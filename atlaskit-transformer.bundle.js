var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module2) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module2) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input2, hint) {
      if (_typeof(input2) !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    module2.exports = _toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module2) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module2.exports = _toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/expand.js
var require_expand = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.expand = void 0;
    function getExpandAttrs(domNode) {
      var dom = domNode;
      return {
        title: dom.getAttribute("data-title"),
        __expanded: true
      };
    }
    var expand = {
      inline: false,
      group: "block",
      marks: "dataConsumer fragment unsupportedMark unsupportedNodeAttribute",
      content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock)+",
      isolating: true,
      selectable: true,
      attrs: {
        title: {
          default: ""
        },
        __expanded: {
          default: true
        }
      },
      parseDOM: [{
        context: "table//",
        tag: 'div[data-node-type="expand"]',
        getAttrs: getExpandAttrs
      }, {
        context: "expand//",
        tag: '[data-node-type="expand"]',
        skip: true
      }, {
        context: "nestedExpand//",
        tag: '[data-node-type="expand"]',
        skip: true
      }, {
        tag: '[data-node-type="nestedExpand"] button',
        ignore: true
      }, {
        tag: '[data-node-type="expand"] button',
        ignore: true
      }, {
        tag: 'div[data-node-type="expand"]',
        getAttrs: getExpandAttrs
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": "expand",
          "data-title": node.attrs.title,
          "data-expanded": node.attrs.__expanded
        };
        return ["div", attrs, 0];
      }
    };
    exports.expand = expand;
    var toJSON = function toJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).filter(function(key) {
          return !key.startsWith("__");
        }).reduce(function(obj, key) {
          obj[key] = node.attrs[key];
          return obj;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-jira-issue.js
var require_confluence_jira_issue = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-jira-issue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.confluenceJiraIssue = void 0;
    var name = "confluenceJiraIssue";
    var confluenceJiraIssue = {
      group: "inline",
      inline: true,
      atom: true,
      attrs: {
        issueKey: {
          default: ""
        },
        macroId: {
          default: null
        },
        schemaVersion: {
          default: null
        },
        server: {
          default: null
        },
        serverId: {
          default: null
        }
      },
      parseDOM: [{
        tag: 'span[data-node-type="'.concat(name, '"]'),
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          return {
            issueKey: dom.textContent,
            macroId: dom.dataset && dom.dataset.macroId,
            schemaVersion: dom.dataset && dom.dataset.schemaVersion,
            server: dom.dataset && dom.dataset.server,
            serverId: dom.dataset && dom.dataset.serverId
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": name,
          "data-macro-id": node.attrs.macroId,
          "data-schema-version": node.attrs.schemaVersion,
          "data-server": node.attrs.server,
          "data-server-id": node.attrs.serverId,
          "data-jira-issue": node.attrs.issueKey
        };
        return ["span", attrs, node.attrs.issueKey];
      }
    };
    exports.confluenceJiraIssue = confluenceJiraIssue;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-unsupported-block.js
var require_confluence_unsupported_block = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-unsupported-block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.confluenceUnsupportedBlock = void 0;
    var name = "confluenceUnsupportedBlock";
    var confluenceUnsupportedBlock = {
      group: "block",
      attrs: {
        cxhtml: {
          default: null
        }
      },
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": name,
          "data-confluence-unsupported": "block",
          "data-confluence-unsupported-block-cxhtml": node.attrs["cxhtml"]
        };
        return ["div", attrs, "Unsupported content"];
      },
      parseDOM: [{
        tag: 'div[data-node-type="'.concat(name, '"]'),
        getAttrs: function getAttrs(dom) {
          return {
            cxhtml: dom.getAttribute("data-confluence-unsupported-block-cxhtml")
          };
        }
      }]
    };
    exports.confluenceUnsupportedBlock = confluenceUnsupportedBlock;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-unsupported-inline.js
var require_confluence_unsupported_inline = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/confluence-unsupported-inline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.confluenceUnsupportedInline = void 0;
    var name = "confluenceUnsupportedInline";
    var confluenceUnsupportedInline = {
      group: "inline",
      inline: true,
      atom: true,
      attrs: {
        cxhtml: {
          default: null
        }
      },
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": name,
          "data-confluence-unsupported": "inline",
          "data-confluence-unsupported-inline-cxhtml": node.attrs["cxhtml"]
        };
        return ["div", attrs, "Unsupported content"];
      },
      parseDOM: [{
        tag: 'div[data-node-type="'.concat(name, '"]'),
        getAttrs: function getAttrs(dom) {
          return {
            cxhtml: dom.getAttribute("data-confluence-unsupported-inline-cxhtml")
          };
        }
      }]
    };
    exports.confluenceUnsupportedInline = confluenceUnsupportedInline;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/doc.js
var require_doc = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/doc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doc = void 0;
    var doc = {
      content: "(block|layoutSection)+",
      marks: "alignment breakout dataConsumer fragment indentation unsupportedMark unsupportedNodeAttribute"
    };
    exports.doc = doc;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/blockquote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.blockquote = void 0;
    var blockquote = {
      content: "(paragraph | unsupportedBlock)+",
      group: "block",
      defining: true,
      selectable: false,
      parseDOM: [{
        tag: "blockquote"
      }],
      toDOM: function toDOM() {
        return ["blockquote", 0];
      }
    };
    exports.blockquote = blockquote;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/bullet-list.js
var require_bullet_list = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/bullet-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bulletListSelector = exports.bulletList = void 0;
    var bulletListSelector = ".ak-ul";
    exports.bulletListSelector = bulletListSelector;
    var bulletList = {
      group: "block",
      content: "listItem+",
      selectable: false,
      parseDOM: [{
        tag: "ul"
      }],
      marks: "unsupportedMark unsupportedNodeAttribute",
      toDOM: function toDOM() {
        var attrs = {
          class: bulletListSelector.substr(1)
        };
        return ["ul", attrs, 0];
      }
    };
    exports.bulletList = bulletList;
  }
});

// node_modules/orderedmap/dist/index-cjs.cjs
var require_index_cjs = __commonJS({
  "node_modules/orderedmap/dist/index-cjs.cjs"(exports, module2) {
    "use strict";
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key)
            return i;
        return -1;
      },
      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found = this.find(key);
        return found == -1 ? void 0 : this.content[found + 1];
      },
      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self2.find(key), content = self2.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey)
            content[found] = newKey;
        }
        return new OrderedMap(content);
      },
      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found = this.find(key);
        if (found == -1)
          return this;
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content);
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map) {
        map = OrderedMap.from(map);
        if (!map.size)
          return this;
        return new OrderedMap(map.content.concat(this.subtract(map).content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map) {
        map = OrderedMap.from(map);
        if (!map.size)
          return this;
        return new OrderedMap(this.subtract(map).content.concat(map.content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i = 0; i < map.content.length; i += 2)
          result = result.remove(map.content[i]);
        return result;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap)
        return value;
      var content = [];
      if (value)
        for (var prop in value)
          content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    module2.exports = OrderedMap;
  }
});

// node_modules/prosemirror-model/dist/index.js
var require_dist = __commonJS({
  "node_modules/prosemirror-model/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OrderedMap = require_index_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var OrderedMap__default = /* @__PURE__ */ _interopDefaultLegacy(OrderedMap);
    function findDiffStart(a, b, pos) {
      for (var i = 0; ; i++) {
        if (i == a.childCount || i == b.childCount) {
          return a.childCount == b.childCount ? null : pos;
        }
        var childA = a.child(i), childB = b.child(i);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB)) {
          return pos;
        }
        if (childA.isText && childA.text != childB.text) {
          for (var j = 0; childA.text[j] == childB.text[j]; j++) {
            pos++;
          }
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null) {
            return inner;
          }
        }
        pos += childA.nodeSize;
      }
    }
    function findDiffEnd(a, b, posA, posB) {
      for (var iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0) {
          return iA == iB ? null : { a: posA, b: posB };
        }
        var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size;
          posB -= size;
          continue;
        }
        if (!childA.sameMarkup(childB)) {
          return { a: posA, b: posB };
        }
        if (childA.isText && childA.text != childB.text) {
          var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return { a: posA, b: posB };
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner) {
            return inner;
          }
        }
        posA -= size;
        posB -= size;
      }
    }
    var Fragment = function Fragment2(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null) {
        for (var i = 0; i < content.length; i++) {
          this.size += content[i].nodeSize;
        }
      }
    };
    var prototypeAccessors = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
    Fragment.prototype.nodesBetween = function nodesBetween(from, to, f, nodeStart, parent) {
      if (nodeStart === void 0)
        nodeStart = 0;
      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i], end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(
            Math.max(0, from - start),
            Math.min(child.content.size, to - start),
            f,
            nodeStart + start
          );
        }
        pos = end;
      }
    };
    Fragment.prototype.descendants = function descendants(f) {
      this.nodesBetween(0, this.size, f);
    };
    Fragment.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
      var text = "", separated = true;
      this.nodesBetween(from, to, function(node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf && leafText) {
          text += leafText;
          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    };
    Fragment.prototype.append = function append(other) {
      if (!other.size) {
        return this;
      }
      if (!this.size) {
        return other;
      }
      var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }
      for (; i < other.content.length; i++) {
        content.push(other.content[i]);
      }
      return new Fragment(content, this.size + other.size);
    };
    Fragment.prototype.cut = function cut(from, to) {
      if (to == null) {
        to = this.size;
      }
      if (from == 0 && to == this.size) {
        return this;
      }
      var result = [], size = 0;
      if (to > from) {
        for (var i = 0, pos = 0; pos < to; i++) {
          var child = this.content[i], end = pos + child.nodeSize;
          if (end > from) {
            if (pos < from || end > to) {
              if (child.isText) {
                child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
              } else {
                child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
              }
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      }
      return new Fragment(result, size);
    };
    Fragment.prototype.cutByIndex = function cutByIndex(from, to) {
      if (from == to) {
        return Fragment.empty;
      }
      if (from == 0 && to == this.content.length) {
        return this;
      }
      return new Fragment(this.content.slice(from, to));
    };
    Fragment.prototype.replaceChild = function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) {
        return this;
      }
      var copy2 = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new Fragment(copy2, size);
    };
    Fragment.prototype.addToStart = function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    };
    Fragment.prototype.addToEnd = function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    };
    Fragment.prototype.eq = function eq(other) {
      if (this.content.length != other.content.length) {
        return false;
      }
      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) {
          return false;
        }
      }
      return true;
    };
    prototypeAccessors.firstChild.get = function() {
      return this.content.length ? this.content[0] : null;
    };
    prototypeAccessors.lastChild.get = function() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    };
    prototypeAccessors.childCount.get = function() {
      return this.content.length;
    };
    Fragment.prototype.child = function child(index) {
      var found2 = this.content[index];
      if (!found2) {
        throw new RangeError("Index " + index + " out of range for " + this);
      }
      return found2;
    };
    Fragment.prototype.maybeChild = function maybeChild(index) {
      return this.content[index];
    };
    Fragment.prototype.forEach = function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    };
    Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
      if (pos === void 0)
        pos = 0;
      return findDiffStart(this, other, pos);
    };
    Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
      if (pos === void 0)
        pos = this.size;
      if (otherPos === void 0)
        otherPos = other.size;
      return findDiffEnd(this, other, pos, otherPos);
    };
    Fragment.prototype.findIndex = function findIndex(pos, round) {
      if (round === void 0)
        round = -1;
      if (pos == 0) {
        return retIndex(0, pos);
      }
      if (pos == this.size) {
        return retIndex(this.content.length, pos);
      }
      if (pos > this.size || pos < 0) {
        throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
      }
      for (var i = 0, curPos = 0; ; i++) {
        var cur = this.child(i), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) {
            return retIndex(i + 1, end);
          }
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    };
    Fragment.prototype.toString = function toString() {
      return "<" + this.toStringInner() + ">";
    };
    Fragment.prototype.toStringInner = function toStringInner() {
      return this.content.join(", ");
    };
    Fragment.prototype.toJSON = function toJSON() {
      return this.content.length ? this.content.map(function(n) {
        return n.toJSON();
      }) : null;
    };
    Fragment.fromJSON = function fromJSON(schema, value) {
      if (!value) {
        return Fragment.empty;
      }
      if (!Array.isArray(value)) {
        throw new RangeError("Invalid input for Fragment.fromJSON");
      }
      return new Fragment(value.map(schema.nodeFromJSON));
    };
    Fragment.fromArray = function fromArray(array) {
      if (!array.length) {
        return Fragment.empty;
      }
      var joined, size = 0;
      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) {
            joined = array.slice(0, i);
          }
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size);
    };
    Fragment.from = function from(nodes) {
      if (!nodes) {
        return Fragment.empty;
      }
      if (nodes instanceof Fragment) {
        return nodes;
      }
      if (Array.isArray(nodes)) {
        return this.fromArray(nodes);
      }
      if (nodes.attrs) {
        return new Fragment([nodes], nodes.nodeSize);
      }
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    };
    Object.defineProperties(Fragment.prototype, prototypeAccessors);
    var found = { index: 0, offset: 0 };
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found;
    }
    Fragment.empty = new Fragment([], 0);
    function compareDeep(a, b) {
      if (a === b) {
        return true;
      }
      if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
        return false;
      }
      var array = Array.isArray(a);
      if (Array.isArray(b) != array) {
        return false;
      }
      if (array) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!compareDeep(a[i], b[i])) {
            return false;
          }
        }
      } else {
        for (var p in a) {
          if (!(p in b) || !compareDeep(a[p], b[p])) {
            return false;
          }
        }
        for (var p$1 in b) {
          if (!(p$1 in a)) {
            return false;
          }
        }
      }
      return true;
    }
    var Mark = function Mark2(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    };
    Mark.prototype.addToSet = function addToSet(set) {
      var copy2, placed = false;
      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) {
          return set;
        }
        if (this.type.excludes(other.type)) {
          if (!copy2) {
            copy2 = set.slice(0, i);
          }
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2) {
              copy2 = set.slice(0, i);
            }
            copy2.push(this);
            placed = true;
          }
          if (copy2) {
            copy2.push(other);
          }
        }
      }
      if (!copy2) {
        copy2 = set.slice();
      }
      if (!placed) {
        copy2.push(this);
      }
      return copy2;
    };
    Mark.prototype.removeFromSet = function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) {
          return set.slice(0, i).concat(set.slice(i + 1));
        }
      }
      return set;
    };
    Mark.prototype.isInSet = function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) {
          return true;
        }
      }
      return false;
    };
    Mark.prototype.eq = function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    };
    Mark.prototype.toJSON = function toJSON() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    };
    Mark.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Mark.fromJSON");
      }
      var type = schema.marks[json.type];
      if (!type) {
        throw new RangeError("There is no mark type " + json.type + " in this schema");
      }
      return type.create(json.attrs);
    };
    Mark.sameSet = function sameSet(a, b) {
      if (a == b) {
        return true;
      }
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) {
          return false;
        }
      }
      return true;
    };
    Mark.setFrom = function setFrom(marks) {
      if (!marks || marks.length == 0) {
        return Mark.none;
      }
      if (marks instanceof Mark) {
        return [marks];
      }
      var copy2 = marks.slice();
      copy2.sort(function(a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy2;
    };
    Mark.none = [];
    function ReplaceError(message) {
      var err = Error.call(this, message);
      err.__proto__ = ReplaceError.prototype;
      return err;
    }
    ReplaceError.prototype = Object.create(Error.prototype);
    ReplaceError.prototype.constructor = ReplaceError;
    ReplaceError.prototype.name = "ReplaceError";
    var Slice = function Slice2(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    };
    var prototypeAccessors$1 = { size: { configurable: true } };
    prototypeAccessors$1.size.get = function() {
      return this.content.size - this.openStart - this.openEnd;
    };
    Slice.prototype.insertAt = function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment, null);
      return content && new Slice(content, this.openStart, this.openEnd);
    };
    Slice.prototype.removeBetween = function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    };
    Slice.prototype.eq = function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    };
    Slice.prototype.toString = function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    };
    Slice.prototype.toJSON = function toJSON() {
      if (!this.content.size) {
        return null;
      }
      var json = { content: this.content.toJSON() };
      if (this.openStart > 0) {
        json.openStart = this.openStart;
      }
      if (this.openEnd > 0) {
        json.openEnd = this.openEnd;
      }
      return json;
    };
    Slice.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        return Slice.empty;
      }
      var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") {
        throw new RangeError("Invalid input for Slice.fromJSON");
      }
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    };
    Slice.maxOpen = function maxOpen(fragment, openIsolating) {
      if (openIsolating === void 0)
        openIsolating = true;
      var openStart = 0, openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }
      for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
        openEnd++;
      }
      return new Slice(fragment, openStart, openEnd);
    };
    Object.defineProperties(Slice.prototype, prototypeAccessors$1);
    function removeRange(content, from, to) {
      var ref = content.findIndex(from);
      var index = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index);
      var ref$1 = content.findIndex(to);
      var indexTo = ref$1.index;
      var offsetTo = ref$1.offset;
      if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText) {
          throw new RangeError("Removing non-flat range");
        }
        return content.cut(0, from).append(content.cut(to));
      }
      if (index != indexTo) {
        throw new RangeError("Removing non-flat range");
      }
      return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      var ref = content.findIndex(dist);
      var index = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert)) {
          return null;
        }
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      var inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index, child.copy(inner));
    }
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    function replace($from, $to, slice) {
      if (slice.openStart > $from.depth) {
        throw new ReplaceError("Inserted content deeper than insertion position");
      }
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd) {
        throw new ReplaceError("Inconsistent open depths");
      }
      return replaceOuter($from, $to, slice, 0);
    }
    function replaceOuter($from, $to, slice, depth) {
      var index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        var inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
        var parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
      } else {
        var ref = prepareSliceForReplace(slice, $from);
        var start = ref.start;
        var end = ref.end;
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type)) {
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
      }
    }
    function joinable($before, $after, depth) {
      var node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      var last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last])) {
        target[last] = child.withText(target[last].text + child.text);
      } else {
        target.push(child);
      }
    }
    function addRange($start, $end, depth, target) {
      var node = ($end || $start).node(depth);
      var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (var i = startIndex; i < endIndex; i++) {
        addNode(node.child(i), target);
      }
      if ($end && $end.depth == depth && $end.textOffset) {
        addNode($end.nodeBefore, target);
      }
    }
    function close(node, content) {
      if (!node.type.validContent(content)) {
        throw new ReplaceError("Invalid content for node " + node.type.name);
      }
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
      var content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart) {
          addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        }
        addRange($start, $end, depth, content);
        if (openEnd) {
          addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
        }
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function replaceTwoWay($from, $to, depth) {
      var content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        var type = joinable($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function prepareSliceForReplace(slice, $along) {
      var extra = $along.depth - slice.openStart, parent = $along.node(extra);
      var node = parent.copy(slice.content);
      for (var i = extra - 1; i >= 0; i--) {
        node = $along.node(i).copy(Fragment.from(node));
      }
      return {
        start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
      };
    }
    var ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.depth = path.length / 3 - 1;
      this.parentOffset = parentOffset;
    };
    var prototypeAccessors$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
    ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
      if (val == null) {
        return this.depth;
      }
      if (val < 0) {
        return this.depth + val;
      }
      return val;
    };
    prototypeAccessors$2.parent.get = function() {
      return this.node(this.depth);
    };
    prototypeAccessors$2.doc.get = function() {
      return this.node(0);
    };
    ResolvedPos.prototype.node = function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    };
    ResolvedPos.prototype.index = function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    };
    ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    };
    ResolvedPos.prototype.start = function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    };
    ResolvedPos.prototype.end = function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    };
    ResolvedPos.prototype.before = function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position before the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    };
    ResolvedPos.prototype.after = function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position after the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    };
    prototypeAccessors$2.textOffset.get = function() {
      return this.pos - this.path[this.path.length - 1];
    };
    prototypeAccessors$2.nodeAfter.get = function() {
      var parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount) {
        return null;
      }
      var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    };
    prototypeAccessors$2.nodeBefore.get = function() {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) {
        return this.parent.child(index).cut(0, dOff);
      }
      return index == 0 ? null : this.parent.child(index - 1);
    };
    ResolvedPos.prototype.posAtIndex = function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var i = 0; i < index; i++) {
        pos += node.child(i).nodeSize;
      }
      return pos;
    };
    ResolvedPos.prototype.marks = function marks() {
      var parent = this.parent, index = this.index();
      if (parent.content.size == 0) {
        return Mark.none;
      }
      if (this.textOffset) {
        return parent.child(index).marks;
      }
      var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }
      var marks2 = main.marks;
      for (var i = 0; i < marks2.length; i++) {
        if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks))) {
          marks2 = marks2[i--].removeFromSet(marks2);
        }
      }
      return marks2;
    };
    ResolvedPos.prototype.marksAcross = function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) {
        return null;
      }
      var marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) {
          marks = marks[i--].removeFromSet(marks);
        }
      }
      return marks;
    };
    ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) {
          return depth;
        }
      }
      return 0;
    };
    ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
      if (other === void 0)
        other = this;
      if (other.pos < this.pos) {
        return other.blockRange(this);
      }
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
          return new NodeRange(this, other, d);
        }
      }
    };
    ResolvedPos.prototype.sameParent = function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    };
    ResolvedPos.prototype.max = function max(other) {
      return other.pos > this.pos ? other : this;
    };
    ResolvedPos.prototype.min = function min(other) {
      return other.pos < this.pos ? other : this;
    };
    ResolvedPos.prototype.toString = function toString() {
      var str = "";
      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }
      return str + ":" + this.parentOffset;
    };
    ResolvedPos.resolve = function resolve(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size)) {
        throw new RangeError("Position " + pos + " out of range");
      }
      var path = [];
      var start = 0, parentOffset = pos;
      for (var node = doc2; ; ) {
        var ref = node.content.findIndex(parentOffset);
        var index = ref.index;
        var offset = ref.offset;
        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) {
          break;
        }
        node = node.child(index);
        if (node.isText) {
          break;
        }
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    };
    ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc2) {
          return cached;
        }
      }
      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    };
    Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);
    var resolveCache = [];
    var resolveCachePos = 0;
    var resolveCacheSize = 12;
    var NodeRange = function NodeRange2($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    };
    var prototypeAccessors$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
    prototypeAccessors$1$1.start.get = function() {
      return this.$from.before(this.depth + 1);
    };
    prototypeAccessors$1$1.end.get = function() {
      return this.$to.after(this.depth + 1);
    };
    prototypeAccessors$1$1.parent.get = function() {
      return this.$from.node(this.depth);
    };
    prototypeAccessors$1$1.startIndex.get = function() {
      return this.$from.index(this.depth);
    };
    prototypeAccessors$1$1.endIndex.get = function() {
      return this.$to.indexAfter(this.depth);
    };
    Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);
    var emptyAttrs = /* @__PURE__ */ Object.create(null);
    var Node2 = function Node3(type, attrs, content, marks) {
      this.type = type;
      this.attrs = attrs;
      this.content = content || Fragment.empty;
      this.marks = marks || Mark.none;
    };
    var prototypeAccessors$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$3.nodeSize.get = function() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    };
    prototypeAccessors$3.childCount.get = function() {
      return this.content.childCount;
    };
    Node2.prototype.child = function child(index) {
      return this.content.child(index);
    };
    Node2.prototype.maybeChild = function maybeChild(index) {
      return this.content.maybeChild(index);
    };
    Node2.prototype.forEach = function forEach(f) {
      this.content.forEach(f);
    };
    Node2.prototype.nodesBetween = function nodesBetween(from, to, f, startPos) {
      if (startPos === void 0)
        startPos = 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    };
    Node2.prototype.descendants = function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    };
    prototypeAccessors$3.textContent.get = function() {
      return this.textBetween(0, this.content.size, "");
    };
    Node2.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    };
    prototypeAccessors$3.firstChild.get = function() {
      return this.content.firstChild;
    };
    prototypeAccessors$3.lastChild.get = function() {
      return this.content.lastChild;
    };
    Node2.prototype.eq = function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    };
    Node2.prototype.sameMarkup = function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    };
    Node2.prototype.hasMarkup = function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    };
    Node2.prototype.copy = function copy2(content) {
      if (content === void 0)
        content = null;
      if (content == this.content) {
        return this;
      }
      return new this.constructor(this.type, this.attrs, content, this.marks);
    };
    Node2.prototype.mark = function mark(marks) {
      return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);
    };
    Node2.prototype.cut = function cut(from, to) {
      if (from == 0 && to == this.content.size) {
        return this;
      }
      return this.copy(this.content.cut(from, to));
    };
    Node2.prototype.slice = function slice(from, to, includeParents) {
      if (to === void 0)
        to = this.content.size;
      if (includeParents === void 0)
        includeParents = false;
      if (from == to) {
        return Slice.empty;
      }
      var $from = this.resolve(from), $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth), node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    };
    Node2.prototype.replace = function replace$1(from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice);
    };
    Node2.prototype.nodeAt = function nodeAt(pos) {
      for (var node = this; ; ) {
        var ref = node.content.findIndex(pos);
        var index = ref.index;
        var offset = ref.offset;
        node = node.maybeChild(index);
        if (!node) {
          return null;
        }
        if (offset == pos || node.isText) {
          return node;
        }
        pos -= offset + 1;
      }
    };
    Node2.prototype.childAfter = function childAfter(pos) {
      var ref = this.content.findIndex(pos);
      var index = ref.index;
      var offset = ref.offset;
      return { node: this.content.maybeChild(index), index, offset };
    };
    Node2.prototype.childBefore = function childBefore(pos) {
      if (pos == 0) {
        return { node: null, index: 0, offset: 0 };
      }
      var ref = this.content.findIndex(pos);
      var index = ref.index;
      var offset = ref.offset;
      if (offset < pos) {
        return { node: this.content.child(index), index, offset };
      }
      var node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset - node.nodeSize };
    };
    Node2.prototype.resolve = function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    };
    Node2.prototype.resolveNoCache = function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    };
    Node2.prototype.rangeHasMark = function rangeHasMark(from, to, type) {
      var found2 = false;
      if (to > from) {
        this.nodesBetween(from, to, function(node) {
          if (type.isInSet(node.marks)) {
            found2 = true;
          }
          return !found2;
        });
      }
      return found2;
    };
    prototypeAccessors$3.isBlock.get = function() {
      return this.type.isBlock;
    };
    prototypeAccessors$3.isTextblock.get = function() {
      return this.type.isTextblock;
    };
    prototypeAccessors$3.inlineContent.get = function() {
      return this.type.inlineContent;
    };
    prototypeAccessors$3.isInline.get = function() {
      return this.type.isInline;
    };
    prototypeAccessors$3.isText.get = function() {
      return this.type.isText;
    };
    prototypeAccessors$3.isLeaf.get = function() {
      return this.type.isLeaf;
    };
    prototypeAccessors$3.isAtom.get = function() {
      return this.type.isAtom;
    };
    Node2.prototype.toString = function toString() {
      if (this.type.spec.toDebugString) {
        return this.type.spec.toDebugString(this);
      }
      var name = this.type.name;
      if (this.content.size) {
        name += "(" + this.content.toStringInner() + ")";
      }
      return wrapMarks(this.marks, name);
    };
    Node2.prototype.contentMatchAt = function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) {
        throw new Error("Called contentMatchAt on a node with invalid content");
      }
      return match;
    };
    Node2.prototype.canReplace = function canReplace(from, to, replacement, start, end) {
      if (replacement === void 0)
        replacement = Fragment.empty;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = replacement.childCount;
      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) {
        return false;
      }
      for (var i = start; i < end; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    Node2.prototype.canReplaceWith = function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) {
        return false;
      }
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    };
    Node2.prototype.canAppend = function canAppend(other) {
      if (other.content.size) {
        return this.canReplace(this.childCount, this.childCount, other.content);
      } else {
        return this.type.compatibleContent(other.type);
      }
    };
    Node2.prototype.check = function check() {
      if (!this.type.validContent(this.content)) {
        throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
      }
      var copy2 = Mark.none;
      for (var i = 0; i < this.marks.length; i++) {
        copy2 = this.marks[i].addToSet(copy2);
      }
      if (!Mark.sameSet(copy2, this.marks)) {
        throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
          return m.type.name;
        }));
      }
      this.content.forEach(function(node) {
        return node.check();
      });
    };
    Node2.prototype.toJSON = function toJSON() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) {
        obj.content = this.content.toJSON();
      }
      if (this.marks.length) {
        obj.marks = this.marks.map(function(n) {
          return n.toJSON();
        });
      }
      return obj;
    };
    Node2.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Node.fromJSON");
      }
      var marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks)) {
          throw new RangeError("Invalid mark data for Node.fromJSON");
        }
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") {
          throw new RangeError("Invalid text node in JSON");
        }
        return schema.text(json.text, marks);
      }
      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    };
    Object.defineProperties(Node2.prototype, prototypeAccessors$3);
    var TextNode = /* @__PURE__ */ function(Node3) {
      function TextNode2(type, attrs, content, marks) {
        Node3.call(this, type, attrs, null, marks);
        if (!content) {
          throw new RangeError("Empty text nodes are not allowed");
        }
        this.text = content;
      }
      if (Node3)
        TextNode2.__proto__ = Node3;
      TextNode2.prototype = Object.create(Node3 && Node3.prototype);
      TextNode2.prototype.constructor = TextNode2;
      var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
      TextNode2.prototype.toString = function toString() {
        if (this.type.spec.toDebugString) {
          return this.type.spec.toDebugString(this);
        }
        return wrapMarks(this.marks, JSON.stringify(this.text));
      };
      prototypeAccessors$12.textContent.get = function() {
        return this.text;
      };
      TextNode2.prototype.textBetween = function textBetween(from, to) {
        return this.text.slice(from, to);
      };
      prototypeAccessors$12.nodeSize.get = function() {
        return this.text.length;
      };
      TextNode2.prototype.mark = function mark(marks) {
        return marks == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks);
      };
      TextNode2.prototype.withText = function withText(text) {
        if (text == this.text) {
          return this;
        }
        return new TextNode2(this.type, this.attrs, text, this.marks);
      };
      TextNode2.prototype.cut = function cut(from, to) {
        if (from === void 0)
          from = 0;
        if (to === void 0)
          to = this.text.length;
        if (from == 0 && to == this.text.length) {
          return this;
        }
        return this.withText(this.text.slice(from, to));
      };
      TextNode2.prototype.eq = function eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
      };
      TextNode2.prototype.toJSON = function toJSON() {
        var base = Node3.prototype.toJSON.call(this);
        base.text = this.text;
        return base;
      };
      Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
      return TextNode2;
    }(Node2);
    function wrapMarks(marks, str) {
      for (var i = marks.length - 1; i >= 0; i--) {
        str = marks[i].type.name + "(" + str + ")";
      }
      return str;
    }
    var ContentMatch = function ContentMatch2(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    };
    var prototypeAccessors$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
    ContentMatch.parse = function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) {
        return ContentMatch.empty;
      }
      var expr = parseExpr(stream);
      if (stream.next) {
        stream.err("Unexpected trailing text");
      }
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    };
    ContentMatch.prototype.matchType = function matchType(type) {
      for (var i = 0; i < this.next.length; i += 2) {
        if (this.next[i] == type) {
          return this.next[i + 1];
        }
      }
      return null;
    };
    ContentMatch.prototype.matchFragment = function matchFragment(frag, start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = frag.childCount;
      var cur = this;
      for (var i = start; cur && i < end; i++) {
        cur = cur.matchType(frag.child(i).type);
      }
      return cur;
    };
    prototypeAccessors$4.inlineContent.get = function() {
      var first = this.next[0];
      return first ? first.isInline : false;
    };
    prototypeAccessors$4.defaultType.get = function() {
      for (var i = 0; i < this.next.length; i += 2) {
        var type = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs())) {
          return type;
        }
      }
    };
    ContentMatch.prototype.compatible = function compatible(other) {
      for (var i = 0; i < this.next.length; i += 2) {
        for (var j = 0; j < other.next.length; j += 2) {
          if (this.next[i] == other.next[j]) {
            return true;
          }
        }
      }
      return false;
    };
    ContentMatch.prototype.fillBefore = function fillBefore(after, toEnd, startIndex) {
      if (toEnd === void 0)
        toEnd = false;
      if (startIndex === void 0)
        startIndex = 0;
      var seen = [this];
      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) {
          return Fragment.from(types.map(function(tp) {
            return tp.createAndFill();
          }));
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i], next = match.next[i + 1];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var found2 = search(next, types.concat(type));
            if (found2) {
              return found2;
            }
          }
        }
      }
      return search(this, []);
    };
    ContentMatch.prototype.findWrapping = function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target) {
          return this.wrapCache[i + 1];
        }
      }
      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    };
    ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
      var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        var current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          var result = [];
          for (var obj = current; obj.type; obj = obj.via) {
            result.push(obj.type);
          }
          return result.reverse();
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
    };
    prototypeAccessors$4.edgeCount.get = function() {
      return this.next.length >> 1;
    };
    ContentMatch.prototype.edge = function edge(n) {
      var i = n << 1;
      if (i >= this.next.length) {
        throw new RangeError("There's no " + n + "th edge in this content match");
      }
      return { type: this.next[i], next: this.next[i + 1] };
    };
    ContentMatch.prototype.toString = function toString() {
      var seen = [];
      function scan(m) {
        seen.push(m);
        for (var i = 1; i < m.next.length; i += 2) {
          if (seen.indexOf(m.next[i]) == -1) {
            scan(m.next[i]);
          }
        }
      }
      scan(this);
      return seen.map(function(m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";
        for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
          out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
        }
        return out;
      }).join("\n");
    };
    Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4);
    ContentMatch.empty = new ContentMatch(true);
    var TokenStream = function TokenStream2(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") {
        this.tokens.pop();
      }
      if (this.tokens[0] == "") {
        this.tokens.shift();
      }
    };
    var prototypeAccessors$1$2 = { next: { configurable: true } };
    prototypeAccessors$1$2.next.get = function() {
      return this.tokens[this.pos];
    };
    TokenStream.prototype.eat = function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    };
    TokenStream.prototype.err = function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    };
    Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);
    function parseExpr(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    }
    function parseExprSeq(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
    }
    function parseExprSubscript(stream) {
      var expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+")) {
          expr = { type: "plus", expr };
        } else if (stream.eat("*")) {
          expr = { type: "star", expr };
        } else if (stream.eat("?")) {
          expr = { type: "opt", expr };
        } else if (stream.eat("{")) {
          expr = parseExprRange(stream, expr);
        } else {
          break;
        }
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next)) {
        stream.err("Expected number, got '" + stream.next + "'");
      }
      var result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      var min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}") {
          max = parseNum(stream);
        } else {
          max = -1;
        }
      }
      if (!stream.eat("}")) {
        stream.err("Unclosed braced range");
      }
      return { type: "range", min, max, expr };
    }
    function resolveName(stream, name) {
      var types = stream.nodeTypes, type = types[name];
      if (type) {
        return [type];
      }
      var result = [];
      for (var typeName in types) {
        var type$1 = types[typeName];
        if (type$1.groups.indexOf(name) > -1) {
          result.push(type$1);
        }
      }
      if (result.length == 0) {
        stream.err("No node type or group '" + name + "' found");
      }
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        var expr = parseExpr(stream);
        if (!stream.eat(")")) {
          stream.err("Missing closing paren");
        }
        return expr;
      } else if (!/\W/.test(stream.next)) {
        var exprs = resolveName(stream, stream.next).map(function(type) {
          if (stream.inline == null) {
            stream.inline = type.isInline;
          } else if (stream.inline != type.isInline) {
            stream.err("Mixing inline and block content");
          }
          return { type: "name", value: type };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      var nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from, to, term) {
        var edge2 = { term, to };
        nfa2[from].push(edge2);
        return edge2;
      }
      function connect(edges, to) {
        edges.forEach(function(edge2) {
          return edge2.to = to;
        });
      }
      function compile(expr2, from) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce(function(out, expr3) {
            return out.concat(compile(expr3, from));
          }, []);
        } else if (expr2.type == "seq") {
          for (var i = 0; ; i++) {
            var next = compile(expr2.exprs[i], from);
            if (i == expr2.exprs.length - 1) {
              return next;
            }
            connect(next, from = node());
          }
        } else if (expr2.type == "star") {
          var loop = node();
          edge(from, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          var loop$1 = node();
          connect(compile(expr2.expr, from), loop$1);
          connect(compile(expr2.expr, loop$1), loop$1);
          return [edge(loop$1)];
        } else if (expr2.type == "opt") {
          return [edge(from)].concat(compile(expr2.expr, from));
        } else if (expr2.type == "range") {
          var cur = from;
          for (var i$1 = 0; i$1 < expr2.min; i$1++) {
            var next$1 = node();
            connect(compile(expr2.expr, cur), next$1);
            cur = next$1;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
              var next$2 = node();
              edge(cur, next$2);
              connect(compile(expr2.expr, cur), next$2);
              cur = next$2;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from, null, expr2.value)];
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      var result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        var edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term) {
          return scan(edges[0].to);
        }
        result.push(node2);
        for (var i = 0; i < edges.length; i++) {
          var ref = edges[i];
          var term = ref.term;
          var to = ref.to;
          if (!term && result.indexOf(to) == -1) {
            scan(to);
          }
        }
      }
    }
    function dfa(nfa2) {
      var labeled = /* @__PURE__ */ Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        var out = [];
        states.forEach(function(node) {
          nfa2[node].forEach(function(ref) {
            var term = ref.term;
            var to = ref.to;
            if (!term) {
              return;
            }
            var known = out.indexOf(term), set = known > -1 && out[known + 1];
            nullFrom(nfa2, to).forEach(function(node2) {
              if (!set) {
                out.push(term, set = []);
              }
              if (set.indexOf(node2) == -1) {
                set.push(node2);
              }
            });
          });
        });
        var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (var i = 0; i < out.length; i += 2) {
          var states$1 = out[i + 1].sort(cmp);
          state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
        }
        return state;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (var i = 0, work = [match]; i < work.length; i++) {
        var state = work[i], dead = !state.validEnd, nodes = [];
        for (var j = 0; j < state.next.length; j += 2) {
          var node = state.next[j], next = state.next[j + 1];
          nodes.push(node.name);
          if (dead && !(node.isText || node.hasRequiredAttrs())) {
            dead = false;
          }
          if (work.indexOf(next) == -1) {
            work.push(next);
          }
        }
        if (dead) {
          stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
        }
      }
    }
    function defaultAttrs(attrs) {
      var defaults = /* @__PURE__ */ Object.create(null);
      for (var attrName in attrs) {
        var attr = attrs[attrName];
        if (!attr.hasDefault) {
          return null;
        }
        defaults[attrName] = attr.default;
      }
      return defaults;
    }
    function computeAttrs(attrs, value) {
      var built = /* @__PURE__ */ Object.create(null);
      for (var name in attrs) {
        var given = value && value[name];
        if (given === void 0) {
          var attr = attrs[name];
          if (attr.hasDefault) {
            given = attr.default;
          } else {
            throw new RangeError("No value supplied for attribute " + name);
          }
        }
        built[name] = given;
      }
      return built;
    }
    function initAttrs(attrs) {
      var result = /* @__PURE__ */ Object.create(null);
      if (attrs) {
        for (var name in attrs) {
          result[name] = new Attribute(attrs[name]);
        }
      }
      return result;
    }
    var NodeType = function NodeType2(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.markSet = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    };
    var prototypeAccessors$5 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$5.isInline.get = function() {
      return !this.isBlock;
    };
    prototypeAccessors$5.isTextblock.get = function() {
      return this.isBlock && this.inlineContent;
    };
    prototypeAccessors$5.isLeaf.get = function() {
      return this.contentMatch == ContentMatch.empty;
    };
    prototypeAccessors$5.isAtom.get = function() {
      return this.isLeaf || this.spec.atom;
    };
    NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) {
          return true;
        }
      }
      return false;
    };
    NodeType.prototype.compatibleContent = function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    };
    NodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {
      if (!attrs && this.defaultAttrs) {
        return this.defaultAttrs;
      } else {
        return computeAttrs(this.attrs, attrs);
      }
    };
    NodeType.prototype.create = function create(attrs, content, marks) {
      if (this.isText) {
        throw new Error("NodeType.create can't construct text nodes");
      }
      return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    };
    NodeType.prototype.createChecked = function createChecked(attrs, content, marks) {
      content = Fragment.from(content);
      if (!this.validContent(content)) {
        throw new RangeError("Invalid content for node " + this.name);
      }
      return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    };
    NodeType.prototype.createAndFill = function createAndFill(attrs, content, marks) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) {
          return null;
        }
        content = before.append(content);
      }
      var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
      if (!after) {
        return null;
      }
      return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
    };
    NodeType.prototype.validContent = function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) {
        return false;
      }
      for (var i = 0; i < content.childCount; i++) {
        if (!this.allowsMarks(content.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowsMarkType = function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    };
    NodeType.prototype.allowsMarks = function allowsMarks(marks) {
      if (this.markSet == null) {
        return true;
      }
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowedMarks = function allowedMarks(marks) {
      if (this.markSet == null) {
        return marks;
      }
      var copy2;
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy2) {
            copy2 = marks.slice(0, i);
          }
        } else if (copy2) {
          copy2.push(marks[i]);
        }
      }
      return !copy2 ? marks : copy2.length ? copy2 : Mark.empty;
    };
    NodeType.compile = function compile(nodes, schema) {
      var result = /* @__PURE__ */ Object.create(null);
      nodes.forEach(function(name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) {
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      }
      if (!result.text) {
        throw new RangeError("Every schema needs a 'text' type");
      }
      for (var _ in result.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }
      return result;
    };
    Object.defineProperties(NodeType.prototype, prototypeAccessors$5);
    var Attribute = function Attribute2(options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
    };
    var prototypeAccessors$1$3 = { isRequired: { configurable: true } };
    prototypeAccessors$1$3.isRequired.get = function() {
      return !this.hasDefault;
    };
    Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3);
    var MarkType = function MarkType2(name, rank, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(spec.attrs);
      this.rank = rank;
      this.excluded = null;
      var defaults = defaultAttrs(this.attrs);
      this.instance = defaults && new Mark(this, defaults);
    };
    MarkType.prototype.create = function create(attrs) {
      if (!attrs && this.instance) {
        return this.instance;
      }
      return new Mark(this, computeAttrs(this.attrs, attrs));
    };
    MarkType.compile = function compile(marks, schema) {
      var result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks.forEach(function(name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    };
    MarkType.prototype.removeFromSet = function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      }
      return set;
    };
    MarkType.prototype.isInSet = function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          return set[i];
        }
      }
    };
    MarkType.prototype.excludes = function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    };
    var Schema = function Schema2(spec) {
      this.spec = {};
      for (var prop in spec) {
        this.spec[prop] = spec[prop];
      }
      this.spec.nodes = OrderedMap__default["default"].from(spec.nodes);
      this.spec.marks = OrderedMap__default["default"].from(spec.marks);
      this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      var contentExprCache = /* @__PURE__ */ Object.create(null);
      for (var prop$1 in this.nodes) {
        if (prop$1 in this.marks) {
          throw new RangeError(prop$1 + " can not be both a node and a mark");
        }
        var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (var prop$2 in this.marks) {
        var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
        type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached = /* @__PURE__ */ Object.create(null);
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    };
    Schema.prototype.node = function node(type, attrs, content, marks) {
      if (typeof type == "string") {
        type = this.nodeType(type);
      } else if (!(type instanceof NodeType)) {
        throw new RangeError("Invalid node type: " + type);
      } else if (type.schema != this) {
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      }
      return type.createChecked(attrs, content, marks);
    };
    Schema.prototype.text = function text(text$1, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks));
    };
    Schema.prototype.mark = function mark(type, attrs) {
      if (typeof type == "string") {
        type = this.marks[type];
      }
      return type.create(attrs);
    };
    Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
      return Node2.fromJSON(this, json);
    };
    Schema.prototype.markFromJSON = function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    };
    Schema.prototype.nodeType = function nodeType(name) {
      var found2 = this.nodes[name];
      if (!found2) {
        throw new RangeError("Unknown node type: " + name);
      }
      return found2;
    };
    function gatherMarks(schema, marks) {
      var found2 = [];
      for (var i = 0; i < marks.length; i++) {
        var name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (var prop in schema.marks) {
            var mark$1 = schema.marks[prop];
            if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
              found2.push(ok = mark$1);
            }
          }
        }
        if (!ok) {
          throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
        }
      }
      return found2;
    }
    var DOMParser = function DOMParser2(schema, rules) {
      var this$1 = this;
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach(function(rule) {
        if (rule.tag) {
          this$1.tags.push(rule);
        } else if (rule.style) {
          this$1.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some(function(r) {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
          return false;
        }
        var node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    };
    DOMParser.prototype.parse = function parse(dom, options) {
      if (options === void 0)
        options = {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, null, options.from, options.to);
      return context.finish();
    };
    DOMParser.prototype.parseSlice = function parseSlice(dom, options) {
      if (options === void 0)
        options = {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, null, options.from, options.to);
      return Slice.maxOpen(context.finish());
    };
    DOMParser.prototype.matchTag = function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) {
              continue;
            }
            rule.attrs = result;
          }
          return rule;
        }
      }
    };
    DOMParser.prototype.matchStyle = function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i];
        if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
          continue;
        }
        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) {
            continue;
          }
          rule.attrs = result;
        }
        return rule;
      }
    };
    DOMParser.schemaRules = function schemaRules(schema) {
      var result = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) {
            break;
          }
        }
        result.splice(i, 0, rule);
      }
      var loop = function(name2) {
        var rules = schema.marks[name2].spec.parseDOM;
        if (rules) {
          rules.forEach(function(rule) {
            insert(rule = copy(rule));
            rule.mark = name2;
          });
        }
      };
      for (var name in schema.marks)
        loop(name);
      var loop$1 = function(name2) {
        var rules$1 = schema.nodes[name$1].spec.parseDOM;
        if (rules$1) {
          rules$1.forEach(function(rule) {
            insert(rule = copy(rule));
            rule.node = name$1;
          });
        }
      };
      for (var name$1 in schema.nodes)
        loop$1();
      return result;
    };
    DOMParser.fromSchema = function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    };
    var blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    var ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    var listTags = { ol: true, ul: true };
    var OPT_PRESERVE_WS = 1;
    var OPT_PRESERVE_WS_FULL = 2;
    var OPT_OPEN_LEFT = 4;
    function wsOptionsFor(preserveWhitespace) {
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    }
    var NodeContext = function NodeContext2(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.solid = solid;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      this.options = options;
      this.content = [];
      this.marks = marks;
      this.activeMarks = Mark.none;
      this.pendingMarks = pendingMarks;
      this.stashMarks = [];
    };
    NodeContext.prototype.findWrapping = function findWrapping(node) {
      if (!this.match) {
        if (!this.type) {
          return [];
        }
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch, wrap;
          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    };
    NodeContext.prototype.finish = function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          if (last.text.length == m[0].length) {
            this.content.pop();
          } else {
            this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
          }
        }
      }
      var content = Fragment.from(this.content);
      if (!openEnd && this.match) {
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      }
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    };
    NodeContext.prototype.popFromStashMark = function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark.eq(this.stashMarks[i])) {
          return this.stashMarks.splice(i, 1)[0];
        }
      }
    };
    NodeContext.prototype.applyPending = function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    };
    NodeContext.prototype.inlineContext = function inlineContext(node) {
      if (this.type) {
        return this.type.inlineContent;
      }
      if (this.content.length) {
        return this.content[0].isInline;
      }
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    };
    var ParseContext = function ParseContext2(parser, options, open) {
      this.parser = parser;
      this.options = options;
      this.isOpen = open;
      var topNode = options.topNode, topContext;
      var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
      if (topNode) {
        topContext = new NodeContext(
          topNode.type,
          topNode.attrs,
          Mark.none,
          Mark.none,
          true,
          options.topMatch || topNode.type.contentMatch,
          topOptions
        );
      } else if (open) {
        topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
      } else {
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
      }
      this.nodes = [topContext];
      this.open = 0;
      this.find = options.findPositions;
      this.needsBlock = false;
    };
    var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
    prototypeAccessors$6.top.get = function() {
      return this.nodes[this.open];
    };
    ParseContext.prototype.addDOM = function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
        if (marks != null) {
          for (var i = 0; i < marks.length; i++) {
            this.addPendingMark(marks[i]);
          }
        }
        this.addElement(dom);
        if (marks != null) {
          for (var i$1 = 0; i$1 < marks.length; i$1++) {
            this.removePendingMark(marks[i$1], top);
          }
        }
      }
    };
    ParseContext.prototype.addTextNode = function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
              value = value.slice(1);
            }
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) {
          this.insertNode(this.parser.schema.text(value));
        }
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    };
    ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
        normalizeList(dom);
      }
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) {
          this.open = Math.max(0, this.open - 1);
        } else if (rule && rule.skip.nodeType) {
          dom = rule.skip;
        }
        var sync, top = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          sync = true;
          if (!top.type) {
            this.needsBlock = true;
          }
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        this.addAll(dom);
        if (sync) {
          this.sync(top);
        }
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
      }
    };
    ParseContext.prototype.leafFallback = function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
      }
    };
    ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
        this.findPlace(this.parser.schema.text("-"));
      }
    };
    ParseContext.prototype.readStyles = function readStyles(styles) {
      var marks = Mark.none;
      style:
        for (var i = 0; i < styles.length; i += 2) {
          for (var after = null; ; ) {
            var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
            if (!rule) {
              continue style;
            }
            if (rule.ignore) {
              return null;
            }
            marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
            if (rule.consuming === false) {
              after = rule;
            } else {
              break;
            }
          }
        }
      return marks;
    };
    ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
      var this$1 = this;
      var sync, nodeType, markType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      var startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function(node) {
          return this$1.insertNode(node);
        });
      } else {
        var contentDOM = rule.contentElement;
        if (typeof contentDOM == "string") {
          contentDOM = dom.querySelector(contentDOM);
        } else if (typeof contentDOM == "function") {
          contentDOM = contentDOM(dom);
        }
        if (!contentDOM) {
          contentDOM = dom;
        }
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, sync);
      }
      if (sync) {
        this.sync(startIn);
        this.open--;
      }
      if (mark) {
        this.removePendingMark(mark, startIn);
      }
    };
    ParseContext.prototype.addAll = function addAll(parent, sync, startIndex, endIndex) {
      var index = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
        if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
          this.sync(sync);
        }
      }
      this.findAtPoint(parent, index);
    };
    ParseContext.prototype.findPlace = function findPlace(node) {
      var route, sync;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length) {
            break;
          }
        }
        if (cx.solid) {
          break;
        }
      }
      if (!route) {
        return false;
      }
      this.sync(sync);
      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }
      return true;
    };
    ParseContext.prototype.insertNode = function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) {
          this.enterInner(block);
        }
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) {
          top.match = top.match.matchType(node.type);
        }
        var marks = top.activeMarks;
        for (var i = 0; i < node.marks.length; i++) {
          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) {
            marks = node.marks[i].addToSet(marks);
          }
        }
        top.content.push(node.mark(marks));
        return true;
      }
      return false;
    };
    ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) {
        this.enterInner(type, attrs, true, preserveWS);
      }
      return ok;
    };
    ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type, attrs);
      var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {
        options |= OPT_OPEN_LEFT;
      }
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    };
    ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }
        this.nodes.length = this.open + 1;
      }
    };
    ParseContext.prototype.finish = function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    };
    ParseContext.prototype.sync = function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return;
        }
      }
    };
    prototypeAccessors$6.currentPos.get = function() {
      this.closeExtra();
      var pos = 0;
      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;
        for (var j = content.length - 1; j >= 0; j--) {
          pos += content[j].nodeSize;
        }
        if (i) {
          pos++;
        }
      }
      return pos;
    };
    ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findInside = function findInside(parent) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findAround = function findAround(parent, content, before) {
      if (parent != content && this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            var pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4)) {
              this.find[i].pos = this.currentPos;
            }
          }
        }
      }
    };
    ParseContext.prototype.findInText = function findInText(textNode) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode) {
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
          }
        }
      }
    };
    ParseContext.prototype.matchesContext = function matchesContext(context) {
      var this$1 = this;
      if (context.indexOf("|") > -1) {
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      }
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) {
              continue;
            }
            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) {
                return true;
              }
            }
            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) {
              return false;
            }
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    };
    ParseContext.prototype.textblockFromContext = function textblockFromContext() {
      var $context = this.options.context;
      if ($context) {
        for (var d = $context.depth; d >= 0; d--) {
          var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
            return deflt;
          }
        }
      }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) {
          return type;
        }
      }
    };
    ParseContext.prototype.addPendingMark = function addPendingMark(mark) {
      var found2 = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found2) {
        this.top.stashMarks.push(found2);
      }
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    };
    ParseContext.prototype.removePendingMark = function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];
        var found2 = level.pendingMarks.lastIndexOf(mark);
        if (found2 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
            level.activeMarks = stashMark.addToSet(level.activeMarks);
          }
        }
        if (level == upto) {
          break;
        }
      }
    };
    Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
    function normalizeList(dom) {
      for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function parseStyles(style) {
      var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
      while (m = re.exec(style)) {
        result.push(m[1], m[2].trim());
      }
      return result;
    }
    function copy(obj) {
      var copy2 = {};
      for (var prop in obj) {
        copy2[prop] = obj[prop];
      }
      return copy2;
    }
    function markMayApply(markType, nodeType) {
      var nodes = nodeType.schema.nodes;
      var loop = function(name2) {
        var parent = nodes[name2];
        if (!parent.allowsMarkType(markType)) {
          return;
        }
        var seen = [], scan = function(match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var ref = match.edge(i);
            var type = ref.type;
            var next = ref.next;
            if (type == nodeType) {
              return true;
            }
            if (seen.indexOf(next) < 0 && scan(next)) {
              return true;
            }
          }
        };
        if (scan(parent.contentMatch)) {
          return { v: true };
        }
      };
      for (var name in nodes) {
        var returned = loop(name);
        if (returned)
          return returned.v;
      }
    }
    function findSameMarkInSet(mark, set) {
      for (var i = 0; i < set.length; i++) {
        if (mark.eq(set[i])) {
          return set[i];
        }
      }
    }
    var DOMSerializer = function DOMSerializer2(nodes, marks) {
      this.nodes = nodes || {};
      this.marks = marks || {};
    };
    DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
      var this$1 = this;
      if (options === void 0)
        options = {};
      if (!target) {
        target = doc(options).createDocumentFragment();
      }
      var top = target, active = null;
      fragment.forEach(function(node) {
        if (active || node.marks.length) {
          if (!active) {
            active = [];
          }
          var keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];
            if (!this$1.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
              break;
            }
            keep += 2;
            rendered++;
          }
          while (keep < active.length) {
            top = active.pop();
            active.pop();
          }
          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];
            var markDOM = this$1.serializeMark(add, node.isInline, options);
            if (markDOM) {
              active.push(add, top);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this$1.serializeNodeInner(node, options));
      });
      return target;
    };
    DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node, options) {
      if (options === void 0)
        options = {};
      var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
      var dom = ref.dom;
      var contentDOM = ref.contentDOM;
      if (contentDOM) {
        if (node.isLeaf) {
          throw new RangeError("Content hole not allowed in a leaf node spec");
        }
        if (options.onContent) {
          options.onContent(node, contentDOM, options);
        } else {
          this.serializeFragment(node.content, options, contentDOM);
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeNode = function serializeNode(node, options) {
      if (options === void 0)
        options = {};
      var dom = this.serializeNodeInner(node, options);
      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);
        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeMark = function serializeMark(mark, inline, options) {
      if (options === void 0)
        options = {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    };
    DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
      if (xmlNS === void 0)
        xmlNS = null;
      if (typeof structure == "string") {
        return { dom: doc2.createTextNode(structure) };
      }
      if (structure.nodeType != null) {
        return { dom: structure };
      }
      if (structure.dom && structure.dom.nodeType != null) {
        return structure;
      }
      var tagName = structure[0], space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      var attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (var name in attrs) {
          if (attrs[name] != null) {
            var space$1 = name.indexOf(" ");
            if (space$1 > 0) {
              dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
            } else {
              dom.setAttribute(name, attrs[name]);
            }
          }
        }
      }
      for (var i = start; i < structure.length; i++) {
        var child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start) {
            throw new RangeError("Content hole must be the only child of its parent node");
          }
          return { dom, contentDOM: dom };
        } else {
          var ref = DOMSerializer.renderSpec(doc2, child, xmlNS);
          var inner = ref.dom;
          var innerContent = ref.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) {
              throw new RangeError("Multiple content holes");
            }
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    };
    DOMSerializer.fromSchema = function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    };
    DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) {
        result.text = function(node) {
          return node.text;
        };
      }
      return result;
    };
    DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    };
    function gatherToDOM(obj) {
      var result = {};
      for (var name in obj) {
        var toDOM = obj[name].spec.toDOM;
        if (toDOM) {
          result[name] = toDOM;
        }
      }
      return result;
    }
    function doc(options) {
      return options.document || window.document;
    }
    exports.ContentMatch = ContentMatch;
    exports.DOMParser = DOMParser;
    exports.DOMSerializer = DOMSerializer;
    exports.Fragment = Fragment;
    exports.Mark = Mark;
    exports.MarkType = MarkType;
    exports.Node = Node2;
    exports.NodeRange = NodeRange;
    exports.NodeType = NodeType;
    exports.ReplaceError = ReplaceError;
    exports.ResolvedPos = ResolvedPos;
    exports.Schema = Schema;
    exports.Slice = Slice;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/code-block.js
var require_code_block = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/code-block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.codeBlock = void 0;
    var _prosemirrorModel = require_dist();
    var getLanguageFromEditorStyle = function getLanguageFromEditorStyle2(dom) {
      return dom.getAttribute("data-language") || void 0;
    };
    var getLanguageFromBitbucketStyle = function getLanguageFromBitbucketStyle2(dom) {
      if (dom && dom.classList.contains("codehilite")) {
        return extractLanguageFromClass(dom.className);
      }
      return;
    };
    var getLanguageFromCode = function getLanguageFromCode2(dom) {
      var firstChild = dom.firstElementChild;
      if (firstChild && firstChild.nodeName === "CODE") {
        return firstChild.getAttribute("data-language") || void 0;
      }
    };
    var extractLanguageFromClass = function extractLanguageFromClass2(className) {
      var languageRegex = /(?:^|\s)language-([^\s]+)/;
      var result = languageRegex.exec(className);
      if (result && result[1]) {
        return result[1];
      }
      return;
    };
    var removeLastNewLine = function removeLastNewLine2(dom) {
      var parent = dom && dom.parentElement;
      if (parent && parent.classList.contains("codehilite")) {
        dom.textContent = dom.textContent.replace(/\n$/, "");
      }
      return dom;
    };
    var codeBlock = {
      attrs: {
        language: {
          default: null
        },
        uniqueId: {
          default: null
        }
      },
      content: "(text | unsupportedInline)*",
      marks: "unsupportedMark unsupportedNodeAttribute",
      group: "block",
      code: true,
      defining: true,
      parseDOM: [
        {
          tag: "pre",
          preserveWhitespace: "full",
          getAttrs: function getAttrs(domNode) {
            var dom = domNode;
            var language = getLanguageFromBitbucketStyle(dom.parentElement) || getLanguageFromEditorStyle(dom.parentElement) || getLanguageFromCode(dom) || dom.getAttribute("data-language");
            dom = removeLastNewLine(dom);
            return {
              language
            };
          }
        },
        // Handle VSCode paste
        // Checking `white-space: pre-wrap` is too aggressive @see ED-2627
        {
          tag: "div[style]",
          preserveWhitespace: "full",
          getAttrs: function getAttrs(domNode) {
            var dom = domNode;
            if (dom.style.whiteSpace === "pre" || dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") > -1) {
              return {};
            }
            return false;
          },
          // @see ED-5682
          getContent: function getContent(domNode, schema) {
            var dom = domNode;
            var code = Array.from(dom.children).map(function(child) {
              return child.textContent;
            }).filter(function(x) {
              return x !== void 0;
            }).join("\n");
            return code ? _prosemirrorModel.Fragment.from(schema.text(code)) : _prosemirrorModel.Fragment.empty;
          }
        },
        // Handle GitHub/Gist paste
        {
          tag: "table[style]",
          preserveWhitespace: "full",
          getAttrs: function getAttrs(dom) {
            if (dom.querySelector('td[class*="blob-code"]')) {
              return {};
            }
            return false;
          }
        },
        {
          tag: "div.code-block",
          preserveWhitespace: "full",
          getAttrs: function getAttrs(domNode) {
            var dom = domNode;
            var lineNumber = dom.querySelectorAll(".react-syntax-highlighter-line-number");
            if (lineNumber.length > 0) {
              lineNumber.forEach(function(line) {
                return line.remove();
              });
            }
            return {};
          }
        }
      ],
      toDOM: function toDOM(node) {
        return ["pre", ["code", {
          "data-language": node.attrs.language
        }, 0]];
      }
    };
    exports.codeBlock = codeBlock;
    var toJSON = function toJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).reduce(function(memo, key) {
          if (key === "uniqueId") {
            return memo;
          }
          if (key === "language" && node.attrs.language === null) {
            return memo;
          }
          memo[key] = node.attrs[key];
          return memo;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/hard-break.js
var require_hard_break = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/hard-break.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hardBreak = void 0;
    var hardBreak = {
      inline: true,
      group: "inline",
      selectable: false,
      parseDOM: [{
        tag: "br"
      }],
      toDOM: function toDOM() {
        return ["br"];
      }
    };
    exports.hardBreak = hardBreak;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/heading.js
var require_heading = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/heading.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.heading = void 0;
    var heading = {
      attrs: {
        level: {
          default: 1
        }
      },
      content: "inline*",
      group: "block",
      defining: true,
      selectable: false,
      parseDOM: [{
        tag: "h1",
        attrs: {
          level: 1
        }
      }, {
        tag: "h2",
        attrs: {
          level: 2
        }
      }, {
        tag: "h3",
        attrs: {
          level: 3
        }
      }, {
        tag: "h4",
        attrs: {
          level: 4
        }
      }, {
        tag: "h5",
        attrs: {
          level: 5
        }
      }, {
        tag: "h6",
        attrs: {
          level: 6
        }
      }],
      toDOM: function toDOM(node) {
        return ["h" + node.attrs["level"], 0];
      }
    };
    exports.heading = heading;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/rule.js
var require_rule = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/rule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rule = void 0;
    var hrDOM = ["hr"];
    var rule = {
      group: "block",
      parseDOM: [{
        tag: "hr"
      }],
      toDOM: function toDOM() {
        return hrDOM;
      }
    };
    exports.rule = rule;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(obj, key, value) {
      key = toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module2.exports = _defineProperty, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/ordered-list.js
var require_ordered_list = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/ordered-list.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.orderedListWithOrder = exports.orderedListSelector = exports.orderedList = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var orderedListSelector = ".ak-ol";
    exports.orderedListSelector = orderedListSelector;
    var orderedList = {
      group: "block",
      attrs: {
        order: {
          default: 1
        }
      },
      content: "listItem+",
      marks: "unsupportedMark unsupportedNodeAttribute",
      selectable: false,
      parseDOM: [{
        tag: "ol"
      }],
      toDOM: function toDOM() {
        var attrs = {
          class: orderedListSelector.substr(1)
        };
        return ["ol", attrs, 0];
      }
    };
    exports.orderedList = orderedList;
    var resolveStart = function resolveStart2(start) {
      var num = Number(start);
      if (Number.isNaN(num)) {
        return;
      }
      if (num < 0) {
        return;
      }
      return Math.floor(Math.max(num, 0));
    };
    var orderedListWithOrder = _objectSpread(_objectSpread({}, orderedList), {}, {
      parseDOM: [{
        tag: "ol",
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          var startDOMAttr = dom.getAttribute("start");
          if (startDOMAttr) {
            var start = resolveStart(startDOMAttr);
            if (typeof start === "number") {
              return {
                order: start
              };
            }
          }
          return null;
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs;
        var start = resolveStart(node === null || node === void 0 ? void 0 : (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.order);
        var attrs = {
          start: typeof start === "number" ? String(start) : void 0,
          class: orderedListSelector.substr(1)
        };
        return ["ol", attrs, 0];
      }
    });
    exports.orderedListWithOrder = orderedListWithOrder;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/paragraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.paragraph = void 0;
    var pDOM = ["p", 0];
    var paragraph = {
      selectable: false,
      content: "inline*",
      group: "block",
      marks: "strong code em link strike subsup textColor typeAheadQuery underline confluenceInlineComment action annotation unsupportedMark unsupportedNodeAttribute dataConsumer fragment",
      parseDOM: [{
        tag: "p"
      }],
      toDOM: function toDOM() {
        return pDOM;
      }
    };
    exports.paragraph = paragraph;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/confluence/emoji.js
var require_emoji = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/confluence/emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.acNameToEmoji = acNameToEmoji;
    exports.acShortcutToEmoji = acShortcutToEmoji;
    exports.emojiIdToAcName = emojiIdToAcName;
    exports.getEmojiAcName = getEmojiAcName;
    var DEFAULT_EMOJI_ID = "2b50";
    var DEFAULT_EMOJI_ACNAME = "blue-star";
    var HC_EMOTICON_PREFIX = "atlassian-";
    var acNameToEmojiMap = {
      smile: ["1f642", ":slight_smile:", "\u{1F642}"],
      sad: ["1f641", ":slight_frown:", "\u{1F641}"],
      cheeky: ["1f61b", ":stuck_out_tongue:", "\u{1F61B}"],
      laugh: ["1f600", ":grinning:", "\u{1F600}"],
      wink: ["1f609", ":wink:", "\u{1F609}"],
      information: ["2139", ":information_source:", "\u2139"],
      tick: ["2705", ":white_check_mark:", "\u2705"],
      cross: ["274c", ":x:", "\u274C"],
      warning: ["26a0", ":warning:", "\u26A0"],
      plus: ["2795", ":heavy_plus_sign:", "\u2795"],
      minus: ["2796", ":heavy_minus_sign:", "\u2796"],
      question: ["2753", ":question:", "?"],
      "thumbs-up": ["1f44d", ":thumbsup:", "\u{1F44D}"],
      "thumbs-down": ["1f44e", ":thumbsdown:", "\u{1F44E}"],
      "light-on": ["1f4a1", ":bulb:", "\u{1F4A1}"],
      "yellow-star": ["2b50", ":star:", "\u{1F49B}"],
      "light-off": ["1f6ab", ":no_entry_sign:", "\u{1F6AB}"],
      "red-star": ["2764", ":heart:", "\u2764\uFE0F"],
      "green-star": ["1f49a", ":green_heart:", "\u{1F49A}"],
      "blue-star": ["1f499", ":blue_heart:", "\u{1F499}"],
      heart: ["2764", ":heart:", "\u2764\uFE0F"],
      "broken-heart": ["1f494", ":broken_heart:", "\u{1F494}"]
    };
    function acNameToEmoji(acName) {
      var emojiData = acNameToEmojiMap[acName];
      return emojiData ? {
        id: emojiData[0],
        shortName: emojiData[1],
        text: emojiData[2]
      } : {
        id: DEFAULT_EMOJI_ID,
        shortName: ":".concat(acName, ":"),
        text: ""
      };
    }
    function emojiIdToAcName(emojiId) {
      var filterEmojis = function filterEmojis2(acName) {
        return acNameToEmojiMap[acName] ? acNameToEmojiMap[acName][0] === emojiId : false;
      };
      return Object.keys(acNameToEmojiMap).filter(filterEmojis)[0];
    }
    function acShortcutToEmoji(hipchatEmoticonShortName) {
      return {
        id: "".concat(HC_EMOTICON_PREFIX).concat(hipchatEmoticonShortName),
        shortName: ":".concat(hipchatEmoticonShortName, ":"),
        text: ""
      };
    }
    function getAcNameFromShortName(shortName) {
      return shortName.slice(shortName[0] === ":" ? 1 : 0, shortName[shortName.length - 1] === ":" ? -1 : shortName.length);
    }
    function getEmojiAcName(_ref) {
      var id = _ref.id, shortName = _ref.shortName;
      if (DEFAULT_EMOJI_ID === id) {
        var possibleName = getAcNameFromShortName(shortName);
        if (possibleName in acNameToEmojiMap) {
          return possibleName;
        }
      }
      return emojiIdToAcName(id) || DEFAULT_EMOJI_ACNAME;
    }
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/emoji.js
var require_emoji2 = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.emoji = void 0;
    var _emoji = require_emoji();
    var emoji = {
      inline: true,
      group: "inline",
      selectable: true,
      attrs: {
        shortName: {
          default: ""
        },
        id: {
          default: ""
        },
        text: {
          default: ""
        }
      },
      parseDOM: [
        // Handle copy/paste beautiful panel from renderer />
        {
          tag: "div.ak-editor-panel__icon span",
          ignore: true
        },
        {
          tag: "span[data-emoji-short-name]",
          getAttrs: function getAttrs(domNode) {
            var dom = domNode;
            return {
              shortName: dom.getAttribute("data-emoji-short-name") || emoji.attrs.shortName.default,
              id: dom.getAttribute("data-emoji-id") || emoji.attrs.id.default,
              text: dom.getAttribute("data-emoji-text") || emoji.attrs.text.default
            };
          }
        },
        // Handle copy/paste from old <ac:emoticon />
        {
          tag: "img[data-emoticon-name]",
          getAttrs: function getAttrs(dom) {
            return (0, _emoji.acNameToEmoji)(dom.getAttribute("data-emoticon-name"));
          }
        },
        // Handle copy/paste from old <ac:hipchat-emoticons />
        {
          tag: "img[data-hipchat-emoticon]",
          getAttrs: function getAttrs(dom) {
            return (0, _emoji.acShortcutToEmoji)(dom.getAttribute("data-hipchat-emoticon"));
          }
        },
        // Handle copy/paste from bitbucket's <img class="emoji" />
        {
          tag: "img.emoji[data-emoji-short-name]",
          getAttrs: function getAttrs(domNode) {
            var dom = domNode;
            return {
              shortName: dom.getAttribute("data-emoji-short-name") || emoji.attrs.shortName.default,
              id: dom.getAttribute("data-emoji-id") || emoji.attrs.id.default,
              text: dom.getAttribute("data-emoji-text") || emoji.attrs.text.default
            };
          }
        }
      ],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, shortName = _node$attrs.shortName, id = _node$attrs.id, text = _node$attrs.text;
        var attrs = {
          "data-emoji-short-name": shortName,
          "data-emoji-id": id,
          "data-emoji-text": text,
          contenteditable: "false"
        };
        return ["span", attrs, text];
      }
    };
    exports.emoji = emoji;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/image.js
var require_image = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/image.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.image = void 0;
    var image = {
      group: "inline",
      inline: true,
      attrs: {
        src: {
          default: ""
        },
        alt: {
          default: ""
        },
        title: {
          default: null
        }
      },
      draggable: true,
      parseDOM: [{
        tag: 'img[src^="data:image/"]',
        ignore: true
      }, {
        tag: "img[src]",
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          return {
            src: dom.getAttribute("src"),
            alt: dom.getAttribute("alt"),
            title: dom.getAttribute("title")
          };
        }
      }],
      toDOM: function toDOM(node) {
        return ["img", node.attrs];
      }
    };
    exports.image = image;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/mention.js
var require_mention = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/mention.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.mention = exports.USER_TYPES = void 0;
    var USER_TYPES;
    exports.USER_TYPES = USER_TYPES;
    (function(USER_TYPES2) {
      USER_TYPES2["DEFAULT"] = "DEFAULT";
      USER_TYPES2["SPECIAL"] = "SPECIAL";
      USER_TYPES2["APP"] = "APP";
    })(USER_TYPES || (exports.USER_TYPES = USER_TYPES = {}));
    var mention = {
      inline: true,
      group: "inline",
      selectable: true,
      attrs: {
        id: {
          default: ""
        },
        text: {
          default: ""
        },
        accessLevel: {
          default: ""
        },
        userType: {
          default: null
        }
      },
      parseDOM: [{
        tag: "span[data-mention-id]",
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          var attrs = {
            id: dom.getAttribute("data-mention-id") || mention.attrs.id.default,
            text: dom.textContent || mention.attrs.text.default,
            accessLevel: dom.getAttribute("data-access-level") || mention.attrs.accessLevel.default
          };
          var userType = dom.getAttribute("data-user-type");
          if (USER_TYPES[userType]) {
            attrs.userType = userType;
          }
          return attrs;
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, id = _node$attrs.id, accessLevel = _node$attrs.accessLevel, text = _node$attrs.text, userType = _node$attrs.userType;
        var attrs = {
          "data-mention-id": id,
          "data-access-level": accessLevel,
          contenteditable: "false"
        };
        if (userType) {
          attrs["data-user-type"] = userType;
        }
        return ["span", attrs, text];
      }
    };
    exports.mention = mention;
    var isOptional = function isOptional2(key) {
      return ["userType"].indexOf(key) > -1;
    };
    var toJSON = function toJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).reduce(function(obj, key) {
          if (isOptional(key) && !node.attrs[key]) {
            return obj;
          }
          obj[key] = node.attrs[key];
          return obj;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/list-item.js
var require_list_item = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/list-item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.listItem = void 0;
    var listItem = {
      content: "(paragraph | mediaSingle | codeBlock) (paragraph | bulletList | orderedList | mediaSingle | codeBlock)*",
      marks: "unsupportedMark unsupportedNodeAttribute",
      defining: true,
      selectable: false,
      parseDOM: [{
        tag: "li"
      }],
      toDOM: function toDOM() {
        return ["li", 0];
      }
    };
    exports.listItem = listItem;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/panel.js
var require_panel = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/panel.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.panel = exports.PanelType = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var PanelType;
    exports.PanelType = PanelType;
    (function(PanelType2) {
      PanelType2["INFO"] = "info";
      PanelType2["NOTE"] = "note";
      PanelType2["TIP"] = "tip";
      PanelType2["WARNING"] = "warning";
      PanelType2["ERROR"] = "error";
      PanelType2["SUCCESS"] = "success";
      PanelType2["CUSTOM"] = "custom";
    })(PanelType || (exports.PanelType = PanelType = {}));
    var getDefaultAttrs = function getDefaultAttrs2() {
      var attrs = {
        panelType: {
          default: "info"
        },
        panelIcon: {
          default: null
        },
        panelIconId: {
          default: null
        },
        panelIconText: {
          default: null
        },
        panelColor: {
          default: null
        }
      };
      return attrs;
    };
    var getDomAttrs = function getDomAttrs2(nodeAttrs) {
      var attrs = {
        "data-panel-type": nodeAttrs.panelType,
        "data-panel-icon": nodeAttrs.panelIcon,
        "data-panel-icon-id": nodeAttrs.panelIconId,
        "data-panel-icon-text": nodeAttrs.panelIconText,
        "data-panel-color": nodeAttrs.panelColor
      };
      return attrs;
    };
    var getParseDOMAttrs = function getParseDOMAttrs2(allowCustomPanel, dom) {
      var parseDOMAttrs = {
        panelType: dom.getAttribute("data-panel-type")
      };
      if (allowCustomPanel) {
        parseDOMAttrs = _objectSpread(_objectSpread({}, parseDOMAttrs), {}, {
          panelIcon: dom.getAttribute("data-panel-icon"),
          panelIconId: dom.getAttribute("data-panel-icon-id"),
          panelIconText: dom.getAttribute("data-panel-icon-text"),
          panelColor: dom.getAttribute("data-panel-color")
        });
      } else {
        parseDOMAttrs.panelType = parseDOMAttrs.panelType === PanelType.CUSTOM ? PanelType.INFO : parseDOMAttrs.panelType;
      }
      return parseDOMAttrs;
    };
    var panel = function panel2(allowCustomPanel) {
      var panelNodeSpec = {
        group: "block",
        content: "(paragraph | heading | bulletList | orderedList | blockCard | unsupportedBlock)+",
        marks: "unsupportedMark unsupportedNodeAttribute",
        attrs: getDefaultAttrs(),
        selectable: true,
        parseDOM: [{
          tag: "div[data-panel-type]",
          getAttrs: function getAttrs(dom) {
            return getParseDOMAttrs(allowCustomPanel, dom);
          }
        }],
        toDOM: function toDOM(node) {
          var attrs = getDomAttrs(node.attrs);
          var contentAttrs = {
            "data-panel-content": "true"
          };
          return ["div", attrs, ["div", contentAttrs, 0]];
        }
      };
      return panelNodeSpec;
    };
    exports.panel = panel;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/text.js
var require_text = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.text = void 0;
    var text = {
      group: "inline",
      toDebugString: process.env.NODE_ENV !== "production" ? void 0 : function() {
        return "text_node";
      }
    };
    exports.text = text;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unknown-block.js
var require_unknown_block = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unknown-block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var name = "unknownBlock";
    var _default = {
      group: "block",
      content: "inline+",
      marks: "_",
      toDOM: function toDOM() {
        return ["div", {
          "data-node-type": name
        }, 0];
      },
      parseDOM: [{
        tag: 'div[data-node-type="'.concat(name, '"]')
      }]
    };
    exports.default = _default;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/caption.js
var require_caption = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/caption.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.caption = void 0;
    var caption = {
      content: "(text|hardBreak|mention|emoji|date|placeholder|inlineCard|status)*",
      isolating: true,
      marks: "_",
      selectable: false,
      parseDOM: [{
        tag: "figcaption[data-caption]"
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-caption": "true"
        };
        return ["figcaption", attrs, 0];
      }
    };
    exports.caption = caption;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module2) {
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module2.exports = _arrayWithHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module2) {
    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    module2.exports = _iterableToArrayLimit, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    module2.exports = _arrayLikeToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray(o, minLen);
    }
    module2.exports = _unsupportedIterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module2) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableRest, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module2) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    module2.exports = _slicedToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/css-color-names/css-color-names.json
var require_css_color_names = __commonJS({
  "node_modules/css-color-names/css-color-names.json"(exports, module2) {
    module2.exports = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/colors.js
var require_colors = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/colors.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Y75 = exports.Y500 = exports.Y50 = exports.Y400 = exports.Y200 = exports.T75 = exports.T500 = exports.T50 = exports.T300 = exports.T100 = exports.R75 = exports.R500 = exports.R50 = exports.R400 = exports.R300 = exports.R100 = exports.P75 = exports.P500 = exports.P50 = exports.P400 = exports.P300 = exports.P100 = exports.N90 = exports.N800 = exports.N80 = exports.N600 = exports.N60 = exports.N500 = exports.N50 = exports.N40 = exports.N300A = exports.N300 = exports.N30 = exports.N200 = exports.N20 = exports.N1000 = exports.N0 = exports.G75 = exports.G500 = exports.G50 = exports.G400 = exports.G300 = exports.G200 = exports.B75 = exports.B500 = exports.B50 = exports.B400 = exports.B100 = void 0;
    exports.hexToRgb = hexToRgb;
    exports.hexToRgba = hexToRgba;
    exports.isHex = isHex;
    exports.isRgb = isRgb;
    exports.normalizeHexColor = normalizeHexColor;
    exports.rgbToHex = rgbToHex;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var namedColors = _interopRequireWildcard(require_css_color_names());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var R50 = "#FFEBE6";
    exports.R50 = R50;
    var R75 = "#FFBDAD";
    exports.R75 = R75;
    var R100 = "#FF8F73";
    exports.R100 = R100;
    var R300 = "#FF5630";
    exports.R300 = R300;
    var R400 = "#DE350B";
    exports.R400 = R400;
    var R500 = "#BF2600";
    exports.R500 = R500;
    var Y50 = "#FFFAE6";
    exports.Y50 = Y50;
    var Y75 = "#FFF0B3";
    exports.Y75 = Y75;
    var Y200 = "#FFC400";
    exports.Y200 = Y200;
    var Y400 = "#FF991F";
    exports.Y400 = Y400;
    var Y500 = "#FF8B00";
    exports.Y500 = Y500;
    var G50 = "#E3FCEF";
    exports.G50 = G50;
    var G75 = "#ABF5D1";
    exports.G75 = G75;
    var G200 = "#57D9A3";
    exports.G200 = G200;
    var G300 = "#36B37E";
    exports.G300 = G300;
    var G400 = "#00875A";
    exports.G400 = G400;
    var G500 = "#006644";
    exports.G500 = G500;
    var B50 = "#DEEBFF";
    exports.B50 = B50;
    var B75 = "#B3D4FF";
    exports.B75 = B75;
    var B100 = "#4C9AFF";
    exports.B100 = B100;
    var B400 = "#0052CC";
    exports.B400 = B400;
    var B500 = "#0747A6";
    exports.B500 = B500;
    var N0 = "#FFFFFF";
    exports.N0 = N0;
    var N20 = "#F4F5F7";
    exports.N20 = N20;
    var N30 = "#EBECF0";
    exports.N30 = N30;
    var N40 = "#DFE1E6";
    exports.N40 = N40;
    var N50 = "#C1C7D0";
    exports.N50 = N50;
    var N60 = "#B3BAC5";
    exports.N60 = N60;
    var N80 = "#97A0AF";
    exports.N80 = N80;
    var N90 = "#8993A4";
    exports.N90 = N90;
    var N200 = "#6B778C";
    exports.N200 = N200;
    var N300 = "#5E6C84";
    exports.N300 = N300;
    var N300A = "#091E4224";
    exports.N300A = N300A;
    var N500 = "#42526E";
    exports.N500 = N500;
    var N600 = "#758195";
    exports.N600 = N600;
    var N800 = "#172B4D";
    exports.N800 = N800;
    var N1000 = "#172B4D";
    exports.N1000 = N1000;
    var P50 = "#EAE6FF";
    exports.P50 = P50;
    var P75 = "#C0B6F2";
    exports.P75 = P75;
    var P100 = "#998DD9";
    exports.P100 = P100;
    var P300 = "#6554C0";
    exports.P300 = P300;
    var P400 = "#5243AA";
    exports.P400 = P400;
    var P500 = "#403294";
    exports.P500 = P500;
    var T50 = "#E6FCFF";
    exports.T50 = T50;
    var T75 = "#B3F5FF";
    exports.T75 = T75;
    var T100 = "#79E2F2";
    exports.T100 = T100;
    var T300 = "#00B8D9";
    exports.T300 = T300;
    var T500 = "#008DA6";
    exports.T500 = T500;
    function normalizeHexColor(color, defaultColor) {
      if (!color) {
        return null;
      }
      color = color.trim().toLowerCase();
      if (isHex(color)) {
        if (color.length === 4) {
          color = color.split("").map(function(c) {
            return c === "#" ? "#" : "".concat(c).concat(c);
          }).join("");
        }
      } else if (isRgb(color)) {
        return rgbToHex(color);
      } else {
        if (color === "default") {
          return null;
        } else if (namedColors.default && namedColors.default[color]) {
          color = namedColors.default[color];
        } else if (namedColors && namedColors[color]) {
          color = namedColors[color];
        } else {
          return null;
        }
      }
      if (color === defaultColor) {
        return null;
      }
      return color;
    }
    function hexToRgb(color) {
      if (!isHex(color)) {
        return null;
      }
      var colorBits = color.substring(1).split("");
      if (colorBits.length === 3) {
        colorBits = [colorBits[0], colorBits[0], colorBits[1], colorBits[1], colorBits[2], colorBits[2]];
      }
      var rgb = Number("0x".concat(colorBits.join("")));
      return "rgb(".concat(rgb >> 16 & 255, ",").concat(rgb >> 8 & 255, ",").concat(rgb & 255, ")");
    }
    function hexToRgba(rawColor, alpha) {
      var color = normalizeHexColor(rawColor);
      if (!color) {
        return null;
      }
      var hex2rgb = function hex2rgb2(color2) {
        return color2.match(/[a-z0-9]{2}/gi).map(function(hex) {
          return parseInt(hex, 16);
        });
      };
      return "rgba(".concat(hex2rgb(color).concat(alpha).join(","), ")");
    }
    function rgbToHex(value) {
      var matches = value.match(/(0?\.?\d{1,3})%?\b/g);
      if (matches && matches.length >= 3) {
        var _matches$map = matches.map(Number), _matches$map2 = (0, _slicedToArray2.default)(_matches$map, 3), red = _matches$map2[0], green = _matches$map2[1], blue = _matches$map2[2];
        return "#" + (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1);
      }
      return null;
    }
    function isRgb(color) {
      return /rgba?\(/.test(color);
    }
    function isHex(color) {
      return /^#([A-Fa-f0-9]{3}){1,2}$/.test(color);
    }
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media.js
var require_media = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.media = exports.defaultAttrs = exports.createMediaSpec = exports.copyPrivateAttributes = exports.camelCaseToKebabCase = void 0;
    var _colors = require_colors();
    var defaultAttrs = {
      id: {
        default: ""
      },
      type: {
        default: "file"
      },
      collection: {
        default: ""
      },
      occurrenceKey: {
        default: null
      },
      alt: {
        default: ""
      },
      width: {
        default: null
      },
      height: {
        default: null
      },
      url: {
        default: null
      },
      __fileName: {
        default: null
      },
      __fileSize: {
        default: null
      },
      __fileMimeType: {
        default: null
      },
      __displayType: {
        default: null
      },
      __contextId: {
        default: null
      },
      __mediaTraceId: {
        default: null
      },
      __external: {
        default: false
      }
    };
    exports.defaultAttrs = defaultAttrs;
    var createMediaSpec = function createMediaSpec2(attributes) {
      var inline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var domNodeType = inline ? "span" : "div";
      var nodeName = inline ? "mediaInline" : "media";
      var parseDOM = [
        {
          tag: "".concat(domNodeType, '[data-node-type="').concat(nodeName, '"]'),
          getAttrs: function getAttrs(dom) {
            var attrs = {};
            if (attributes) {
              Object.keys(attributes).forEach(function(k) {
                var key = camelCaseToKebabCase(k).replace(/^__/, "");
                var value = dom.getAttribute("data-".concat(key)) || "";
                if (value) {
                  attrs[k] = value;
                }
              });
            }
            if (attrs.__fileSize) {
              attrs.__fileSize = +attrs.__fileSize;
            }
            var width = Number(attrs.width);
            if (typeof width !== "undefined" && !isNaN(width)) {
              attrs.width = width;
            }
            var height = Number(attrs.height);
            if (typeof height !== "undefined" && !isNaN(height)) {
              attrs.height = height;
            }
            return attrs;
          }
        },
        // Don't match data URI
        {
          tag: 'img[src^="data:image"]',
          ignore: true
        }
      ];
      if (!inline) {
        parseDOM.push({
          tag: "img:not(.smart-link-icon)",
          getAttrs: function getAttrs(dom) {
            return {
              type: "external",
              url: dom.getAttribute("src") || "",
              alt: dom.getAttribute("alt") || ""
            };
          }
        });
      }
      return {
        selectable: true,
        inline,
        group: inline ? "inline" : void 0,
        attrs: attributes,
        parseDOM,
        toDOM: function toDOM(node) {
          var attrs = {
            "data-id": node.attrs.id,
            "data-node-type": "".concat(nodeName),
            "data-type": node.attrs.type,
            "data-collection": node.attrs.collection,
            "data-occurrence-key": node.attrs.occurrenceKey,
            "data-width": node.attrs.width,
            "data-height": node.attrs.height,
            "data-url": node.attrs.url,
            "data-alt": node.attrs.alt,
            // toDOM is used for static rendering as well as editor rendering. This comes into play for
            // emails, copy/paste, etc, so the title and styling here *is* useful (despite a React-based
            // node view being used for editing).
            title: "Attachment",
            // Manually kept in sync with the style of media cards. The goal is to render a plain gray
            // rectangle that provides an affordance for media.
            style: "display: inline-block; border-radius: 3px; background: ".concat(_colors.N30, "; box-shadow: 0 1px 1px rgba(9, 30, 66, 0.2), 0 0 1px 0 rgba(9, 30, 66, 0.24);")
          };
          copyPrivateAttributes(node.attrs, attrs, function(key) {
            return "data-".concat(camelCaseToKebabCase(key.slice(2)));
          });
          return ["".concat(domNodeType), attrs];
        }
      };
    };
    exports.createMediaSpec = createMediaSpec;
    var media = createMediaSpec(defaultAttrs);
    exports.media = media;
    var camelCaseToKebabCase = function camelCaseToKebabCase2(str) {
      return str.replace(/([^A-Z]+)([A-Z])/g, function(_, x, y) {
        return "".concat(x, "-").concat(y.toLowerCase());
      });
    };
    exports.camelCaseToKebabCase = camelCaseToKebabCase;
    var copyPrivateAttributes = function copyPrivateAttributes2(from, to, map) {
      if (media.attrs) {
        Object.keys(media.attrs).forEach(function(key) {
          if (key[0] === "_" && key[1] === "_" && from[key]) {
            to[map ? map(key) : key] = from[key];
          }
        });
      }
    };
    exports.copyPrivateAttributes = copyPrivateAttributes;
    var optionalAttributes = ["occurrenceKey", "width", "height", "url", "alt"];
    var externalOnlyAttributes = ["type", "url", "width", "height", "alt"];
    var toJSON = function toJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).filter(function(key) {
          return !(key[0] === "_" && key[1] === "_");
        }).reduce(function(obj, key) {
          if (node.attrs.type === "external" && externalOnlyAttributes.indexOf(key) === -1) {
            return obj;
          }
          if (optionalAttributes.indexOf(key) > -1 && (node.attrs[key] === null || node.attrs[key] === "")) {
            return obj;
          }
          if (["width", "height"].indexOf(key) !== -1) {
            obj[key] = Number(node.attrs[key]);
            return obj;
          }
          obj[key] = node.attrs[key];
          return obj;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-group.js
var require_media_group = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-group.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mediaGroup = void 0;
    var mediaGroup = {
      inline: false,
      group: "block",
      content: "(media|unsupportedBlock)+",
      attrs: {},
      marks: "unsupportedMark unsupportedNodeAttribute border link",
      selectable: false,
      parseDOM: [{
        tag: 'div[data-node-type="mediaGroup"]'
      }, {
        tag: 'div[class="MediaGroup"]'
      }],
      toDOM: function toDOM() {
        return ["div", {
          "data-node-type": "mediaGroup"
        }, 0];
      }
    };
    exports.mediaGroup = mediaGroup;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-inline.js
var require_media_inline = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-inline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mediaInline = void 0;
    var _media = require_media();
    var mediaInline = (0, _media.createMediaSpec)(_media.defaultAttrs, true);
    exports.mediaInline = mediaInline;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-single.js
var require_media_single = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/media-single.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.mediaSingleWithCaption = exports.mediaSingle = exports.defaultAttrs = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var defaultAttrs = {
      width: {
        default: null
      },
      // null makes small images to have original size by default
      layout: {
        default: "center"
      }
    };
    exports.defaultAttrs = defaultAttrs;
    var mediaSingle = {
      inline: false,
      group: "block",
      selectable: true,
      atom: true,
      content: "media|unsupportedBlock+|media unsupportedBlock+",
      attrs: defaultAttrs,
      marks: "unsupportedMark unsupportedNodeAttribute border link",
      parseDOM: [{
        tag: 'div[data-node-type="mediaSingle"]',
        getAttrs: function getAttrs(dom) {
          return {
            layout: dom.getAttribute("data-layout") || "center",
            width: Number(dom.getAttribute("data-width")) || null
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, layout = _node$attrs.layout, width = _node$attrs.width;
        var attrs = {
          "data-node-type": "mediaSingle",
          "data-layout": layout,
          "data-width": ""
        };
        if (width) {
          attrs["data-width"] = isFinite(width) && Math.floor(width) === width ? width : width.toFixed(2);
        }
        return ["div", attrs, 0];
      }
    };
    exports.mediaSingle = mediaSingle;
    var mediaSingleWithCaption = _objectSpread(_objectSpread({}, mediaSingle), {}, {
      atom: false,
      content: "media|unsupportedBlock+|media (caption|unsupportedBlock) unsupportedBlock*"
    });
    exports.mediaSingleWithCaption = mediaSingleWithCaption;
    var toJSON = function toJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).reduce(function(obj, key) {
          if (node.attrs[key] !== null) {
            obj[key] = node.attrs[key];
          }
          return obj;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/editor-palette/dist/cjs/background.js
var require_background = __commonJS({
  "node_modules/@atlaskit/editor-palette/dist/cjs/background.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.editorBackgroundPalette = void 0;
    exports.hexToEditorBackgroundPaletteColor = hexToEditorBackgroundPaletteColor;
    exports.hexToEditorBackgroundPaletteColorTokenName = hexToEditorBackgroundPaletteColorTokenName;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _editorBackgroundPale;
    function hexToEditorBackgroundPaletteColor(hexColor) {
      var tokenData = editorBackgroundPalette[hexColor.toUpperCase()];
      return tokenData ? tokenData.token : void 0;
    }
    function hexToEditorBackgroundPaletteColorTokenName(hexColor) {
      var tokenData = editorBackgroundPalette[hexColor.toUpperCase()];
      return tokenData ? tokenData.tokenName : void 0;
    }
    var editorBackgroundPalette = (_editorBackgroundPale = {}, (0, _defineProperty2.default)(_editorBackgroundPale, "#DEEBFF", {
      tokenName: "color.background.accent.blue.subtlest",
      token: "var(--ds-background-accent-blue-subtlest, #DEEBFF)"
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#B3D4FF", {
      tokenName: "color.background.accent.blue.subtler",
      token: "var(--ds-background-accent-blue-subtler, #B3D4FF)"
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#4C9AFF", {
      tokenName: "color.background.accent.blue.subtle",
      token: "var(--ds-background-accent-blue-subtle, #4C9AFF)"
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#E6FCFF", {
      tokenName: "color.background.accent.teal.subtlest",
      token: "var(--ds-background-accent-teal-subtlest, #E6FCFF)"
      // source for hex code was legacy token T50,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#B3F5FF", {
      tokenName: "color.background.accent.teal.subtler",
      token: "var(--ds-background-accent-teal-subtler, #B3F5FF)"
      // source for hex code was legacy token T75,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#79E2F2", {
      tokenName: "color.background.accent.teal.subtle",
      token: "var(--ds-background-accent-teal-subtle, #79E2F2)"
      // source for hex code was legacy token T100,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#E3FCEF", {
      tokenName: "color.background.accent.green.subtlest",
      token: "var(--ds-background-accent-green-subtlest, #E3FCEF)"
      // source for hex code was legacy token G50,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#ABF5D1", {
      tokenName: "color.background.accent.green.subtler",
      token: "var(--ds-background-accent-green-subtler, #ABF5D1)"
      // source for hex code was legacy token G75,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#57D9A3", {
      tokenName: "color.background.accent.green.subtle",
      token: "var(--ds-background-accent-green-subtle, #57D9A3)"
      // source for hex code was legacy token G200,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFFAE6", {
      tokenName: "color.background.accent.yellow.subtlest",
      token: "var(--ds-background-accent-yellow-subtlest, #FFFAE6)"
      // source for hex code was legacy token Y50,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFF0B3", {
      tokenName: "color.background.accent.yellow.subtler",
      token: "var(--ds-background-accent-yellow-subtler, #FFF0B3)"
      // source for hex code was legacy token Y75,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFC400", {
      tokenName: "color.background.accent.orange.subtle",
      token: "var(--ds-background-accent-orange-subtle, #FFC400)"
      // source for hex code was legacy token Y200,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFEBE6", {
      tokenName: "color.background.accent.red.subtlest",
      token: "var(--ds-background-accent-red-subtlest, #FFEBE6)"
      // source for hex code was legacy token R50,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFBDAD", {
      tokenName: "color.background.accent.red.subtler",
      token: "var(--ds-background-accent-red-subtler, #FFBDAD)"
      // source for hex code was legacy token R75,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FF8F73", {
      tokenName: "color.background.accent.red.subtle",
      token: "var(--ds-background-accent-red-subtle, #FF8F73)"
      // source for hex code was legacy token R100,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#EAE6FF", {
      tokenName: "color.background.accent.purple.subtlest",
      token: "var(--ds-background-accent-purple-subtlest, #EAE6FF)"
      // source for hex code was legacy token P50,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#C0B6F2", {
      tokenName: "color.background.accent.purple.subtler",
      token: "var(--ds-background-accent-purple-subtler, #C0B6F2)"
      // source for hex code was legacy token P75,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#998DD9", {
      tokenName: "color.background.accent.purple.subtle",
      token: "var(--ds-background-accent-purple-subtle, #998DD9)"
      // source for hex code was legacy token P100,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#FFFFFF", {
      tokenName: "elevation.surface",
      token: "var(--ds-surface, #FFFFFF)"
      // source for hex code was legacy token N0,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#F4F5F7", {
      tokenName: "color.background.accent.gray.subtlest",
      token: "var(--ds-background-accent-gray-subtlest, #F4F5F7)"
      // source for hex code was legacy token N20,
    }), (0, _defineProperty2.default)(_editorBackgroundPale, "#B3BAC5", {
      tokenName: "color.background.accent.gray.subtle",
      token: "var(--ds-background-accent-gray-subtle, #B3BAC5)"
      // source for hex code was legacy token N60,
    }), _editorBackgroundPale);
    exports.editorBackgroundPalette = editorBackgroundPalette;
    var backgroundPaletteKeys = Object.keys(editorBackgroundPalette);
    var tokenNames = backgroundPaletteKeys.map(function(hexCode) {
      return editorBackgroundPalette[hexCode].tokenName;
    });
  }
});

// node_modules/@atlaskit/editor-palette/dist/cjs/border.js
var require_border = __commonJS({
  "node_modules/@atlaskit/editor-palette/dist/cjs/border.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.editorBorderPalette = void 0;
    exports.hexToEditorBorderPaletteColor = hexToEditorBorderPaletteColor;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _editorBorderPalette;
    function hexToEditorBorderPaletteColor(hexColor) {
      return editorBorderPalette[hexColor.toUpperCase()];
    }
    var editorBorderPalette = (_editorBorderPalette = {}, (0, _defineProperty2.default)(_editorBorderPalette, "#091E4224", "var(--ds-border, #091E4224)"), (0, _defineProperty2.default)(_editorBorderPalette, "#758195", "var(--ds-border-bold, #758195)"), (0, _defineProperty2.default)(_editorBorderPalette, "#172B4D", "var(--ds-text, #172B4D)"), _editorBorderPalette);
    exports.editorBorderPalette = editorBorderPalette;
  }
});

// node_modules/@atlaskit/editor-palette/dist/cjs/text.js
var require_text2 = __commonJS({
  "node_modules/@atlaskit/editor-palette/dist/cjs/text.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.editorTextPalette = void 0;
    exports.hexToEditorTextPaletteColor = hexToEditorTextPaletteColor;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _editorTextPalette;
    function hexToEditorTextPaletteColor(hexColor) {
      return editorTextPalette[hexColor.toUpperCase()];
    }
    var editorTextPalette = (_editorTextPalette = {}, (0, _defineProperty2.default)(_editorTextPalette, "#B3D4FF", "var(--ds-background-accent-blue-subtler, #B3D4FF)"), (0, _defineProperty2.default)(_editorTextPalette, "#4C9AFF", "var(--ds-icon-accent-blue, #4C9AFF)"), (0, _defineProperty2.default)(_editorTextPalette, "#0747A6", "var(--ds-text-accent-blue, #0747A6)"), (0, _defineProperty2.default)(_editorTextPalette, "#B3F5FF", "var(--ds-background-accent-teal-subtler, #B3F5FF)"), (0, _defineProperty2.default)(_editorTextPalette, "#00B8D9", "var(--ds-icon-accent-teal, #00B8D9)"), (0, _defineProperty2.default)(_editorTextPalette, "#008DA6", "var(--ds-text-accent-teal, #008DA6)"), (0, _defineProperty2.default)(_editorTextPalette, "#ABF5D1", "var(--ds-background-accent-green-subtler, #ABF5D1)"), (0, _defineProperty2.default)(_editorTextPalette, "#36B37E", "var(--ds-icon-accent-green, #36B37E)"), (0, _defineProperty2.default)(_editorTextPalette, "#006644", "var(--ds-text-accent-green, #006644)"), (0, _defineProperty2.default)(_editorTextPalette, "#FFF0B3", "var(--ds-background-accent-yellow-subtler, #FFF0B3)"), (0, _defineProperty2.default)(_editorTextPalette, "#FFC400", "var(--ds-background-accent-orange-subtle, #FFC400)"), (0, _defineProperty2.default)(_editorTextPalette, "#FF991F", "var(--ds-icon-accent-orange, #FF991F)"), (0, _defineProperty2.default)(_editorTextPalette, "#FFBDAD", "var(--ds-background-accent-red-subtler, #FFBDAD)"), (0, _defineProperty2.default)(_editorTextPalette, "#FF5630", "var(--ds-icon-accent-red, #FF5630)"), (0, _defineProperty2.default)(_editorTextPalette, "#BF2600", "var(--ds-text-accent-red, #BF2600)"), (0, _defineProperty2.default)(_editorTextPalette, "#EAE6FF", "var(--ds-background-accent-purple-subtler, #EAE6FF)"), (0, _defineProperty2.default)(_editorTextPalette, "#6554C0", "var(--ds-icon-accent-purple, #6554C0)"), (0, _defineProperty2.default)(_editorTextPalette, "#403294", "var(--ds-text-accent-purple, #403294)"), (0, _defineProperty2.default)(_editorTextPalette, "#FFFFFF", "var(--ds-text-inverse, #FFFFFF)"), (0, _defineProperty2.default)(_editorTextPalette, "#97A0AF", "var(--ds-icon-accent-gray, #97A0AF)"), (0, _defineProperty2.default)(_editorTextPalette, "#172B4D", "var(--ds-text, #172B4D)"), _editorTextPalette);
    exports.editorTextPalette = editorTextPalette;
  }
});

// node_modules/@atlaskit/editor-palette/dist/cjs/table-charts.js
var require_table_charts = __commonJS({
  "node_modules/@atlaskit/editor-palette/dist/cjs/table-charts.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hexToEditorTableChartsPaletteColor = hexToEditorTableChartsPaletteColor;
    exports.hexToEditorTableChartsPaletteColorTokenName = hexToEditorTableChartsPaletteColorTokenName;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _editorTableChartsPal;
    function hexToEditorTableChartsPaletteColor(hexColor) {
      var tokenData = editorTableChartsPalette[hexColor.toUpperCase()];
      return tokenData ? tokenData.token : void 0;
    }
    function hexToEditorTableChartsPaletteColorTokenName(hexColor) {
      var tokenData = editorTableChartsPalette[hexColor.toUpperCase()];
      return tokenData ? tokenData.tokenName : void 0;
    }
    var editorTableChartsPalette = (_editorTableChartsPal = {}, (0, _defineProperty2.default)(_editorTableChartsPal, "#7AB2FF", {
      tokenName: "color.background.accent.blue.subtle",
      token: "var(--ds-background-accent-blue-subtle, #7AB2FF)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#60C6D2", {
      tokenName: "color.background.accent.teal.subtle",
      token: "var(--ds-background-accent-teal-subtle, #60C6D2)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#6BE1B0", {
      tokenName: "color.background.accent.green.subtle",
      token: "var(--ds-background-accent-green-subtle, #6BE1B0)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FFDB57", {
      tokenName: "color.background.accent.yellow.subtle",
      token: "var(--ds-background-accent-yellow-subtle, #FFDB57)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FAA53D", {
      tokenName: "color.background.accent.orange.subtle",
      token: "var(--ds-background-accent-orange-subtle, #FAA53D)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FF8F73", {
      tokenName: "color.background.accent.red.subtle",
      token: "var(--ds-background-accent-red-subtle, #FF8F73)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#E774BB", {
      tokenName: "color.background.accent.magenta.subtle",
      token: "var(--ds-background-accent-magenta-subtle, #E774BB)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#B5A7FB", {
      tokenName: "color.background.accent.purple.subtle",
      token: "var(--ds-background-accent-purple-subtle, #B5A7FB)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#8993A5", {
      tokenName: "color.background.accent.gray.subtler",
      token: "var(--ds-background-accent-gray-subtler, #8993A5)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#247FFF", {
      tokenName: "color.chart.blue.bold",
      token: "var(--ds-chart-blue-bold, #247FFF)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#1D9AAA", {
      tokenName: "color.chart.teal.bold",
      token: "var(--ds-chart-teal-bold, #1D9AAA)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#23A971", {
      tokenName: "color.chart.green.bold",
      token: "var(--ds-chart-green-bold, #23A971)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FFBE33", {
      tokenName: "color.chart.yellow.bold",
      token: "var(--ds-chart-yellow-bold, #FFBE33)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#D97008", {
      tokenName: "color.chart.orange.bold",
      token: "var(--ds-chart-orange-bold, #D97008)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FC552C", {
      tokenName: "color.chart.red.bold",
      token: "var(--ds-chart-red-bold, #FC552C)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#DA62AC", {
      tokenName: "color.chart.magenta.bold",
      token: "var(--ds-chart-magenta-bold, #DA62AC)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#8B77EE", {
      tokenName: "color.chart.purple.bold",
      token: "var(--ds-chart-purple-bold, #8B77EE)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#8590A2", {
      tokenName: "color.chart.gray.bold",
      token: "var(--ds-chart-gray-bold, #8590A2)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#0055CC", {
      tokenName: "color.chart.blue.bolder",
      token: "var(--ds-chart-blue-bolder, #0055CC)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#1D7F8C", {
      tokenName: "color.chart.teal.bolder",
      token: "var(--ds-chart-teal-bolder, #1D7F8C)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#177D52", {
      tokenName: "color.chart.green.bolder",
      token: "var(--ds-chart-green-bolder, #177D52)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#FF9D00", {
      tokenName: "color.chart.yellow.bolder",
      token: "var(--ds-chart-yellow-bolder, #FF9D00)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#B65C02", {
      tokenName: "color.chart.orange.bolder",
      token: "var(--ds-chart-orange-bolder, #B65C02)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#D32D03", {
      tokenName: "color.chart.red.bolder",
      token: "var(--ds-chart-red-bolder, #D32D03)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#CD519D", {
      tokenName: "color.chart.magenta.bolder",
      token: "var(--ds-chart-magenta-bolder, #CD519D)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#5A43D0", {
      tokenName: "color.chart.purple.bolder",
      token: "var(--ds-chart-purple-bolder, #5A43D0)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#758195", {
      tokenName: "color.chart.gray.bolder",
      token: "var(--ds-chart-gray-bolder, #758195)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#003884", {
      tokenName: "color.chart.blue.boldest",
      token: "var(--ds-chart-blue-boldest, #003884)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#206B74", {
      tokenName: "color.chart.teal.boldest",
      token: "var(--ds-chart-teal-boldest, #206B74)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#055C3F", {
      tokenName: "color.chart.green.boldest",
      token: "var(--ds-chart-green-boldest, #055C3F)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#946104", {
      tokenName: "color.chart.yellow.boldest",
      token: "var(--ds-chart-yellow-boldest, #946104)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#974F0C", {
      tokenName: "color.chart.orange.boldest",
      token: "var(--ds-chart-orange-boldest, #974F0C)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#A32000", {
      tokenName: "color.chart.red.boldest",
      token: "var(--ds-chart-red-boldest, #A32000)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#943D73", {
      tokenName: "color.chart.magenta.boldest",
      token: "var(--ds-chart-magenta-boldest, #943D73)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#44368B", {
      tokenName: "color.chart.purple.boldest",
      token: "var(--ds-chart-purple-boldest, #44368B)"
    }), (0, _defineProperty2.default)(_editorTableChartsPal, "#44546F", {
      tokenName: "color.chart.gray.boldest",
      token: "var(--ds-chart-gray-boldest, #44546F)"
    }), _editorTableChartsPal);
    var tableChartsPaletteKeys = Object.keys(editorTableChartsPalette);
    var tokenNames = tableChartsPaletteKeys.map(function(hexCode) {
      return editorTableChartsPalette[hexCode].tokenName;
    });
  }
});

// node_modules/@atlaskit/editor-palette/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@atlaskit/editor-palette/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "hexToEditorBackgroundPaletteColor", {
      enumerable: true,
      get: function get() {
        return _background.hexToEditorBackgroundPaletteColor;
      }
    });
    Object.defineProperty(exports, "hexToEditorBackgroundPaletteColorTokenName", {
      enumerable: true,
      get: function get() {
        return _background.hexToEditorBackgroundPaletteColorTokenName;
      }
    });
    Object.defineProperty(exports, "hexToEditorBorderPaletteColor", {
      enumerable: true,
      get: function get() {
        return _border.hexToEditorBorderPaletteColor;
      }
    });
    Object.defineProperty(exports, "hexToEditorTableChartsPaletteColor", {
      enumerable: true,
      get: function get() {
        return _tableCharts.hexToEditorTableChartsPaletteColor;
      }
    });
    Object.defineProperty(exports, "hexToEditorTableChartsPaletteColorTokenName", {
      enumerable: true,
      get: function get() {
        return _tableCharts.hexToEditorTableChartsPaletteColorTokenName;
      }
    });
    Object.defineProperty(exports, "hexToEditorTextPaletteColor", {
      enumerable: true,
      get: function get() {
        return _text.hexToEditorTextPaletteColor;
      }
    });
    var _background = require_background();
    var _border = require_border();
    var _text = require_text2();
    var _tableCharts = require_table_charts();
  }
});

// node_modules/@atlaskit/ds-lib/dist/cjs/utils/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/@atlaskit/ds-lib/dist/cjs/utils/warn-once.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = warnOnce;
    var printed = {};
    function warnOnce(message) {
      if (printed[message]) {
        return;
      }
      printed[message] = true;
      if (typeof window !== "undefined") {
        console.warn(message);
      }
    }
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/token-names.js
var require_token_names = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/token-names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tokens = {
      "border.radius.050": "--ds-radius-050",
      "border.radius.100": "--ds-radius-100",
      "border.radius.200": "--ds-radius-200",
      "border.radius.300": "--ds-radius-300",
      "border.radius.400": "--ds-radius-400",
      "border.radius.round": "--ds-radius-round",
      "border.width.0": "--ds-width-0",
      "border.width.050": "--ds-width-050",
      "border.width.100": "--ds-width-100",
      "color.text": "--ds-text",
      "color.text.accent.red": "--ds-text-accent-red",
      "color.text.accent.red.bolder": "--ds-text-accent-red-bolder",
      "color.text.accent.orange": "--ds-text-accent-orange",
      "color.text.accent.orange.bolder": "--ds-text-accent-orange-bolder",
      "color.text.accent.yellow": "--ds-text-accent-yellow",
      "color.text.accent.yellow.bolder": "--ds-text-accent-yellow-bolder",
      "color.text.accent.green": "--ds-text-accent-green",
      "color.text.accent.green.bolder": "--ds-text-accent-green-bolder",
      "color.text.accent.teal": "--ds-text-accent-teal",
      "color.text.accent.teal.bolder": "--ds-text-accent-teal-bolder",
      "color.text.accent.blue": "--ds-text-accent-blue",
      "color.text.accent.blue.bolder": "--ds-text-accent-blue-bolder",
      "color.text.accent.purple": "--ds-text-accent-purple",
      "color.text.accent.purple.bolder": "--ds-text-accent-purple-bolder",
      "color.text.accent.magenta": "--ds-text-accent-magenta",
      "color.text.accent.magenta.bolder": "--ds-text-accent-magenta-bolder",
      "color.text.accent.gray": "--ds-text-accent-gray",
      "color.text.accent.gray.bolder": "--ds-text-accent-gray-bolder",
      "color.text.disabled": "--ds-text-disabled",
      "color.text.inverse": "--ds-text-inverse",
      "color.text.selected": "--ds-text-selected",
      "color.text.brand": "--ds-text-brand",
      "color.text.danger": "--ds-text-danger",
      "color.text.warning": "--ds-text-warning",
      "color.text.warning.inverse": "--ds-text-warning-inverse",
      "color.text.success": "--ds-text-success",
      "color.text.discovery": "--ds-text-discovery",
      "color.text.information": "--ds-text-information",
      "color.text.subtlest": "--ds-text-subtlest",
      "color.text.subtle": "--ds-text-subtle",
      "color.link": "--ds-link",
      "color.link.pressed": "--ds-link-pressed",
      "color.icon": "--ds-icon",
      "color.icon.accent.red": "--ds-icon-accent-red",
      "color.icon.accent.orange": "--ds-icon-accent-orange",
      "color.icon.accent.yellow": "--ds-icon-accent-yellow",
      "color.icon.accent.green": "--ds-icon-accent-green",
      "color.icon.accent.teal": "--ds-icon-accent-teal",
      "color.icon.accent.blue": "--ds-icon-accent-blue",
      "color.icon.accent.purple": "--ds-icon-accent-purple",
      "color.icon.accent.magenta": "--ds-icon-accent-magenta",
      "color.icon.accent.gray": "--ds-icon-accent-gray",
      "color.icon.disabled": "--ds-icon-disabled",
      "color.icon.inverse": "--ds-icon-inverse",
      "color.icon.selected": "--ds-icon-selected",
      "color.icon.brand": "--ds-icon-brand",
      "color.icon.danger": "--ds-icon-danger",
      "color.icon.warning": "--ds-icon-warning",
      "color.icon.warning.inverse": "--ds-icon-warning-inverse",
      "color.icon.success": "--ds-icon-success",
      "color.icon.discovery": "--ds-icon-discovery",
      "color.icon.information": "--ds-icon-information",
      "color.icon.subtle": "--ds-icon-subtle",
      "color.border": "--ds-border",
      "color.border.accent.red": "--ds-border-accent-red",
      "color.border.accent.orange": "--ds-border-accent-orange",
      "color.border.accent.yellow": "--ds-border-accent-yellow",
      "color.border.accent.green": "--ds-border-accent-green",
      "color.border.accent.teal": "--ds-border-accent-teal",
      "color.border.accent.blue": "--ds-border-accent-blue",
      "color.border.accent.purple": "--ds-border-accent-purple",
      "color.border.accent.magenta": "--ds-border-accent-magenta",
      "color.border.accent.gray": "--ds-border-accent-gray",
      "color.border.disabled": "--ds-border-disabled",
      "color.border.focused": "--ds-border-focused",
      "color.border.input": "--ds-border-input",
      "color.border.inverse": "--ds-border-inverse",
      "color.border.selected": "--ds-border-selected",
      "color.border.brand": "--ds-border-brand",
      "color.border.danger": "--ds-border-danger",
      "color.border.warning": "--ds-border-warning",
      "color.border.success": "--ds-border-success",
      "color.border.discovery": "--ds-border-discovery",
      "color.border.information": "--ds-border-information",
      "color.border.bold": "--ds-border-bold",
      "color.background.accent.red.subtlest": "--ds-background-accent-red-subtlest",
      "color.background.accent.red.subtler": "--ds-background-accent-red-subtler",
      "color.background.accent.red.subtle": "--ds-background-accent-red-subtle",
      "color.background.accent.red.bolder": "--ds-background-accent-red-bolder",
      "color.background.accent.orange.subtlest": "--ds-background-accent-orange-subtlest",
      "color.background.accent.orange.subtler": "--ds-background-accent-orange-subtler",
      "color.background.accent.orange.subtle": "--ds-background-accent-orange-subtle",
      "color.background.accent.orange.bolder": "--ds-background-accent-orange-bolder",
      "color.background.accent.yellow.subtlest": "--ds-background-accent-yellow-subtlest",
      "color.background.accent.yellow.subtler": "--ds-background-accent-yellow-subtler",
      "color.background.accent.yellow.subtle": "--ds-background-accent-yellow-subtle",
      "color.background.accent.yellow.bolder": "--ds-background-accent-yellow-bolder",
      "color.background.accent.green.subtlest": "--ds-background-accent-green-subtlest",
      "color.background.accent.green.subtler": "--ds-background-accent-green-subtler",
      "color.background.accent.green.subtle": "--ds-background-accent-green-subtle",
      "color.background.accent.green.bolder": "--ds-background-accent-green-bolder",
      "color.background.accent.teal.subtlest": "--ds-background-accent-teal-subtlest",
      "color.background.accent.teal.subtler": "--ds-background-accent-teal-subtler",
      "color.background.accent.teal.subtle": "--ds-background-accent-teal-subtle",
      "color.background.accent.teal.bolder": "--ds-background-accent-teal-bolder",
      "color.background.accent.blue.subtlest": "--ds-background-accent-blue-subtlest",
      "color.background.accent.blue.subtler": "--ds-background-accent-blue-subtler",
      "color.background.accent.blue.subtle": "--ds-background-accent-blue-subtle",
      "color.background.accent.blue.bolder": "--ds-background-accent-blue-bolder",
      "color.background.accent.purple.subtlest": "--ds-background-accent-purple-subtlest",
      "color.background.accent.purple.subtler": "--ds-background-accent-purple-subtler",
      "color.background.accent.purple.subtle": "--ds-background-accent-purple-subtle",
      "color.background.accent.purple.bolder": "--ds-background-accent-purple-bolder",
      "color.background.accent.magenta.subtlest": "--ds-background-accent-magenta-subtlest",
      "color.background.accent.magenta.subtler": "--ds-background-accent-magenta-subtler",
      "color.background.accent.magenta.subtle": "--ds-background-accent-magenta-subtle",
      "color.background.accent.magenta.bolder": "--ds-background-accent-magenta-bolder",
      "color.background.accent.gray.subtlest": "--ds-background-accent-gray-subtlest",
      "color.background.accent.gray.subtler": "--ds-background-accent-gray-subtler",
      "color.background.accent.gray.subtle": "--ds-background-accent-gray-subtle",
      "color.background.accent.gray.bolder": "--ds-background-accent-gray-bolder",
      "color.background.disabled": "--ds-background-disabled",
      "color.background.input": "--ds-background-input",
      "color.background.input.hovered": "--ds-background-input-hovered",
      "color.background.input.pressed": "--ds-background-input-pressed",
      "color.background.inverse.subtle": "--ds-background-inverse-subtle",
      "color.background.inverse.subtle.hovered": "--ds-background-inverse-subtle-hovered",
      "color.background.inverse.subtle.pressed": "--ds-background-inverse-subtle-pressed",
      "color.background.neutral": "--ds-background-neutral",
      "color.background.neutral.hovered": "--ds-background-neutral-hovered",
      "color.background.neutral.pressed": "--ds-background-neutral-pressed",
      "color.background.neutral.subtle": "--ds-background-neutral-subtle",
      "color.background.neutral.subtle.hovered": "--ds-background-neutral-subtle-hovered",
      "color.background.neutral.subtle.pressed": "--ds-background-neutral-subtle-pressed",
      "color.background.neutral.bold": "--ds-background-neutral-bold",
      "color.background.neutral.bold.hovered": "--ds-background-neutral-bold-hovered",
      "color.background.neutral.bold.pressed": "--ds-background-neutral-bold-pressed",
      "color.background.selected": "--ds-background-selected",
      "color.background.selected.hovered": "--ds-background-selected-hovered",
      "color.background.selected.pressed": "--ds-background-selected-pressed",
      "color.background.selected.bold": "--ds-background-selected-bold",
      "color.background.selected.bold.hovered": "--ds-background-selected-bold-hovered",
      "color.background.selected.bold.pressed": "--ds-background-selected-bold-pressed",
      "color.background.brand.bold": "--ds-background-brand-bold",
      "color.background.brand.bold.hovered": "--ds-background-brand-bold-hovered",
      "color.background.brand.bold.pressed": "--ds-background-brand-bold-pressed",
      "color.background.danger": "--ds-background-danger",
      "color.background.danger.hovered": "--ds-background-danger-hovered",
      "color.background.danger.pressed": "--ds-background-danger-pressed",
      "color.background.danger.bold": "--ds-background-danger-bold",
      "color.background.danger.bold.hovered": "--ds-background-danger-bold-hovered",
      "color.background.danger.bold.pressed": "--ds-background-danger-bold-pressed",
      "color.background.warning": "--ds-background-warning",
      "color.background.warning.hovered": "--ds-background-warning-hovered",
      "color.background.warning.pressed": "--ds-background-warning-pressed",
      "color.background.warning.bold": "--ds-background-warning-bold",
      "color.background.warning.bold.hovered": "--ds-background-warning-bold-hovered",
      "color.background.warning.bold.pressed": "--ds-background-warning-bold-pressed",
      "color.background.success": "--ds-background-success",
      "color.background.success.hovered": "--ds-background-success-hovered",
      "color.background.success.pressed": "--ds-background-success-pressed",
      "color.background.success.bold": "--ds-background-success-bold",
      "color.background.success.bold.hovered": "--ds-background-success-bold-hovered",
      "color.background.success.bold.pressed": "--ds-background-success-bold-pressed",
      "color.background.discovery": "--ds-background-discovery",
      "color.background.discovery.hovered": "--ds-background-discovery-hovered",
      "color.background.discovery.pressed": "--ds-background-discovery-pressed",
      "color.background.discovery.bold": "--ds-background-discovery-bold",
      "color.background.discovery.bold.hovered": "--ds-background-discovery-bold-hovered",
      "color.background.discovery.bold.pressed": "--ds-background-discovery-bold-pressed",
      "color.background.information": "--ds-background-information",
      "color.background.information.hovered": "--ds-background-information-hovered",
      "color.background.information.pressed": "--ds-background-information-pressed",
      "color.background.information.bold": "--ds-background-information-bold",
      "color.background.information.bold.hovered": "--ds-background-information-bold-hovered",
      "color.background.information.bold.pressed": "--ds-background-information-bold-pressed",
      "color.blanket": "--ds-blanket",
      "color.blanket.selected": "--ds-blanket-selected",
      "color.blanket.danger": "--ds-blanket-danger",
      "color.interaction.hovered": "--ds-interaction-hovered",
      "color.interaction.pressed": "--ds-interaction-pressed",
      "color.skeleton": "--ds-skeleton",
      "color.skeleton.subtle": "--ds-skeleton-subtle",
      "color.chart.categorical.1": "--ds-chart-categorical-1",
      "color.chart.categorical.1.hovered": "--ds-chart-categorical-1-hovered",
      "color.chart.categorical.2": "--ds-chart-categorical-2",
      "color.chart.categorical.2.hovered": "--ds-chart-categorical-2-hovered",
      "color.chart.categorical.3": "--ds-chart-categorical-3",
      "color.chart.categorical.3.hovered": "--ds-chart-categorical-3-hovered",
      "color.chart.categorical.4": "--ds-chart-categorical-4",
      "color.chart.categorical.4.hovered": "--ds-chart-categorical-4-hovered",
      "color.chart.categorical.5": "--ds-chart-categorical-5",
      "color.chart.categorical.5.hovered": "--ds-chart-categorical-5-hovered",
      "color.chart.categorical.6": "--ds-chart-categorical-6",
      "color.chart.categorical.6.hovered": "--ds-chart-categorical-6-hovered",
      "color.chart.categorical.7": "--ds-chart-categorical-7",
      "color.chart.categorical.7.hovered": "--ds-chart-categorical-7-hovered",
      "color.chart.categorical.8": "--ds-chart-categorical-8",
      "color.chart.categorical.8.hovered": "--ds-chart-categorical-8-hovered",
      "color.chart.neutral": "--ds-chart-neutral",
      "color.chart.neutral.hovered": "--ds-chart-neutral-hovered",
      "color.chart.red.bold": "--ds-chart-red-bold",
      "color.chart.red.bold.hovered": "--ds-chart-red-bold-hovered",
      "color.chart.red.bolder": "--ds-chart-red-bolder",
      "color.chart.red.bolder.hovered": "--ds-chart-red-bolder-hovered",
      "color.chart.red.boldest": "--ds-chart-red-boldest",
      "color.chart.red.boldest.hovered": "--ds-chart-red-boldest-hovered",
      "color.chart.orange.bold": "--ds-chart-orange-bold",
      "color.chart.orange.bold.hovered": "--ds-chart-orange-bold-hovered",
      "color.chart.orange.bolder": "--ds-chart-orange-bolder",
      "color.chart.orange.bolder.hovered": "--ds-chart-orange-bolder-hovered",
      "color.chart.orange.boldest": "--ds-chart-orange-boldest",
      "color.chart.orange.boldest.hovered": "--ds-chart-orange-boldest-hovered",
      "color.chart.yellow.bold": "--ds-chart-yellow-bold",
      "color.chart.yellow.bold.hovered": "--ds-chart-yellow-bold-hovered",
      "color.chart.yellow.bolder": "--ds-chart-yellow-bolder",
      "color.chart.yellow.bolder.hovered": "--ds-chart-yellow-bolder-hovered",
      "color.chart.yellow.boldest": "--ds-chart-yellow-boldest",
      "color.chart.yellow.boldest.hovered": "--ds-chart-yellow-boldest-hovered",
      "color.chart.green.bold": "--ds-chart-green-bold",
      "color.chart.green.bold.hovered": "--ds-chart-green-bold-hovered",
      "color.chart.green.bolder": "--ds-chart-green-bolder",
      "color.chart.green.bolder.hovered": "--ds-chart-green-bolder-hovered",
      "color.chart.green.boldest": "--ds-chart-green-boldest",
      "color.chart.green.boldest.hovered": "--ds-chart-green-boldest-hovered",
      "color.chart.teal.bold": "--ds-chart-teal-bold",
      "color.chart.teal.bold.hovered": "--ds-chart-teal-bold-hovered",
      "color.chart.teal.bolder": "--ds-chart-teal-bolder",
      "color.chart.teal.bolder.hovered": "--ds-chart-teal-bolder-hovered",
      "color.chart.teal.boldest": "--ds-chart-teal-boldest",
      "color.chart.teal.boldest.hovered": "--ds-chart-teal-boldest-hovered",
      "color.chart.blue.bold": "--ds-chart-blue-bold",
      "color.chart.blue.bold.hovered": "--ds-chart-blue-bold-hovered",
      "color.chart.blue.bolder": "--ds-chart-blue-bolder",
      "color.chart.blue.bolder.hovered": "--ds-chart-blue-bolder-hovered",
      "color.chart.blue.boldest": "--ds-chart-blue-boldest",
      "color.chart.blue.boldest.hovered": "--ds-chart-blue-boldest-hovered",
      "color.chart.purple.bold": "--ds-chart-purple-bold",
      "color.chart.purple.bold.hovered": "--ds-chart-purple-bold-hovered",
      "color.chart.purple.bolder": "--ds-chart-purple-bolder",
      "color.chart.purple.bolder.hovered": "--ds-chart-purple-bolder-hovered",
      "color.chart.purple.boldest": "--ds-chart-purple-boldest",
      "color.chart.purple.boldest.hovered": "--ds-chart-purple-boldest-hovered",
      "color.chart.magenta.bold": "--ds-chart-magenta-bold",
      "color.chart.magenta.bold.hovered": "--ds-chart-magenta-bold-hovered",
      "color.chart.magenta.bolder": "--ds-chart-magenta-bolder",
      "color.chart.magenta.bolder.hovered": "--ds-chart-magenta-bolder-hovered",
      "color.chart.magenta.boldest": "--ds-chart-magenta-boldest",
      "color.chart.magenta.boldest.hovered": "--ds-chart-magenta-boldest-hovered",
      "color.chart.gray.bold": "--ds-chart-gray-bold",
      "color.chart.gray.bold.hovered": "--ds-chart-gray-bold-hovered",
      "color.chart.gray.bolder": "--ds-chart-gray-bolder",
      "color.chart.gray.bolder.hovered": "--ds-chart-gray-bolder-hovered",
      "color.chart.gray.boldest": "--ds-chart-gray-boldest",
      "color.chart.gray.boldest.hovered": "--ds-chart-gray-boldest-hovered",
      "color.chart.brand": "--ds-chart-brand",
      "color.chart.brand.hovered": "--ds-chart-brand-hovered",
      "color.chart.danger": "--ds-chart-danger",
      "color.chart.danger.hovered": "--ds-chart-danger-hovered",
      "color.chart.danger.bold": "--ds-chart-danger-bold",
      "color.chart.danger.bold.hovered": "--ds-chart-danger-bold-hovered",
      "color.chart.warning": "--ds-chart-warning",
      "color.chart.warning.hovered": "--ds-chart-warning-hovered",
      "color.chart.warning.bold": "--ds-chart-warning-bold",
      "color.chart.warning.bold.hovered": "--ds-chart-warning-bold-hovered",
      "color.chart.success": "--ds-chart-success",
      "color.chart.success.hovered": "--ds-chart-success-hovered",
      "color.chart.success.bold": "--ds-chart-success-bold",
      "color.chart.success.bold.hovered": "--ds-chart-success-bold-hovered",
      "color.chart.discovery": "--ds-chart-discovery",
      "color.chart.discovery.hovered": "--ds-chart-discovery-hovered",
      "color.chart.discovery.bold": "--ds-chart-discovery-bold",
      "color.chart.discovery.bold.hovered": "--ds-chart-discovery-bold-hovered",
      "color.chart.information": "--ds-chart-information",
      "color.chart.information.hovered": "--ds-chart-information-hovered",
      "color.chart.information.bold": "--ds-chart-information-bold",
      "color.chart.information.bold.hovered": "--ds-chart-information-bold-hovered",
      "elevation.surface": "--ds-surface",
      "elevation.surface.hovered": "--ds-surface-hovered",
      "elevation.surface.pressed": "--ds-surface-pressed",
      "elevation.surface.overlay": "--ds-surface-overlay",
      "elevation.surface.overlay.hovered": "--ds-surface-overlay-hovered",
      "elevation.surface.overlay.pressed": "--ds-surface-overlay-pressed",
      "elevation.surface.raised": "--ds-surface-raised",
      "elevation.surface.raised.hovered": "--ds-surface-raised-hovered",
      "elevation.surface.raised.pressed": "--ds-surface-raised-pressed",
      "elevation.surface.sunken": "--ds-surface-sunken",
      "elevation.shadow.overflow": "--ds-shadow-overflow",
      "elevation.shadow.overflow.perimeter": "--ds-shadow-overflow-perimeter",
      "elevation.shadow.overflow.spread": "--ds-shadow-overflow-spread",
      "elevation.shadow.overlay": "--ds-shadow-overlay",
      "elevation.shadow.raised": "--ds-shadow-raised",
      "opacity.disabled": "--ds-opacity-disabled",
      "opacity.loading": "--ds-opacity-loading",
      "utility.UNSAFE.transparent": "--ds-UNSAFE-transparent",
      "space.0": "--ds-space-0",
      "space.025": "--ds-space-025",
      "space.050": "--ds-space-050",
      "space.075": "--ds-space-075",
      "space.100": "--ds-space-100",
      "space.150": "--ds-space-150",
      "space.200": "--ds-space-200",
      "space.250": "--ds-space-250",
      "space.300": "--ds-space-300",
      "space.400": "--ds-space-400",
      "space.500": "--ds-space-500",
      "space.600": "--ds-space-600",
      "space.800": "--ds-space-800",
      "space.1000": "--ds-space-1000",
      "font.family.monospace": "--ds-font-family-monospace",
      "font.family.sans": "--ds-font-family-sans",
      "font.size.050": "--ds-font-size-050",
      "font.size.075": "--ds-font-size-075",
      "font.size.100": "--ds-font-size-100",
      "font.size.200": "--ds-font-size-200",
      "font.size.300": "--ds-font-size-300",
      "font.size.400": "--ds-font-size-400",
      "font.size.500": "--ds-font-size-500",
      "font.size.600": "--ds-font-size-600",
      "font.weight.bold": "--ds-font-weight-bold",
      "font.weight.medium": "--ds-font-weight-medium",
      "font.weight.regular": "--ds-font-weight-regular",
      "font.weight.semibold": "--ds-font-weight-semibold",
      "font.lineHeight.100": "--ds-font-lineHeight-100",
      "font.lineHeight.200": "--ds-font-lineHeight-200",
      "font.lineHeight.300": "--ds-font-lineHeight-300",
      "font.lineHeight.400": "--ds-font-lineHeight-400",
      "font.lineHeight.500": "--ds-font-lineHeight-500",
      "font.lineHeight.600": "--ds-font-lineHeight-600"
    };
    var _default = tokens;
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TOKEN_NOT_FOUND_CSS_VAR = exports.THEME_DATA_ATTRIBUTE = exports.DEFAULT_THEME = exports.CSS_VAR_FULL = exports.CSS_PREFIX = exports.COLOR_MODE_ATTRIBUTE = void 0;
    var THEME_DATA_ATTRIBUTE = "data-theme";
    exports.THEME_DATA_ATTRIBUTE = THEME_DATA_ATTRIBUTE;
    var COLOR_MODE_ATTRIBUTE = "data-color-mode";
    exports.COLOR_MODE_ATTRIBUTE = COLOR_MODE_ATTRIBUTE;
    var DEFAULT_THEME = "light";
    exports.DEFAULT_THEME = DEFAULT_THEME;
    var CSS_PREFIX = "ds";
    exports.CSS_PREFIX = CSS_PREFIX;
    var CSS_VAR_FULL = ["opacity", "font", "space"];
    exports.CSS_VAR_FULL = CSS_VAR_FULL;
    var TOKEN_NOT_FOUND_CSS_VAR = "--".concat(CSS_PREFIX, "-token-not-found");
    exports.TOKEN_NOT_FOUND_CSS_VAR = TOKEN_NOT_FOUND_CSS_VAR;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/get-token.js
var require_get_token = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/get-token.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _warnOnce = _interopRequireDefault(require_warn_once());
    var _tokenNames = _interopRequireDefault(require_token_names());
    var _constants = require_constants();
    var name = "@atlaskit/tokens";
    var version = "1.2.15";
    function token(path, fallback) {
      var token2 = _tokenNames.default[path];
      if (typeof process !== "undefined" && process.env.NODE_ENV !== "production" && !token2) {
        (0, _warnOnce.default)("Unknown token id at path: ".concat(path, " for ").concat(name, "@").concat(version));
      }
      if (!token2) {
        token2 = _constants.TOKEN_NOT_FOUND_CSS_VAR;
      }
      var tokenCall = fallback ? "var(".concat(token2, ", ").concat(fallback, ")") : "var(".concat(token2, ")");
      return tokenCall;
    }
    var _default = token;
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/get-token-value.js
var require_get_token_value = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/get-token-value.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _warnOnce = _interopRequireDefault(require_warn_once());
    var _tokenNames = _interopRequireDefault(require_token_names());
    var name = "@atlaskit/tokens";
    var version = "1.2.15";
    function getTokenValue(tokenId) {
      var fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var token = _tokenNames.default[tokenId];
      var tokenValue = fallback;
      if (typeof process !== "undefined" && process.env.NODE_ENV !== "production" && !token) {
        (0, _warnOnce.default)("Unknown token id at path: ".concat(tokenId, " for ").concat(name, "@").concat(version));
      }
      if (typeof window === "undefined") {
        return tokenValue;
      }
      tokenValue = window.getComputedStyle(document.documentElement).getPropertyValue(token).trim();
      tokenValue = tokenValue || fallback;
      return tokenValue;
    }
    var _default = getTokenValue;
    exports.default = _default;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return arrayLikeToArray(arr);
    }
    module2.exports = _arrayWithoutHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module2) {
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module2.exports = _iterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module2) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableSpread, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module2) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module2.exports = _toConsumableArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module2) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args2 = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args2);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/bind-event-listener/dist/bind.js
var require_bind = __commonJS({
  "node_modules/bind-event-listener/dist/bind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bind = void 0;
    function bind(target, _a) {
      var type = _a.type, listener = _a.listener, options = _a.options;
      target.addEventListener(type, listener, options);
      return function unbind() {
        target.removeEventListener(type, listener, options);
      };
    }
    exports.bind = bind;
  }
});

// node_modules/bind-event-listener/dist/bind-all.js
var require_bind_all = __commonJS({
  "node_modules/bind-event-listener/dist/bind-all.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindAll = void 0;
    var bind_1 = require_bind();
    function toOptions(value) {
      if (typeof value === "undefined") {
        return void 0;
      }
      if (typeof value === "boolean") {
        return {
          capture: value
        };
      }
      return value;
    }
    function getBinding(original, sharedOptions) {
      if (sharedOptions == null) {
        return original;
      }
      var binding = __assign(__assign({}, original), { options: __assign(__assign({}, toOptions(sharedOptions)), toOptions(original.options)) });
      return binding;
    }
    function bindAll(target, bindings, sharedOptions) {
      var unbinds = bindings.map(function(original) {
        var binding = getBinding(original, sharedOptions);
        return (0, bind_1.bind)(target, binding);
      });
      return function unbindAll() {
        unbinds.forEach(function(unbind) {
          return unbind();
        });
      };
    }
    exports.bindAll = bindAll;
  }
});

// node_modules/bind-event-listener/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/bind-event-listener/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindAll = exports.bind = void 0;
    var bind_1 = require_bind();
    Object.defineProperty(exports, "bind", { enumerable: true, get: function() {
      return bind_1.bind;
    } });
    var bind_all_1 = require_bind_all();
    Object.defineProperty(exports, "bindAll", { enumerable: true, get: function() {
      return bind_all_1.bindAll;
    } });
  }
});

// node_modules/@atlaskit/ds-lib/dist/cjs/utils/noop.js
var require_noop = __commonJS({
  "node_modules/@atlaskit/ds-lib/dist/cjs/utils/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = noop;
    function noop() {
    }
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/cjs/debug.js
var require_debug = __commonJS({
  "node_modules/@atlaskit/platform-feature-flags/dist/cjs/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.debug = void 0;
    var _ref;
    var _globalThis$process;
    var _globalThis$process$e;
    var _globalThis$process2;
    var _globalThis$process2$;
    var TESTS_MODE = (_ref = (globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$process = globalThis.process) === null || _globalThis$process === void 0 ? void 0 : (_globalThis$process$e = _globalThis$process.env) === null || _globalThis$process$e === void 0 ? void 0 : _globalThis$process$e.JEST_WORKER_ID) !== void 0) !== null && _ref !== void 0 ? _ref : false;
    var DEBUG_MODE = !TESTS_MODE && (globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$process2 = globalThis.process) === null || _globalThis$process2 === void 0 ? void 0 : (_globalThis$process2$ = _globalThis$process2.env) === null || _globalThis$process2$ === void 0 ? void 0 : _globalThis$process2$.NODE_ENV) !== "production";
    var debug = function debug2() {
      var _console;
      if (!DEBUG_MODE) {
        return;
      }
      (_console = console).debug.apply(_console, arguments);
    };
    exports.debug = debug;
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/cjs/resolvers.js
var require_resolvers = __commonJS({
  "node_modules/@atlaskit/platform-feature-flags/dist/cjs/resolvers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveBooleanFlag = resolveBooleanFlag;
    exports.setBooleanResolver = setBooleanResolver;
    var _debug = require_debug();
    var pkgName = "@atlaskit/platform-feature-flags";
    var hasProcessEnv = typeof process !== "undefined" && typeof process.env !== "undefined";
    var ENV_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    var ENV_STORYBOOK_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["STORYBOOK_ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    var ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE = ENV_ENABLE_PLATFORM_FF || ENV_STORYBOOK_ENABLE_PLATFORM_FF;
    var booleanResolver = function booleanResolver2() {
      return false;
    };
    function setBooleanResolver(resolver) {
      booleanResolver = resolver;
    }
    function resolveBooleanFlag(flagKey) {
      if (ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE) {
        (0, _debug.debug)('[%s]: The feature flags were enabled while running tests. The flag "%s" will be always enabled.', pkgName, flagKey);
        return true;
      }
      try {
        var result = booleanResolver(flagKey);
        if (typeof result !== "boolean") {
          console.warn("".concat(flagKey, " resolved to a non-boolean value, returning false for safety"));
          return false;
        }
        return result;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@atlaskit/platform-feature-flags/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getBooleanFF = getBooleanFF;
    exports.setBooleanFeatureFlagResolver = setBooleanFeatureFlagResolver;
    var _resolvers = require_resolvers();
    function setBooleanFeatureFlagResolver(flagResolver) {
      (0, _resolvers.setBooleanResolver)(flagResolver);
    }
    function getBooleanFF(name) {
      return (0, _resolvers.resolveBooleanFlag)(name);
    }
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-light.js
var require_atlassian_light = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-color-mode="light"][data-theme~="light:light"],\nhtml[data-color-mode="dark"][data-theme~="dark:light"] {\n  --ds-text: #172B4D;\n  --ds-text-accent-red: #AE2A19;\n  --ds-text-accent-red-bolder: #601E16;\n  --ds-text-accent-orange: #974F0C;\n  --ds-text-accent-orange-bolder: #5F3811;\n  --ds-text-accent-yellow: #7F5F01;\n  --ds-text-accent-yellow-bolder: #533F04;\n  --ds-text-accent-green: #216E4E;\n  --ds-text-accent-green-bolder: #164B35;\n  --ds-text-accent-teal: #206B74;\n  --ds-text-accent-teal-bolder: #1D474C;\n  --ds-text-accent-blue: #0055CC;\n  --ds-text-accent-blue-bolder: #09326C;\n  --ds-text-accent-purple: #5E4DB2;\n  --ds-text-accent-purple-bolder: #352C63;\n  --ds-text-accent-magenta: #943D73;\n  --ds-text-accent-magenta-bolder: #50253F;\n  --ds-text-accent-gray: #44546F;\n  --ds-text-accent-gray-bolder: #091E42;\n  --ds-text-disabled: #091E424F;\n  --ds-text-inverse: #FFFFFF;\n  --ds-text-selected: #0C66E4;\n  --ds-text-brand: #0C66E4;\n  --ds-text-danger: #AE2A19;\n  --ds-text-warning: #974F0C;\n  --ds-text-warning-inverse: #172B4D;\n  --ds-text-success: #216E4E;\n  --ds-text-discovery: #5E4DB2;\n  --ds-text-information: #0055CC;\n  --ds-text-subtlest: #626F86;\n  --ds-text-subtle: #44546F;\n  --ds-link: #0C66E4;\n  --ds-link-pressed: #0055CC;\n  --ds-icon: #44546F;\n  --ds-icon-accent-red: #E34935;\n  --ds-icon-accent-orange: #D97008;\n  --ds-icon-accent-yellow: #B38600;\n  --ds-icon-accent-green: #22A06B;\n  --ds-icon-accent-teal: #1D9AAA;\n  --ds-icon-accent-blue: #1D7AFC;\n  --ds-icon-accent-purple: #8270DB;\n  --ds-icon-accent-magenta: #CD519D;\n  --ds-icon-accent-gray: #758195;\n  --ds-icon-disabled: #091E424F;\n  --ds-icon-inverse: #FFFFFF;\n  --ds-icon-selected: #0C66E4;\n  --ds-icon-brand: #0C66E4;\n  --ds-icon-danger: #E34935;\n  --ds-icon-warning: #D97008;\n  --ds-icon-warning-inverse: #172B4D;\n  --ds-icon-success: #22A06B;\n  --ds-icon-discovery: #8270DB;\n  --ds-icon-information: #1D7AFC;\n  --ds-icon-subtle: #626F86;\n  --ds-border: #091E4224;\n  --ds-border-accent-red: #E34935;\n  --ds-border-accent-orange: #D97008;\n  --ds-border-accent-yellow: #B38600;\n  --ds-border-accent-green: #22A06B;\n  --ds-border-accent-teal: #1D9AAA;\n  --ds-border-accent-blue: #1D7AFC;\n  --ds-border-accent-purple: #8270DB;\n  --ds-border-accent-magenta: #CD519D;\n  --ds-border-accent-gray: #758195;\n  --ds-border-disabled: #091E420F;\n  --ds-border-focused: #388BFF;\n  --ds-border-input: #091E4224;\n  --ds-border-inverse: #FFFFFF;\n  --ds-border-selected: #0C66E4;\n  --ds-border-brand: #0C66E4;\n  --ds-border-danger: #E34935;\n  --ds-border-warning: #D97008;\n  --ds-border-success: #22A06B;\n  --ds-border-discovery: #8270DB;\n  --ds-border-information: #1D7AFC;\n  --ds-border-bold: #758195;\n  --ds-background-accent-red-subtlest: #FFEDEB;\n  --ds-background-accent-red-subtler: #FFD2CC;\n  --ds-background-accent-red-subtle: #F87462;\n  --ds-background-accent-red-bolder: #CA3521;\n  --ds-background-accent-orange-subtlest: #FFF4E5;\n  --ds-background-accent-orange-subtler: #FFE2BD;\n  --ds-background-accent-orange-subtle: #FAA53D;\n  --ds-background-accent-orange-bolder: #B65C02;\n  --ds-background-accent-yellow-subtlest: #FFF7D6;\n  --ds-background-accent-yellow-subtler: #F8E6A0;\n  --ds-background-accent-yellow-subtle: #E2B203;\n  --ds-background-accent-yellow-bolder: #946F00;\n  --ds-background-accent-green-subtlest: #DFFCF0;\n  --ds-background-accent-green-subtler: #BAF3DB;\n  --ds-background-accent-green-subtle: #4BCE97;\n  --ds-background-accent-green-bolder: #1F845A;\n  --ds-background-accent-teal-subtlest: #E3FAFC;\n  --ds-background-accent-teal-subtler: #C1F0F5;\n  --ds-background-accent-teal-subtle: #60C6D2;\n  --ds-background-accent-teal-bolder: #1D7F8C;\n  --ds-background-accent-blue-subtlest: #E9F2FF;\n  --ds-background-accent-blue-subtler: #CCE0FF;\n  --ds-background-accent-blue-subtle: #579DFF;\n  --ds-background-accent-blue-bolder: #0C66E4;\n  --ds-background-accent-purple-subtlest: #F3F0FF;\n  --ds-background-accent-purple-subtler: #DFD8FD;\n  --ds-background-accent-purple-subtle: #9F8FEF;\n  --ds-background-accent-purple-bolder: #6E5DC6;\n  --ds-background-accent-magenta-subtlest: #FFECF8;\n  --ds-background-accent-magenta-subtler: #FDD0EC;\n  --ds-background-accent-magenta-subtle: #E774BB;\n  --ds-background-accent-magenta-bolder: #AE4787;\n  --ds-background-accent-gray-subtlest: #F1F2F4;\n  --ds-background-accent-gray-subtler: #DCDFE4;\n  --ds-background-accent-gray-subtle: #8590A2;\n  --ds-background-accent-gray-bolder: #626F86;\n  --ds-background-disabled: #091E4208;\n  --ds-background-input: #FFFFFF;\n  --ds-background-input-hovered: #F7F8F9;\n  --ds-background-input-pressed: #FFFFFF;\n  --ds-background-inverse-subtle: #00000029;\n  --ds-background-inverse-subtle-hovered: #0000003D;\n  --ds-background-inverse-subtle-pressed: #00000052;\n  --ds-background-neutral: #091E420F;\n  --ds-background-neutral-hovered: #091E4224;\n  --ds-background-neutral-pressed: #091E424F;\n  --ds-background-neutral-subtle: #00000000;\n  --ds-background-neutral-subtle-hovered: #091E420F;\n  --ds-background-neutral-subtle-pressed: #091E4224;\n  --ds-background-neutral-bold: #44546F;\n  --ds-background-neutral-bold-hovered: #2C3E5D;\n  --ds-background-neutral-bold-pressed: #172B4D;\n  --ds-background-selected: #E9F2FF;\n  --ds-background-selected-hovered: #CCE0FF;\n  --ds-background-selected-pressed: #85B8FF;\n  --ds-background-selected-bold: #0C66E4;\n  --ds-background-selected-bold-hovered: #0055CC;\n  --ds-background-selected-bold-pressed: #09326C;\n  --ds-background-brand-bold: #0C66E4;\n  --ds-background-brand-bold-hovered: #0055CC;\n  --ds-background-brand-bold-pressed: #09326C;\n  --ds-background-danger: #FFEDEB;\n  --ds-background-danger-hovered: #FFD2CC;\n  --ds-background-danger-pressed: #FF9C8F;\n  --ds-background-danger-bold: #CA3521;\n  --ds-background-danger-bold-hovered: #AE2A19;\n  --ds-background-danger-bold-pressed: #601E16;\n  --ds-background-warning: #FFF7D6;\n  --ds-background-warning-hovered: #F8E6A0;\n  --ds-background-warning-pressed: #F5CD47;\n  --ds-background-warning-bold: #E2B203;\n  --ds-background-warning-bold-hovered: #CF9F02;\n  --ds-background-warning-bold-pressed: #B38600;\n  --ds-background-success: #DFFCF0;\n  --ds-background-success-hovered: #BAF3DB;\n  --ds-background-success-pressed: #7EE2B8;\n  --ds-background-success-bold: #1F845A;\n  --ds-background-success-bold-hovered: #216E4E;\n  --ds-background-success-bold-pressed: #164B35;\n  --ds-background-discovery: #F3F0FF;\n  --ds-background-discovery-hovered: #DFD8FD;\n  --ds-background-discovery-pressed: #B8ACF6;\n  --ds-background-discovery-bold: #6E5DC6;\n  --ds-background-discovery-bold-hovered: #5E4DB2;\n  --ds-background-discovery-bold-pressed: #352C63;\n  --ds-background-information: #E9F2FF;\n  --ds-background-information-hovered: #CCE0FF;\n  --ds-background-information-pressed: #85B8FF;\n  --ds-background-information-bold: #0C66E4;\n  --ds-background-information-bold-hovered: #0055CC;\n  --ds-background-information-bold-pressed: #09326C;\n  --ds-blanket: #091E427D;\n  --ds-blanket-selected: #388BFF14;\n  --ds-blanket-danger: #EF5C4814;\n  --ds-interaction-hovered: #00000029;\n  --ds-interaction-pressed: #00000052;\n  --ds-skeleton: #091E420F;\n  --ds-skeleton-subtle: #091E4208;\n  --ds-chart-categorical-1: #1D9AAA;\n  --ds-chart-categorical-1-hovered: #1D7F8C;\n  --ds-chart-categorical-2: #5E4DB2;\n  --ds-chart-categorical-2-hovered: #352C63;\n  --ds-chart-categorical-3: #D97008;\n  --ds-chart-categorical-3-hovered: #B65C02;\n  --ds-chart-categorical-4: #943D73;\n  --ds-chart-categorical-4-hovered: #50253F;\n  --ds-chart-categorical-5: #09326C;\n  --ds-chart-categorical-5-hovered: #082145;\n  --ds-chart-categorical-6: #8F7EE7;\n  --ds-chart-categorical-6-hovered: #8270DB;\n  --ds-chart-categorical-7: #50253F;\n  --ds-chart-categorical-7-hovered: #341829;\n  --ds-chart-categorical-8: #974F0C;\n  --ds-chart-categorical-8-hovered: #5F3811;\n  --ds-chart-neutral: #8590A2;\n  --ds-chart-neutral-hovered: #758195;\n  --ds-chart-red-bold: #EF5C48;\n  --ds-chart-red-bold-hovered: #E34935;\n  --ds-chart-red-bolder: #E34935;\n  --ds-chart-red-bolder-hovered: #CA3521;\n  --ds-chart-red-boldest: #AE2A19;\n  --ds-chart-red-boldest-hovered: #601E16;\n  --ds-chart-orange-bold: #D97008;\n  --ds-chart-orange-bold-hovered: #B65C02;\n  --ds-chart-orange-bolder: #B65C02;\n  --ds-chart-orange-bolder-hovered: #974F0C;\n  --ds-chart-orange-boldest: #974F0C;\n  --ds-chart-orange-boldest-hovered: #5F3811;\n  --ds-chart-yellow-bold: #B38600;\n  --ds-chart-yellow-bold-hovered: #946F00;\n  --ds-chart-yellow-bolder: #946F00;\n  --ds-chart-yellow-bolder-hovered: #7F5F01;\n  --ds-chart-yellow-boldest: #7F5F01;\n  --ds-chart-yellow-boldest-hovered: #533F04;\n  --ds-chart-green-bold: #22A06B;\n  --ds-chart-green-bold-hovered: #1F845A;\n  --ds-chart-green-bolder: #1F845A;\n  --ds-chart-green-bolder-hovered: #216E4E;\n  --ds-chart-green-boldest: #216E4E;\n  --ds-chart-green-boldest-hovered: #164B35;\n  --ds-chart-teal-bold: #1D9AAA;\n  --ds-chart-teal-bold-hovered: #1D7F8C;\n  --ds-chart-teal-bolder: #1D7F8C;\n  --ds-chart-teal-bolder-hovered: #206B74;\n  --ds-chart-teal-boldest: #206B74;\n  --ds-chart-teal-boldest-hovered: #1D474C;\n  --ds-chart-blue-bold: #388BFF;\n  --ds-chart-blue-bold-hovered: #1D7AFC;\n  --ds-chart-blue-bolder: #1D7AFC;\n  --ds-chart-blue-bolder-hovered: #0C66E4;\n  --ds-chart-blue-boldest: #0055CC;\n  --ds-chart-blue-boldest-hovered: #09326C;\n  --ds-chart-purple-bold: #8F7EE7;\n  --ds-chart-purple-bold-hovered: #8270DB;\n  --ds-chart-purple-bolder: #8270DB;\n  --ds-chart-purple-bolder-hovered: #6E5DC6;\n  --ds-chart-purple-boldest: #5E4DB2;\n  --ds-chart-purple-boldest-hovered: #352C63;\n  --ds-chart-magenta-bold: #DA62AC;\n  --ds-chart-magenta-bold-hovered: #CD519D;\n  --ds-chart-magenta-bolder: #CD519D;\n  --ds-chart-magenta-bolder-hovered: #AE4787;\n  --ds-chart-magenta-boldest: #943D73;\n  --ds-chart-magenta-boldest-hovered: #50253F;\n  --ds-chart-gray-bold: #8590A2;\n  --ds-chart-gray-bold-hovered: #758195;\n  --ds-chart-gray-bolder: #758195;\n  --ds-chart-gray-bolder-hovered: #626F86;\n  --ds-chart-gray-boldest: #44546F;\n  --ds-chart-gray-boldest-hovered: #2C3E5D;\n  --ds-chart-brand: #1D7AFC;\n  --ds-chart-brand-hovered: #0C66E4;\n  --ds-chart-danger: #EF5C48;\n  --ds-chart-danger-hovered: #E34935;\n  --ds-chart-danger-bold: #AE2A19;\n  --ds-chart-danger-bold-hovered: #601E16;\n  --ds-chart-warning: #B38600;\n  --ds-chart-warning-hovered: #946F00;\n  --ds-chart-warning-bold: #7F5F01;\n  --ds-chart-warning-bold-hovered: #533F04;\n  --ds-chart-success: #22A06B;\n  --ds-chart-success-hovered: #1F845A;\n  --ds-chart-success-bold: #216E4E;\n  --ds-chart-success-bold-hovered: #164B35;\n  --ds-chart-discovery: #8F7EE7;\n  --ds-chart-discovery-hovered: #8270DB;\n  --ds-chart-discovery-bold: #5E4DB2;\n  --ds-chart-discovery-bold-hovered: #352C63;\n  --ds-chart-information: #388BFF;\n  --ds-chart-information-hovered: #1D7AFC;\n  --ds-chart-information-bold: #0055CC;\n  --ds-chart-information-bold-hovered: #09326C;\n  --ds-surface: #FFFFFF;\n  --ds-surface-hovered: #F1F2F4;\n  --ds-surface-pressed: #DCDFE4;\n  --ds-surface-overlay: #FFFFFF;\n  --ds-surface-overlay-hovered: #F1F2F4;\n  --ds-surface-overlay-pressed: #DCDFE4;\n  --ds-surface-raised: #FFFFFF;\n  --ds-surface-raised-hovered: #F1F2F4;\n  --ds-surface-raised-pressed: #DCDFE4;\n  --ds-surface-sunken: #F7F8F9;\n  --ds-shadow-overflow: 0px 0px 8px #091E4229, 0px 0px 1px #091E421F;\n  --ds-shadow-overflow-perimeter: #091e421f;\n  --ds-shadow-overflow-spread: #091e4229;\n  --ds-shadow-overlay: 0px 8px 12px #091E4226, 0px 0px 1px #091E424F;\n  --ds-shadow-raised: 0px 1px 1px #091E4240, 0px 0px 1px #091E424F;\n  --ds-opacity-disabled: 0.4;\n  --ds-opacity-loading: 0.2;\n  --ds-UNSAFE-transparent: transparent;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-dark.js
var require_atlassian_dark = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-color-mode="light"][data-theme~="light:dark"],\nhtml[data-color-mode="dark"][data-theme~="dark:dark"] {\n  --ds-text: #C7D1DB;\n  --ds-text-accent-red: #FF9C8F;\n  --ds-text-accent-red-bolder: #FFD2CC;\n  --ds-text-accent-orange: #FEC57B;\n  --ds-text-accent-orange-bolder: #FFE2BD;\n  --ds-text-accent-yellow: #F5CD47;\n  --ds-text-accent-yellow-bolder: #F8E6A0;\n  --ds-text-accent-green: #7EE2B8;\n  --ds-text-accent-green-bolder: #BAF3DB;\n  --ds-text-accent-teal: #8BDBE5;\n  --ds-text-accent-teal-bolder: #C1F0F5;\n  --ds-text-accent-blue: #85B8FF;\n  --ds-text-accent-blue-bolder: #CCE0FF;\n  --ds-text-accent-purple: #B8ACF6;\n  --ds-text-accent-purple-bolder: #DFD8FD;\n  --ds-text-accent-magenta: #F797D2;\n  --ds-text-accent-magenta-bolder: #FDD0EC;\n  --ds-text-accent-gray: #9FADBC;\n  --ds-text-accent-gray-bolder: #DEE4EA;\n  --ds-text-disabled: #BFDBF847;\n  --ds-text-inverse: #161A1D;\n  --ds-text-selected: #579DFF;\n  --ds-text-brand: #579DFF;\n  --ds-text-danger: #FF9C8F;\n  --ds-text-warning: #F5CD47;\n  --ds-text-warning-inverse: #161A1D;\n  --ds-text-success: #7EE2B8;\n  --ds-text-discovery: #B8ACF6;\n  --ds-text-information: #85B8FF;\n  --ds-text-subtlest: #8696A7;\n  --ds-text-subtle: #9FADBC;\n  --ds-link: #579DFF;\n  --ds-link-pressed: #85B8FF;\n  --ds-icon: #9FADBC;\n  --ds-icon-accent-red: #EF5C48;\n  --ds-icon-accent-orange: #F18D13;\n  --ds-icon-accent-yellow: #CF9F02;\n  --ds-icon-accent-green: #2ABB7F;\n  --ds-icon-accent-teal: #37B4C3;\n  --ds-icon-accent-blue: #388BFF;\n  --ds-icon-accent-purple: #8F7EE7;\n  --ds-icon-accent-magenta: #DA62AC;\n  --ds-icon-accent-gray: #738496;\n  --ds-icon-disabled: #BFDBF847;\n  --ds-icon-inverse: #161A1D;\n  --ds-icon-selected: #579DFF;\n  --ds-icon-brand: #579DFF;\n  --ds-icon-danger: #EF5C48;\n  --ds-icon-warning: #CF9F02;\n  --ds-icon-warning-inverse: #161A1D;\n  --ds-icon-success: #2ABB7F;\n  --ds-icon-discovery: #8F7EE7;\n  --ds-icon-information: #388BFF;\n  --ds-icon-subtle: #8696A7;\n  --ds-border: #A6C5E229;\n  --ds-border-accent-red: #EF5C48;\n  --ds-border-accent-orange: #F18D13;\n  --ds-border-accent-yellow: #CF9F02;\n  --ds-border-accent-green: #2ABB7F;\n  --ds-border-accent-teal: #37B4C3;\n  --ds-border-accent-blue: #388BFF;\n  --ds-border-accent-purple: #8F7EE7;\n  --ds-border-accent-magenta: #DA62AC;\n  --ds-border-accent-gray: #738496;\n  --ds-border-disabled: #A1BDD914;\n  --ds-border-focused: #85B8FF;\n  --ds-border-input: #A6C5E229;\n  --ds-border-inverse: #161A1D;\n  --ds-border-selected: #579DFF;\n  --ds-border-brand: #579DFF;\n  --ds-border-danger: #EF5C48;\n  --ds-border-warning: #CF9F02;\n  --ds-border-success: #2ABB7F;\n  --ds-border-discovery: #8F7EE7;\n  --ds-border-information: #388BFF;\n  --ds-border-bold: #738496;\n  --ds-background-accent-red-subtlest: #391813;\n  --ds-background-accent-red-subtler: #601E16;\n  --ds-background-accent-red-subtle: #AE2A19;\n  --ds-background-accent-red-bolder: #F87462;\n  --ds-background-accent-orange-subtlest: #43290F;\n  --ds-background-accent-orange-subtler: #5F3811;\n  --ds-background-accent-orange-subtle: #974F0C;\n  --ds-background-accent-orange-bolder: #FAA53D;\n  --ds-background-accent-yellow-subtlest: #3D2E00;\n  --ds-background-accent-yellow-subtler: #533F04;\n  --ds-background-accent-yellow-subtle: #7F5F01;\n  --ds-background-accent-yellow-bolder: #E2B203;\n  --ds-background-accent-green-subtlest: #133527;\n  --ds-background-accent-green-subtler: #164B35;\n  --ds-background-accent-green-subtle: #216E4E;\n  --ds-background-accent-green-bolder: #4BCE97;\n  --ds-background-accent-teal-subtlest: #153337;\n  --ds-background-accent-teal-subtler: #1D474C;\n  --ds-background-accent-teal-subtle: #206B74;\n  --ds-background-accent-teal-bolder: #60C6D2;\n  --ds-background-accent-blue-subtlest: #082145;\n  --ds-background-accent-blue-subtler: #09326C;\n  --ds-background-accent-blue-subtle: #0055CC;\n  --ds-background-accent-blue-bolder: #579DFF;\n  --ds-background-accent-purple-subtlest: #231C3F;\n  --ds-background-accent-purple-subtler: #352C63;\n  --ds-background-accent-purple-subtle: #5E4DB2;\n  --ds-background-accent-purple-bolder: #9F8FEF;\n  --ds-background-accent-magenta-subtlest: #341829;\n  --ds-background-accent-magenta-subtler: #50253F;\n  --ds-background-accent-magenta-subtle: #943D73;\n  --ds-background-accent-magenta-bolder: #E774BB;\n  --ds-background-accent-gray-subtlest: #2C333A;\n  --ds-background-accent-gray-subtler: #454F59;\n  --ds-background-accent-gray-subtle: #596773;\n  --ds-background-accent-gray-bolder: #8696A7;\n  --ds-background-disabled: #BCD6F00A;\n  --ds-background-input: #1D2125;\n  --ds-background-input-hovered: #22272B;\n  --ds-background-input-pressed: #1D2125;\n  --ds-background-inverse-subtle: #FFFFFF29;\n  --ds-background-inverse-subtle-hovered: #FFFFFF3D;\n  --ds-background-inverse-subtle-pressed: #FFFFFF52;\n  --ds-background-neutral: #A1BDD914;\n  --ds-background-neutral-hovered: #A6C5E229;\n  --ds-background-neutral-pressed: #BFDBF847;\n  --ds-background-neutral-subtle: #00000000;\n  --ds-background-neutral-subtle-hovered: #A1BDD914;\n  --ds-background-neutral-subtle-pressed: #A6C5E229;\n  --ds-background-neutral-bold: #9FADBC;\n  --ds-background-neutral-bold-hovered: #B6C2CF;\n  --ds-background-neutral-bold-pressed: #C7D1DB;\n  --ds-background-selected: #082145;\n  --ds-background-selected-hovered: #09326C;\n  --ds-background-selected-pressed: #0055CC;\n  --ds-background-selected-bold: #579DFF;\n  --ds-background-selected-bold-hovered: #85B8FF;\n  --ds-background-selected-bold-pressed: #CCE0FF;\n  --ds-background-brand-bold: #579DFF;\n  --ds-background-brand-bold-hovered: #85B8FF;\n  --ds-background-brand-bold-pressed: #CCE0FF;\n  --ds-background-danger: #391813;\n  --ds-background-danger-hovered: #601E16;\n  --ds-background-danger-pressed: #AE2A19;\n  --ds-background-danger-bold: #F87462;\n  --ds-background-danger-bold-hovered: #FF9C8F;\n  --ds-background-danger-bold-pressed: #FFD2CC;\n  --ds-background-warning: #3D2E00;\n  --ds-background-warning-hovered: #533F04;\n  --ds-background-warning-pressed: #7F5F01;\n  --ds-background-warning-bold: #E2B203;\n  --ds-background-warning-bold-hovered: #F5CD47;\n  --ds-background-warning-bold-pressed: #F8E6A0;\n  --ds-background-success: #133527;\n  --ds-background-success-hovered: #164B35;\n  --ds-background-success-pressed: #216E4E;\n  --ds-background-success-bold: #4BCE97;\n  --ds-background-success-bold-hovered: #7EE2B8;\n  --ds-background-success-bold-pressed: #BAF3DB;\n  --ds-background-discovery: #231C3F;\n  --ds-background-discovery-hovered: #352C63;\n  --ds-background-discovery-pressed: #5E4DB2;\n  --ds-background-discovery-bold: #9F8FEF;\n  --ds-background-discovery-bold-hovered: #B8ACF6;\n  --ds-background-discovery-bold-pressed: #DFD8FD;\n  --ds-background-information: #082145;\n  --ds-background-information-hovered: #09326C;\n  --ds-background-information-pressed: #0055CC;\n  --ds-background-information-bold: #579DFF;\n  --ds-background-information-bold-hovered: #85B8FF;\n  --ds-background-information-bold-pressed: #CCE0FF;\n  --ds-blanket: #03040442;\n  --ds-blanket-selected: #1D7AFC14;\n  --ds-blanket-danger: #E3493514;\n  --ds-interaction-hovered: #ffffff33;\n  --ds-interaction-pressed: #ffffff5c;\n  --ds-skeleton: #A1BDD914;\n  --ds-skeleton-subtle: #BCD6F00A;\n  --ds-chart-categorical-1: #1D9AAA;\n  --ds-chart-categorical-1-hovered: #37B4C3;\n  --ds-chart-categorical-2: #B8ACF6;\n  --ds-chart-categorical-2-hovered: #DFD8FD;\n  --ds-chart-categorical-3: #D97008;\n  --ds-chart-categorical-3-hovered: #F18D13;\n  --ds-chart-categorical-4: #F797D2;\n  --ds-chart-categorical-4-hovered: #FDD0EC;\n  --ds-chart-categorical-5: #CCE0FF;\n  --ds-chart-categorical-5-hovered: #E9F2FF;\n  --ds-chart-categorical-6: #8270DB;\n  --ds-chart-categorical-6-hovered: #8F7EE7;\n  --ds-chart-categorical-7: #FDD0EC;\n  --ds-chart-categorical-7-hovered: #FFECF8;\n  --ds-chart-categorical-8: #FEC57B;\n  --ds-chart-categorical-8-hovered: #FFE2BD;\n  --ds-chart-neutral: #738496;\n  --ds-chart-neutral-hovered: #8696A7;\n  --ds-chart-red-bold: #E34935;\n  --ds-chart-red-bold-hovered: #EF5C48;\n  --ds-chart-red-bolder: #EF5C48;\n  --ds-chart-red-bolder-hovered: #F87462;\n  --ds-chart-red-boldest: #FF9C8F;\n  --ds-chart-red-boldest-hovered: #FFD2CC;\n  --ds-chart-orange-bold: #F18D13;\n  --ds-chart-orange-bold-hovered: #FAA53D;\n  --ds-chart-orange-bolder: #FAA53D;\n  --ds-chart-orange-bolder-hovered: #FEC57B;\n  --ds-chart-orange-boldest: #FEC57B;\n  --ds-chart-orange-boldest-hovered: #FFE2BD;\n  --ds-chart-yellow-bold: #CF9F02;\n  --ds-chart-yellow-bold-hovered: #E2B203;\n  --ds-chart-yellow-bolder: #E2B203;\n  --ds-chart-yellow-bolder-hovered: #F5CD47;\n  --ds-chart-yellow-boldest: #F5CD47;\n  --ds-chart-yellow-boldest-hovered: #F8E6A0;\n  --ds-chart-green-bold: #2ABB7F;\n  --ds-chart-green-bold-hovered: #4BCE97;\n  --ds-chart-green-bolder: #4BCE97;\n  --ds-chart-green-bolder-hovered: #7EE2B8;\n  --ds-chart-green-boldest: #7EE2B8;\n  --ds-chart-green-boldest-hovered: #BAF3DB;\n  --ds-chart-teal-bold: #37B4C3;\n  --ds-chart-teal-bold-hovered: #60C6D2;\n  --ds-chart-teal-bolder: #60C6D2;\n  --ds-chart-teal-bolder-hovered: #8BDBE5;\n  --ds-chart-teal-boldest: #8BDBE5;\n  --ds-chart-teal-boldest-hovered: #C1F0F5;\n  --ds-chart-blue-bold: #1D7AFC;\n  --ds-chart-blue-bold-hovered: #388BFF;\n  --ds-chart-blue-bolder: #388BFF;\n  --ds-chart-blue-bolder-hovered: #579DFF;\n  --ds-chart-blue-boldest: #85B8FF;\n  --ds-chart-blue-boldest-hovered: #CCE0FF;\n  --ds-chart-purple-bold: #8270DB;\n  --ds-chart-purple-bold-hovered: #8F7EE7;\n  --ds-chart-purple-bolder: #8F7EE7;\n  --ds-chart-purple-bolder-hovered: #9F8FEF;\n  --ds-chart-purple-boldest: #B8ACF6;\n  --ds-chart-purple-boldest-hovered: #DFD8FD;\n  --ds-chart-magenta-bold: #CD519D;\n  --ds-chart-magenta-bold-hovered: #DA62AC;\n  --ds-chart-magenta-bolder: #DA62AC;\n  --ds-chart-magenta-bolder-hovered: #E774BB;\n  --ds-chart-magenta-boldest: #F797D2;\n  --ds-chart-magenta-boldest-hovered: #FDD0EC;\n  --ds-chart-gray-bold: #738496;\n  --ds-chart-gray-bold-hovered: #8696A7;\n  --ds-chart-gray-bolder: #8696A7;\n  --ds-chart-gray-bolder-hovered: #9FADBC;\n  --ds-chart-gray-boldest: #9FADBC;\n  --ds-chart-gray-boldest-hovered: #B6C2CF;\n  --ds-chart-brand: #388BFF;\n  --ds-chart-brand-hovered: #579DFF;\n  --ds-chart-danger: #E34935;\n  --ds-chart-danger-hovered: #EF5C48;\n  --ds-chart-danger-bold: #FF9C8F;\n  --ds-chart-danger-bold-hovered: #FFD2CC;\n  --ds-chart-warning: #CF9F02;\n  --ds-chart-warning-hovered: #E2B203;\n  --ds-chart-warning-bold: #F5CD47;\n  --ds-chart-warning-bold-hovered: #F8E6A0;\n  --ds-chart-success: #2ABB7F;\n  --ds-chart-success-hovered: #4BCE97;\n  --ds-chart-success-bold: #7EE2B8;\n  --ds-chart-success-bold-hovered: #BAF3DB;\n  --ds-chart-discovery: #8270DB;\n  --ds-chart-discovery-hovered: #8F7EE7;\n  --ds-chart-discovery-bold: #B8ACF6;\n  --ds-chart-discovery-bold-hovered: #DFD8FD;\n  --ds-chart-information: #1D7AFC;\n  --ds-chart-information-hovered: #388BFF;\n  --ds-chart-information-bold: #85B8FF;\n  --ds-chart-information-bold-hovered: #CCE0FF;\n  --ds-surface: #161A1D;\n  --ds-surface-hovered: #1D2125;\n  --ds-surface-pressed: #22272B;\n  --ds-surface-overlay: #22272B;\n  --ds-surface-overlay-hovered: #2C333A;\n  --ds-surface-overlay-pressed: #454F59;\n  --ds-surface-raised: #1D2125;\n  --ds-surface-raised-hovered: #22272B;\n  --ds-surface-raised-pressed: #2C333A;\n  --ds-surface-sunken: #101214;\n  --ds-shadow-overflow: 0px 0px 12px #0304048F, 0px 0px 1px #03040480;\n  --ds-shadow-overflow-perimeter: #03040480;\n  --ds-shadow-overflow-spread: #0304048f;\n  --ds-shadow-overlay: inset 0px 0px 0px 1px #BCD6F00A, 0px 8px 12px #0304045C, 0px 0px 1px #03040480;\n  --ds-shadow-raised: inset 0px 0px 0px 1px #00000000, 0px 1px 1px #03040480, 0px 0px 1px #03040480;\n  --ds-opacity-disabled: 0.4;\n  --ds-opacity-loading: 0.2;\n  --ds-UNSAFE-transparent: transparent;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-legacy-light.js
var require_atlassian_legacy_light = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-legacy-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-color-mode="light"][data-theme~="light:legacy-light"],\nhtml[data-color-mode="dark"][data-theme~="dark:legacy-light"] {\n  --ds-text: #172B4D;\n  --ds-text-accent-red: #DE350B;\n  --ds-text-accent-red-bolder: #BF2600;\n  --ds-text-accent-orange: #F18D13;\n  --ds-text-accent-orange-bolder: #B65C02;\n  --ds-text-accent-yellow: #FF991F;\n  --ds-text-accent-yellow-bolder: #FF8B00;\n  --ds-text-accent-green: #00875A;\n  --ds-text-accent-green-bolder: #006644;\n  --ds-text-accent-teal: #00A3BF;\n  --ds-text-accent-teal-bolder: #008DA6;\n  --ds-text-accent-blue: #0052CC;\n  --ds-text-accent-blue-bolder: #0747A6;\n  --ds-text-accent-purple: #5243AA;\n  --ds-text-accent-purple-bolder: #403294;\n  --ds-text-accent-magenta: #E774BB;\n  --ds-text-accent-magenta-bolder: #DA62AC;\n  --ds-text-accent-gray: #505F79;\n  --ds-text-accent-gray-bolder: #172B4D;\n  --ds-text-disabled: #A5ADBA;\n  --ds-text-inverse: #FFFFFF;\n  --ds-text-selected: #0052CC;\n  --ds-text-brand: #0065FF;\n  --ds-text-danger: #DE350B;\n  --ds-text-warning: #974F0C;\n  --ds-text-warning-inverse: #172B4D;\n  --ds-text-success: #006644;\n  --ds-text-discovery: #403294;\n  --ds-text-information: #0052CC;\n  --ds-text-subtlest: #7A869A;\n  --ds-text-subtle: #42526E;\n  --ds-link: #0052CC;\n  --ds-link-pressed: #0747A6;\n  --ds-icon: #505F79;\n  --ds-icon-accent-red: #FF5630;\n  --ds-icon-accent-orange: #D94008;\n  --ds-icon-accent-yellow: #FFAB00;\n  --ds-icon-accent-green: #36B37E;\n  --ds-icon-accent-teal: #00B8D9;\n  --ds-icon-accent-blue: #0065FF;\n  --ds-icon-accent-purple: #6554C0;\n  --ds-icon-accent-magenta: #CD519D;\n  --ds-icon-accent-gray: #5E6C84;\n  --ds-icon-disabled: #8993A4;\n  --ds-icon-inverse: #FFFFFF;\n  --ds-icon-selected: #0052CC;\n  --ds-icon-brand: #0065FF;\n  --ds-icon-danger: #DE350B;\n  --ds-icon-warning: #FFC400;\n  --ds-icon-warning-inverse: #253858;\n  --ds-icon-success: #00875A;\n  --ds-icon-discovery: #8777D9;\n  --ds-icon-information: #0747A6;\n  --ds-icon-subtle: #6B778C;\n  --ds-border: #091e4221;\n  --ds-border-accent-red: #FF5630;\n  --ds-border-accent-orange: #D94008;\n  --ds-border-accent-yellow: #FFAB00;\n  --ds-border-accent-green: #36B37E;\n  --ds-border-accent-teal: #00B8D9;\n  --ds-border-accent-blue: #0065FF;\n  --ds-border-accent-purple: #6554C0;\n  --ds-border-accent-magenta: #CD519D;\n  --ds-border-accent-gray: #5E6C84;\n  --ds-border-disabled: #FAFBFC;\n  --ds-border-focused: #4C9AFF;\n  --ds-border-input: #FAFBFC;\n  --ds-border-inverse: #FFFFFF;\n  --ds-border-selected: #0052CC;\n  --ds-border-brand: #0052CC;\n  --ds-border-danger: #FF5630;\n  --ds-border-warning: #FFC400;\n  --ds-border-success: #00875A;\n  --ds-border-discovery: #998DD9;\n  --ds-border-information: #0065FF;\n  --ds-border-bold: #344563;\n  --ds-background-accent-red-subtlest: #FF8F73;\n  --ds-background-accent-red-subtler: #FF7452;\n  --ds-background-accent-red-subtle: #DE350B;\n  --ds-background-accent-red-bolder: #DE350B;\n  --ds-background-accent-orange-subtlest: #F18D13;\n  --ds-background-accent-orange-subtler: #B65C02;\n  --ds-background-accent-orange-subtle: #5F3811;\n  --ds-background-accent-orange-bolder: #43290F;\n  --ds-background-accent-yellow-subtlest: #FFE380;\n  --ds-background-accent-yellow-subtler: #FFC400;\n  --ds-background-accent-yellow-subtle: #FF991F;\n  --ds-background-accent-yellow-bolder: #FF991F;\n  --ds-background-accent-green-subtlest: #79F2C0;\n  --ds-background-accent-green-subtler: #57D9A3;\n  --ds-background-accent-green-subtle: #00875A;\n  --ds-background-accent-green-bolder: #00875A;\n  --ds-background-accent-teal-subtlest: #79E2F2;\n  --ds-background-accent-teal-subtler: #00C7E6;\n  --ds-background-accent-teal-subtle: #00A3BF;\n  --ds-background-accent-teal-bolder: #00A3BF;\n  --ds-background-accent-blue-subtlest: #4C9AFF;\n  --ds-background-accent-blue-subtler: #2684FF;\n  --ds-background-accent-blue-subtle: #0052CC;\n  --ds-background-accent-blue-bolder: #0052CC;\n  --ds-background-accent-purple-subtlest: #998DD9;\n  --ds-background-accent-purple-subtler: #8777D9;\n  --ds-background-accent-purple-subtle: #5243AA;\n  --ds-background-accent-purple-bolder: #5243AA;\n  --ds-background-accent-magenta-subtlest: #E774BB;\n  --ds-background-accent-magenta-subtler: #E774BB;\n  --ds-background-accent-magenta-subtle: #E774BB;\n  --ds-background-accent-magenta-bolder: #E774BB;\n  --ds-background-accent-gray-subtlest: #6B778C;\n  --ds-background-accent-gray-subtler: #5E6C84;\n  --ds-background-accent-gray-subtle: #42526E;\n  --ds-background-accent-gray-bolder: #505F79;\n  --ds-background-disabled: #091e4289;\n  --ds-background-input: #FAFBFC;\n  --ds-background-input-hovered: #EBECF0;\n  --ds-background-input-pressed: #FFFFFF;\n  --ds-background-inverse-subtle: #00000029;\n  --ds-background-inverse-subtle-hovered: #0000003D;\n  --ds-background-inverse-subtle-pressed: #00000052;\n  --ds-background-neutral: #DFE1E6;\n  --ds-background-neutral-hovered: #091e4214;\n  --ds-background-neutral-pressed: #B3D4FF;\n  --ds-background-neutral-subtle: transparent;\n  --ds-background-neutral-subtle-hovered: #091e4214;\n  --ds-background-neutral-subtle-pressed: #B3D4FF;\n  --ds-background-neutral-bold: #42526E;\n  --ds-background-neutral-bold-hovered: #505F79;\n  --ds-background-neutral-bold-pressed: #344563;\n  --ds-background-selected: #DEEBFF;\n  --ds-background-selected-hovered: #B3D4FF;\n  --ds-background-selected-pressed: #4C9AFF;\n  --ds-background-selected-bold: #0052CC;\n  --ds-background-selected-bold-hovered: #2684FF;\n  --ds-background-selected-bold-pressed: #0052CC;\n  --ds-background-brand-bold: #0052CC;\n  --ds-background-brand-bold-hovered: #0065FF;\n  --ds-background-brand-bold-pressed: #0747A6;\n  --ds-background-danger: #FFEBE6;\n  --ds-background-danger-hovered: #FFBDAD;\n  --ds-background-danger-pressed: #FF8F73;\n  --ds-background-danger-bold: #DE350B;\n  --ds-background-danger-bold-hovered: #FF5630;\n  --ds-background-danger-bold-pressed: #BF2600;\n  --ds-background-warning: #FFFAE6;\n  --ds-background-warning-hovered: #FFF0B3;\n  --ds-background-warning-pressed: #FFE380;\n  --ds-background-warning-bold: #FFAB00;\n  --ds-background-warning-bold-hovered: #FFC400;\n  --ds-background-warning-bold-pressed: #FF991F;\n  --ds-background-success: #E3FCEF;\n  --ds-background-success-hovered: #ABF5D1;\n  --ds-background-success-pressed: #79F2C0;\n  --ds-background-success-bold: #00875A;\n  --ds-background-success-bold-hovered: #57D9A3;\n  --ds-background-success-bold-pressed: #00875A;\n  --ds-background-discovery: #EAE6FF;\n  --ds-background-discovery-hovered: #C0B6F2;\n  --ds-background-discovery-pressed: #998DD9;\n  --ds-background-discovery-bold: #5243AA;\n  --ds-background-discovery-bold-hovered: #8777D9;\n  --ds-background-discovery-bold-pressed: #5243AA;\n  --ds-background-information: #DEEBFF;\n  --ds-background-information-hovered: #B3D4FF;\n  --ds-background-information-pressed: #4C9AFF;\n  --ds-background-information-bold: #0052CC;\n  --ds-background-information-bold-hovered: #2684FF;\n  --ds-background-information-bold-pressed: #0052CC;\n  --ds-blanket: #091e4289;\n  --ds-blanket-selected: #388BFF14;\n  --ds-blanket-danger: #EF5C4814;\n  --ds-interaction-hovered: #00000029;\n  --ds-interaction-pressed: #00000052;\n  --ds-skeleton: #F4F5F7;\n  --ds-skeleton-subtle: #091e420a;\n  --ds-chart-categorical-1: #00B8D9;\n  --ds-chart-categorical-1-hovered: #00A3BF;\n  --ds-chart-categorical-2: #5243AA;\n  --ds-chart-categorical-2-hovered: #403294;\n  --ds-chart-categorical-3: #D94008;\n  --ds-chart-categorical-3-hovered: #B65C02;\n  --ds-chart-categorical-4: #943D73;\n  --ds-chart-categorical-4-hovered: #50253F;\n  --ds-chart-categorical-5: #0052CC;\n  --ds-chart-categorical-5-hovered: #0747A6;\n  --ds-chart-categorical-6: #5243AA;\n  --ds-chart-categorical-6-hovered: #403294;\n  --ds-chart-categorical-7: #50253F;\n  --ds-chart-categorical-7-hovered: #341829;\n  --ds-chart-categorical-8: #974F0C;\n  --ds-chart-categorical-8-hovered: #5F3811;\n  --ds-chart-neutral: #5E6C84;\n  --ds-chart-neutral-hovered: #505F79;\n  --ds-chart-red-bold: #FF5630;\n  --ds-chart-red-bold-hovered: #DE350B;\n  --ds-chart-red-bolder: #DE350B;\n  --ds-chart-red-bolder-hovered: #BF2600;\n  --ds-chart-red-boldest: #BF2600;\n  --ds-chart-red-boldest-hovered: #BF2600;\n  --ds-chart-orange-bold: #D97008;\n  --ds-chart-orange-bold-hovered: #B65C02;\n  --ds-chart-orange-bolder: #B65C02;\n  --ds-chart-orange-bolder-hovered: #974F0C;\n  --ds-chart-orange-boldest: #974F0C;\n  --ds-chart-orange-boldest-hovered: #5F3811;\n  --ds-chart-yellow-bold: #FFAB00;\n  --ds-chart-yellow-bold-hovered: #FF991F;\n  --ds-chart-yellow-bolder: #FF991F;\n  --ds-chart-yellow-bolder-hovered: #FF8B00;\n  --ds-chart-yellow-boldest: #FF8B00;\n  --ds-chart-yellow-boldest-hovered: #FF8B00;\n  --ds-chart-green-bold: #36B37E;\n  --ds-chart-green-bold-hovered: #00875A;\n  --ds-chart-green-bolder: #00875A;\n  --ds-chart-green-bolder-hovered: #006644;\n  --ds-chart-green-boldest: #006644;\n  --ds-chart-green-boldest-hovered: #006644;\n  --ds-chart-teal-bold: #00B8D9;\n  --ds-chart-teal-bold-hovered: #00A3BF;\n  --ds-chart-teal-bolder: #00A3BF;\n  --ds-chart-teal-bolder-hovered: #008DA6;\n  --ds-chart-teal-boldest: #008DA6;\n  --ds-chart-teal-boldest-hovered: #008DA6;\n  --ds-chart-blue-bold: #0065FF;\n  --ds-chart-blue-bold-hovered: #0052CC;\n  --ds-chart-blue-bolder: #0052CC;\n  --ds-chart-blue-bolder-hovered: #0747A6;\n  --ds-chart-blue-boldest: #0747A6;\n  --ds-chart-blue-boldest-hovered: #0747A6;\n  --ds-chart-purple-bold: #6554C0;\n  --ds-chart-purple-bold-hovered: #5243AA;\n  --ds-chart-purple-bolder: #5243AA;\n  --ds-chart-purple-bolder-hovered: #403294;\n  --ds-chart-purple-boldest: #403294;\n  --ds-chart-purple-boldest-hovered: #403294;\n  --ds-chart-magenta-bold: #DA62AC;\n  --ds-chart-magenta-bold-hovered: #CD519D;\n  --ds-chart-magenta-bolder: #CD519D;\n  --ds-chart-magenta-bolder-hovered: #AE4787;\n  --ds-chart-magenta-boldest: #943D73;\n  --ds-chart-magenta-boldest-hovered: #50253F;\n  --ds-chart-gray-bold: #5E6C84;\n  --ds-chart-gray-bold-hovered: #505F79;\n  --ds-chart-gray-bolder: #505F79;\n  --ds-chart-gray-bolder-hovered: #42526E;\n  --ds-chart-gray-boldest: #42526E;\n  --ds-chart-gray-boldest-hovered: #42526E;\n  --ds-chart-brand: #0065FF;\n  --ds-chart-brand-hovered: #0052CC;\n  --ds-chart-danger: #FF5630;\n  --ds-chart-danger-hovered: #DE350B;\n  --ds-chart-danger-bold: #DE350B;\n  --ds-chart-danger-bold-hovered: #BF2600;\n  --ds-chart-warning: #FFAB00;\n  --ds-chart-warning-hovered: #FF991F;\n  --ds-chart-warning-bold: #FF991F;\n  --ds-chart-warning-bold-hovered: #FF8B00;\n  --ds-chart-success: #36B37E;\n  --ds-chart-success-hovered: #00875A;\n  --ds-chart-success-bold: #00875A;\n  --ds-chart-success-bold-hovered: #006644;\n  --ds-chart-discovery: #6554C0;\n  --ds-chart-discovery-hovered: #5243AA;\n  --ds-chart-discovery-bold: #5243AA;\n  --ds-chart-discovery-bold-hovered: #403294;\n  --ds-chart-information: #0065FF;\n  --ds-chart-information-hovered: #0052CC;\n  --ds-chart-information-bold: #0052CC;\n  --ds-chart-information-bold-hovered: #0747A6;\n  --ds-surface: #FFFFFF;\n  --ds-surface-hovered: #FAFBFC;\n  --ds-surface-pressed: #F4F5F7;\n  --ds-surface-overlay: #FFFFFF;\n  --ds-surface-overlay-hovered: #FAFBFC;\n  --ds-surface-overlay-pressed: #F4F5F7;\n  --ds-surface-raised: #FFFFFF;\n  --ds-surface-raised-hovered: #FAFBFC;\n  --ds-surface-raised-pressed: #F4F5F7;\n  --ds-surface-sunken: #F4F5F7;\n  --ds-shadow-overflow: 0px 0px 8px #091e4229, 0px 0px 1px #091e421F;\n  --ds-shadow-overflow-perimeter: #091e421f;\n  --ds-shadow-overflow-spread: #091e4229;\n  --ds-shadow-overlay: 0px 8px 12px #091e4226, 0px 0px 1px #091e424F;\n  --ds-shadow-raised: 0px 1px 1px #091e4240, 0px 0px 1px #091e424F;\n  --ds-opacity-disabled: 0.4;\n  --ds-opacity-loading: 0.2;\n  --ds-UNSAFE-transparent: transparent;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-legacy-dark.js
var require_atlassian_legacy_dark = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-legacy-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-color-mode="light"][data-theme~="light:legacy-dark"],\nhtml[data-color-mode="dark"][data-theme~="dark:legacy-dark"] {\n  --ds-text: #E6EDFA;\n  --ds-text-accent-red: #FF5630;\n  --ds-text-accent-red-bolder: #FF7452;\n  --ds-text-accent-orange: #FEC57B;\n  --ds-text-accent-orange-bolder: #F18D13;\n  --ds-text-accent-yellow: #FFAB00;\n  --ds-text-accent-yellow-bolder: #FFC400;\n  --ds-text-accent-green: #36B37E;\n  --ds-text-accent-green-bolder: #57D9A3;\n  --ds-text-accent-teal: #00B8D9;\n  --ds-text-accent-teal-bolder: #00C7E6;\n  --ds-text-accent-blue: #0065FF;\n  --ds-text-accent-blue-bolder: #2684FF;\n  --ds-text-accent-purple: #6554C0;\n  --ds-text-accent-purple-bolder: #8777D9;\n  --ds-text-accent-magenta: #F797D2;\n  --ds-text-accent-magenta-bolder: #FDD0EC;\n  --ds-text-accent-gray: #8C9CB8;\n  --ds-text-accent-gray-bolder: #ABBBD6;\n  --ds-text-disabled: #1B2638;\n  --ds-text-inverse: #0D1424;\n  --ds-text-selected: #0052CC;\n  --ds-text-brand: #0052CC;\n  --ds-text-danger: #FF5630;\n  --ds-text-warning: #172B4D;\n  --ds-text-warning-inverse: #0D1424;\n  --ds-text-success: #36B37E;\n  --ds-text-discovery: #6554C0;\n  --ds-text-information: #0065FF;\n  --ds-text-subtlest: #7988A3;\n  --ds-text-subtle: #9FB0CC;\n  --ds-link: #0052CC;\n  --ds-link-pressed: #0065FF;\n  --ds-icon: #DCE5F5;\n  --ds-icon-accent-red: #BF2600;\n  --ds-icon-accent-orange: #F18D13;\n  --ds-icon-accent-yellow: #FF8B00;\n  --ds-icon-accent-green: #006644;\n  --ds-icon-accent-teal: #008DA6;\n  --ds-icon-accent-blue: #0747A6;\n  --ds-icon-accent-purple: #403294;\n  --ds-icon-accent-magenta: #DA62AC;\n  --ds-icon-accent-gray: #B8C7E0;\n  --ds-icon-disabled: #0d14245b;\n  --ds-icon-inverse: #202B3D;\n  --ds-icon-selected: #4C9AFF;\n  --ds-icon-brand: #4C9AFF;\n  --ds-icon-danger: #FF8F73;\n  --ds-icon-warning: #FFF0B3;\n  --ds-icon-warning-inverse: #202B3D;\n  --ds-icon-success: #57D9A3;\n  --ds-icon-discovery: #998DD9;\n  --ds-icon-information: #B3D4FF;\n  --ds-icon-subtle: #202B3D;\n  --ds-border: #202B3D;\n  --ds-border-accent-red: #BF2600;\n  --ds-border-accent-orange: #F18D13;\n  --ds-border-accent-yellow: #FF8B00;\n  --ds-border-accent-green: #006644;\n  --ds-border-accent-teal: #008DA6;\n  --ds-border-accent-blue: #0747A6;\n  --ds-border-accent-purple: #403294;\n  --ds-border-accent-magenta: #DA62AC;\n  --ds-border-accent-gray: #B8C7E0;\n  --ds-border-disabled: #0E1624;\n  --ds-border-focused: #B3D4FF;\n  --ds-border-input: #202B3D;\n  --ds-border-inverse: #0D1424;\n  --ds-border-selected: #0052CC;\n  --ds-border-brand: #0052CC;\n  --ds-border-danger: #DE350B;\n  --ds-border-warning: #FF8B00;\n  --ds-border-success: #006644;\n  --ds-border-discovery: #403294;\n  --ds-border-information: #0747A6;\n  --ds-border-bold: #7988A3;\n  --ds-background-accent-red-subtlest: #BF2600;\n  --ds-background-accent-red-subtler: #DE350B;\n  --ds-background-accent-red-subtle: #FF5630;\n  --ds-background-accent-red-bolder: #FF8F73;\n  --ds-background-accent-orange-subtlest: #43290F;\n  --ds-background-accent-orange-subtler: #5F3811;\n  --ds-background-accent-orange-subtle: #974F0C;\n  --ds-background-accent-orange-bolder: #F18D13;\n  --ds-background-accent-yellow-subtlest: #FF8B00;\n  --ds-background-accent-yellow-subtler: #FF991F;\n  --ds-background-accent-yellow-subtle: #FFAB00;\n  --ds-background-accent-yellow-bolder: #FFE380;\n  --ds-background-accent-green-subtlest: #006644;\n  --ds-background-accent-green-subtler: #00875A;\n  --ds-background-accent-green-subtle: #36B37E;\n  --ds-background-accent-green-bolder: #79F2C0;\n  --ds-background-accent-teal-subtlest: #008DA6;\n  --ds-background-accent-teal-subtler: #00A3BF;\n  --ds-background-accent-teal-subtle: #00B8D9;\n  --ds-background-accent-teal-bolder: #79E2F2;\n  --ds-background-accent-blue-subtlest: #0747A6;\n  --ds-background-accent-blue-subtler: #0052CC;\n  --ds-background-accent-blue-subtle: #0065FF;\n  --ds-background-accent-blue-bolder: #4C9AFF;\n  --ds-background-accent-purple-subtlest: #403294;\n  --ds-background-accent-purple-subtler: #5243AA;\n  --ds-background-accent-purple-subtle: #6554C0;\n  --ds-background-accent-purple-bolder: #998DD9;\n  --ds-background-accent-magenta-subtlest: #341829;\n  --ds-background-accent-magenta-subtler: #50253F;\n  --ds-background-accent-magenta-subtle: #943D73;\n  --ds-background-accent-magenta-bolder: #E774BB;\n  --ds-background-accent-gray-subtlest: #8C9CB8;\n  --ds-background-accent-gray-subtler: #9FB0CC;\n  --ds-background-accent-gray-subtle: #ABBBD6;\n  --ds-background-accent-gray-bolder: #CED9EB;\n  --ds-background-disabled: #3B475C;\n  --ds-background-input: #0E1624;\n  --ds-background-input-hovered: #1B2638;\n  --ds-background-input-pressed: #0D1424;\n  --ds-background-inverse-subtle: #FFFFFF29;\n  --ds-background-inverse-subtle-hovered: #FFFFFF3D;\n  --ds-background-inverse-subtle-pressed: #FFFFFF52;\n  --ds-background-neutral: #3B475C;\n  --ds-background-neutral-hovered: #313D52;\n  --ds-background-neutral-pressed: #B3D4FF;\n  --ds-background-neutral-subtle: transparent;\n  --ds-background-neutral-subtle-hovered: #313D52;\n  --ds-background-neutral-subtle-pressed: #B3D4FF;\n  --ds-background-neutral-bold: #CED9EB;\n  --ds-background-neutral-bold-hovered: #B8C7E0;\n  --ds-background-neutral-bold-pressed: #DCE5F5;\n  --ds-background-selected: #DEEBFF;\n  --ds-background-selected-hovered: #B3D4FF;\n  --ds-background-selected-pressed: #4C9AFF;\n  --ds-background-selected-bold: #0052CC;\n  --ds-background-selected-bold-hovered: #0065FF;\n  --ds-background-selected-bold-pressed: #0747A6;\n  --ds-background-brand-bold: #0052CC;\n  --ds-background-brand-bold-hovered: #0065FF;\n  --ds-background-brand-bold-pressed: #0747A6;\n  --ds-background-danger: #FFEBE6;\n  --ds-background-danger-hovered: #FFBDAD;\n  --ds-background-danger-pressed: #FF8F73;\n  --ds-background-danger-bold: #FF5630;\n  --ds-background-danger-bold-hovered: #FF7452;\n  --ds-background-danger-bold-pressed: #DE350B;\n  --ds-background-warning: #FFFAE6;\n  --ds-background-warning-hovered: #FFF0B3;\n  --ds-background-warning-pressed: #FFE380;\n  --ds-background-warning-bold: #FFAB00;\n  --ds-background-warning-bold-hovered: #FFC400;\n  --ds-background-warning-bold-pressed: #FF991F;\n  --ds-background-success: #E3FCEF;\n  --ds-background-success-hovered: #ABF5D1;\n  --ds-background-success-pressed: #79F2C0;\n  --ds-background-success-bold: #00875A;\n  --ds-background-success-bold-hovered: #36B37E;\n  --ds-background-success-bold-pressed: #006644;\n  --ds-background-discovery: #EAE6FF;\n  --ds-background-discovery-hovered: #C0B6F2;\n  --ds-background-discovery-pressed: #998DD9;\n  --ds-background-discovery-bold: #5243AA;\n  --ds-background-discovery-bold-hovered: #6554C0;\n  --ds-background-discovery-bold-pressed: #403294;\n  --ds-background-information: #DEEBFF;\n  --ds-background-information-hovered: #B3D4FF;\n  --ds-background-information-pressed: #4C9AFF;\n  --ds-background-information-bold: #0052CC;\n  --ds-background-information-bold-hovered: #0065FF;\n  --ds-background-information-bold-pressed: #0747A6;\n  --ds-blanket: #0d1424a0;\n  --ds-blanket-selected: #1D7AFC14;\n  --ds-blanket-danger: #E3493514;\n  --ds-interaction-hovered: #ffffff33;\n  --ds-interaction-pressed: #ffffff5c;\n  --ds-skeleton: #0d1424f2;\n  --ds-skeleton-subtle: #0d1424f7;\n  --ds-chart-categorical-1: #00B8D9;\n  --ds-chart-categorical-1-hovered: #00C7E6;\n  --ds-chart-categorical-2: #6554C0;\n  --ds-chart-categorical-2-hovered: #8777D9;\n  --ds-chart-categorical-3: #D97008;\n  --ds-chart-categorical-3-hovered: #F18D13;\n  --ds-chart-categorical-4: #F797D2;\n  --ds-chart-categorical-4-hovered: #FDD0EC;\n  --ds-chart-categorical-5: #0065FF;\n  --ds-chart-categorical-5-hovered: #2684FF;\n  --ds-chart-categorical-6: #6554C0;\n  --ds-chart-categorical-6-hovered: #8777D9;\n  --ds-chart-categorical-7: #FDD0EC;\n  --ds-chart-categorical-7-hovered: #FFECF8;\n  --ds-chart-categorical-8: #FEC57B;\n  --ds-chart-categorical-8-hovered: #FFE2BD;\n  --ds-chart-neutral: #B8C7E0;\n  --ds-chart-neutral-hovered: #ABBBD6;\n  --ds-chart-red-bold: #BF2600;\n  --ds-chart-red-bold-hovered: #DE350B;\n  --ds-chart-red-bolder: #DE350B;\n  --ds-chart-red-bolder-hovered: #FF5630;\n  --ds-chart-red-boldest: #FF5630;\n  --ds-chart-red-boldest-hovered: #FF7452;\n  --ds-chart-orange-bold: #F18D13;\n  --ds-chart-orange-bold-hovered: #FAA53D;\n  --ds-chart-orange-bolder: #FAA53D;\n  --ds-chart-orange-bolder-hovered: #FEC57B;\n  --ds-chart-orange-boldest: #FEC57B;\n  --ds-chart-orange-boldest-hovered: #FFE2BD;\n  --ds-chart-yellow-bold: #FF8B00;\n  --ds-chart-yellow-bold-hovered: #FF991F;\n  --ds-chart-yellow-bolder: #FF991F;\n  --ds-chart-yellow-bolder-hovered: #FFAB00;\n  --ds-chart-yellow-boldest: #FFAB00;\n  --ds-chart-yellow-boldest-hovered: #FFC400;\n  --ds-chart-green-bold: #006644;\n  --ds-chart-green-bold-hovered: #00875A;\n  --ds-chart-green-bolder: #00875A;\n  --ds-chart-green-bolder-hovered: #36B37E;\n  --ds-chart-green-boldest: #36B37E;\n  --ds-chart-green-boldest-hovered: #57D9A3;\n  --ds-chart-teal-bold: #008DA6;\n  --ds-chart-teal-bold-hovered: #00A3BF;\n  --ds-chart-teal-bolder: #00A3BF;\n  --ds-chart-teal-bolder-hovered: #00B8D9;\n  --ds-chart-teal-boldest: #00B8D9;\n  --ds-chart-teal-boldest-hovered: #00C7E6;\n  --ds-chart-blue-bold: #0747A6;\n  --ds-chart-blue-bold-hovered: #0052CC;\n  --ds-chart-blue-bolder: #0052CC;\n  --ds-chart-blue-bolder-hovered: #0065FF;\n  --ds-chart-blue-boldest: #0065FF;\n  --ds-chart-blue-boldest-hovered: #2684FF;\n  --ds-chart-purple-bold: #403294;\n  --ds-chart-purple-bold-hovered: #5243AA;\n  --ds-chart-purple-bolder: #5243AA;\n  --ds-chart-purple-bolder-hovered: #6554C0;\n  --ds-chart-purple-boldest: #6554C0;\n  --ds-chart-purple-boldest-hovered: #8777D9;\n  --ds-chart-magenta-bold: #CD519D;\n  --ds-chart-magenta-bold-hovered: #DA62AC;\n  --ds-chart-magenta-bolder: #DA62AC;\n  --ds-chart-magenta-bolder-hovered: #E774BB;\n  --ds-chart-magenta-boldest: #F797D2;\n  --ds-chart-magenta-boldest-hovered: #FDD0EC;\n  --ds-chart-gray-bold: #B8C7E0;\n  --ds-chart-gray-bold-hovered: #CED9EB;\n  --ds-chart-gray-bolder: #CED9EB;\n  --ds-chart-gray-bolder-hovered: #DCE5F5;\n  --ds-chart-gray-boldest: #DCE5F5;\n  --ds-chart-gray-boldest-hovered: #E6EDFA;\n  --ds-chart-brand: #0052CC;\n  --ds-chart-brand-hovered: #0065FF;\n  --ds-chart-danger: #DE350B;\n  --ds-chart-danger-hovered: #FF5630;\n  --ds-chart-danger-bold: #FF5630;\n  --ds-chart-danger-bold-hovered: #FF7452;\n  --ds-chart-warning: #FF991F;\n  --ds-chart-warning-hovered: #FFAB00;\n  --ds-chart-warning-bold: #FFAB00;\n  --ds-chart-warning-bold-hovered: #FFC400;\n  --ds-chart-success: #00875A;\n  --ds-chart-success-hovered: #36B37E;\n  --ds-chart-success-bold: #36B37E;\n  --ds-chart-success-bold-hovered: #57D9A3;\n  --ds-chart-discovery: #5243AA;\n  --ds-chart-discovery-hovered: #6554C0;\n  --ds-chart-discovery-bold: #6554C0;\n  --ds-chart-discovery-bold-hovered: #8777D9;\n  --ds-chart-information: #0052CC;\n  --ds-chart-information-hovered: #0065FF;\n  --ds-chart-information-bold: #0065FF;\n  --ds-chart-information-bold-hovered: #2684FF;\n  --ds-surface: #1B2638;\n  --ds-surface-hovered: #202B3D;\n  --ds-surface-pressed: #283447;\n  --ds-surface-overlay: #7988A3;\n  --ds-surface-overlay-hovered: #8C9CB8;\n  --ds-surface-overlay-pressed: #9FB0CC;\n  --ds-surface-raised: #455166;\n  --ds-surface-raised-hovered: #56637A;\n  --ds-surface-raised-pressed: #67758F;\n  --ds-surface-sunken: #67758F;\n  --ds-shadow-overflow: 0px 0px 12px #0304048F, 0px 0px 1px #03040480;\n  --ds-shadow-overflow-perimeter: #03040480;\n  --ds-shadow-overflow-spread: #0304048f;\n  --ds-shadow-overlay: inset 0px 0px 0px 1px #0d14240A, 0px 8px 12px #0d14245C, 0px 0px 1px #0d142480;\n  --ds-shadow-raised: inset 0px 0px 0px 1px #00000000, 0px 1px 1px #0d142480, 0px 0px 1px #0d142480;\n  --ds-opacity-disabled: 0.4;\n  --ds-opacity-loading: 0.2;\n  --ds-UNSAFE-transparent: transparent;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-spacing.js
var require_atlassian_spacing = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-spacing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-theme~="spacing:spacing"] {\n  --ds-space-0: 0;\n  --ds-space-025: 0.125rem;\n  --ds-space-050: 0.25rem;\n  --ds-space-075: 0.375rem;\n  --ds-space-100: 0.5rem;\n  --ds-space-150: 0.75rem;\n  --ds-space-200: 1rem;\n  --ds-space-250: 1.25rem;\n  --ds-space-300: 1.5rem;\n  --ds-space-400: 2rem;\n  --ds-space-500: 2.5rem;\n  --ds-space-600: 3rem;\n  --ds-space-800: 4rem;\n  --ds-space-1000: 5rem;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-typography.js
var require_atlassian_typography = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-typography.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-theme~="typography:typography"] {\n  --ds-font-family-monospace: "SFMono-Medium", "SF Mono", "Segoe UI Mono", "Roboto Mono", "Ubuntu Mono", Menlo, Consolas, Courier, monospace;\n  --ds-font-family-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;\n  --ds-font-size-050: 11px;\n  --ds-font-size-075: 12px;\n  --ds-font-size-100: 14px;\n  --ds-font-size-200: 16px;\n  --ds-font-size-300: 20px;\n  --ds-font-size-400: 24px;\n  --ds-font-size-500: 29px;\n  --ds-font-size-600: 35px;\n  --ds-font-weight-bold: 700;\n  --ds-font-weight-medium: 500;\n  --ds-font-weight-regular: 400;\n  --ds-font-weight-semibold: 600;\n  --ds-font-lineHeight-100: 16px;\n  --ds-font-lineHeight-200: 20px;\n  --ds-font-lineHeight-300: 24px;\n  --ds-font-lineHeight-400: 28px;\n  --ds-font-lineHeight-500: 32px;\n  --ds-font-lineHeight-600: 40px;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-shape.js
var require_atlassian_shape = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-shape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-theme~="shape:shape"] {\n  --ds-radius-050: 0.125rem;\n  --ds-radius-100: 0.25rem;\n  --ds-radius-200: 0.5rem;\n  --ds-radius-300: 0.75rem;\n  --ds-radius-400: 1rem;\n  --ds-radius-round: 50%;\n  --ds-width-0: 0;\n  --ds-width-050: 0.0625rem;\n  --ds-width-100: 0.125rem;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-dark-iteration.js
var require_atlassian_dark_iteration = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/themes/atlassian-dark-iteration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '\nhtml[data-color-mode="light"][data-theme~="light:dark"],\nhtml[data-color-mode="dark"][data-theme~="dark:dark"] {\n  --ds-text: #B6C2CF;\n  --ds-text-inverse: #1D2125;\n  --ds-text-selected: #6EAAFF;\n  --ds-text-warning-inverse: #1D2125;\n  --ds-text-subtlest: #8C9BAB;\n  --ds-link: #6EAAFF;\n  --ds-link-pressed: #A8CCFF;\n  --ds-icon-inverse: #1D2125;\n  --ds-icon-selected: #6EAAFF;\n  --ds-icon-warning-inverse: #1D2125;\n  --ds-icon-subtle: #8C9BAB;\n  --ds-background-accent-red-subtlest: #4F1C16;\n  --ds-background-accent-orange-subtlest: #513010;\n  --ds-background-accent-yellow-subtlest: #473602;\n  --ds-background-accent-green-subtlest: #143E2C;\n  --ds-background-accent-teal-subtlest: #193E42;\n  --ds-background-accent-blue-subtlest: #092957;\n  --ds-background-accent-purple-subtlest: #2B2451;\n  --ds-background-accent-magenta-subtlest: #421F34;\n  --ds-background-accent-gray-bolder: #8C9BAB;\n  --ds-background-input: #22272B;\n  --ds-background-input-hovered: #282E33;\n  --ds-background-input-pressed: #22272B;\n  --ds-background-selected: #092957;\n  --ds-background-selected-pressed: #073A83;\n  --ds-background-danger: #4F1C16;\n  --ds-background-danger-pressed: #872518;\n  --ds-background-warning: #473602;\n  --ds-background-warning-pressed: #6B5103;\n  --ds-background-success: #143E2C;\n  --ds-background-success-pressed: #1B5A40;\n  --ds-background-discovery: #2B2451;\n  --ds-background-discovery-pressed: #4A3D8A;\n  --ds-background-information: #092957;\n  --ds-background-information-pressed: #073A83;\n  --ds-blanket: #10121499;\n  --ds-chart-neutral-hovered: #8C9BAB;\n  --ds-chart-gray-bold-hovered: #8C9BAB;\n  --ds-chart-gray-bolder: #8C9BAB;\n  --ds-surface: #1D2125;\n  --ds-surface-hovered: #22272B;\n  --ds-surface-pressed: #282E33;\n  --ds-surface-overlay: #282E33;\n  --ds-surface-overlay-pressed: #38414A;\n  --ds-surface-raised: #22272B;\n  --ds-surface-raised-hovered: #282E33;\n  --ds-surface-sunken: #161A1D;\n  --ds-shadow-overlay: inset 0px 0px 0px 1px #BCD6F01F, 0px 8px 12px #0304045C, 0px 0px 1px #03040480;\n}\n';
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/artifacts/theme-import-map.js
var require_theme_import_map = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/artifacts/theme-import-map.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || (0, _typeof2.default)(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var themeImportsMap = {
      "light": function light() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_light());
        });
      },
      "dark": function dark() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_dark());
        });
      },
      "legacy-light": function legacyLight() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_legacy_light());
        });
      },
      "legacy-dark": function legacyDark() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_legacy_dark());
        });
      },
      "spacing": function spacing() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_spacing());
        });
      },
      "typography": function typography() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_typography());
        });
      },
      "shape": function shape() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_shape());
        });
      },
      "dark-iteration": function darkIteration() {
        return Promise.resolve().then(function() {
          return _interopRequireWildcard(require_atlassian_dark_iteration());
        });
      }
    };
    var _default = themeImportsMap;
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/utils/theme-loading.js
var require_theme_loading = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/utils/theme-loading.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loadThemeCss = exports.loadAndAppendThemeCss = void 0;
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _themeImportMap = _interopRequireDefault(require_theme_import_map());
    var _constants = require_constants();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      };
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", { value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return { value: record.arg, done: context.done };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; ) {
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              }
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      function doneResult() {
        return { value: void 0, done: true };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return { __await: arg };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          }
      }, stop: function stop() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      }, dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      }, complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      }, finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      }, catch: function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = { iterator: values(iterable), resultName, nextLoc }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      } }, exports2;
    }
    var loadAndAppendThemeCss = /* @__PURE__ */ function() {
      var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(themeId) {
        var themeCss, style;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!document.head.querySelector("style[".concat(_constants.THEME_DATA_ATTRIBUTE, '="').concat(themeId, '"]'))) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                _context.next = 4;
                return loadThemeCss(themeId);
              case 4:
                themeCss = _context.sent;
                style = document.createElement("style");
                style.textContent = themeCss;
                style.dataset.theme = themeId;
                document.head.appendChild(style);
              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function loadAndAppendThemeCss2(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    exports.loadAndAppendThemeCss = loadAndAppendThemeCss;
    var loadThemeCss = /* @__PURE__ */ function() {
      var _ref2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(themeId) {
        var _yield$themeImportMap, themeCss;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _themeImportMap.default[themeId]();
              case 2:
                _yield$themeImportMap = _context2.sent;
                themeCss = _yield$themeImportMap.default;
                return _context2.abrupt("return", themeCss);
              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function loadThemeCss2(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    exports.loadThemeCss = loadThemeCss;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/theme-config.js
var require_theme_config = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/theme-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.themeOverrideConfig = exports.themeIds = exports.themeColorModes = exports.default = void 0;
    var themeColorModes = ["light", "dark", "auto"];
    exports.themeColorModes = themeColorModes;
    var themeIds = ["light", "dark", "legacy-light", "legacy-dark", "spacing", "typography", "shape"];
    exports.themeIds = themeIds;
    var themeConfig = {
      "atlassian-light": {
        id: "light",
        displayName: "Light Theme",
        palette: "defaultPalette",
        attributes: {
          type: "color",
          mode: "light"
        }
      },
      "atlassian-dark": {
        id: "dark",
        displayName: "Dark Theme",
        palette: "defaultPalette",
        attributes: {
          type: "color",
          mode: "dark"
        }
      },
      "atlassian-legacy-light": {
        id: "legacy-light",
        displayName: "Light Theme (legacy)",
        palette: "legacyPalette",
        attributes: {
          type: "color",
          mode: "light"
        }
      },
      "atlassian-legacy-dark": {
        id: "legacy-dark",
        displayName: "Dark Theme (legacy)",
        palette: "legacyPalette",
        attributes: {
          type: "color",
          mode: "dark"
        }
      },
      "atlassian-spacing": {
        id: "spacing",
        displayName: "Atlassian Spacing",
        palette: "spacingScale",
        attributes: {
          type: "spacing"
        }
      },
      "atlassian-typography": {
        id: "typography",
        displayName: "Atlassian Typography",
        palette: "typographyPalette",
        attributes: {
          type: "typography"
        }
      },
      "atlassian-shape": {
        id: "shape",
        displayName: "Atlassian Shape",
        palette: "shapePalette",
        attributes: {
          type: "shape"
        }
      }
    };
    var themeOverrideConfig = {
      "atlassian-dark-iteration": {
        id: "dark-iteration",
        displayName: "Dark Theme Iteration",
        palette: "defaultPalette",
        overrideTheme: "dark",
        attributes: {
          type: "color",
          mode: "dark"
        }
      }
    };
    exports.themeOverrideConfig = themeOverrideConfig;
    var _default = themeConfig;
    exports.default = _default;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/utils/theme-state-transformer.js
var require_theme_state_transformer = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/utils/theme-state-transformer.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.themeStringToObject = exports.themeObjectToString = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _themeConfig = require_theme_config();
    var themeKinds = ["light", "dark", "spacing", "typography"];
    var isThemeKind = function isThemeKind2(themeKind) {
      return themeKinds.find(function(kind) {
        return kind === themeKind;
      }) !== void 0;
    };
    var isThemeIds = function isThemeIds2(themeId) {
      return _themeConfig.themeIds.find(function(id) {
        return id === themeId;
      }) !== void 0;
    };
    var isColorMode = function isColorMode2(modeId) {
      return ["light", "dark", "auto"].includes(modeId);
    };
    var themeStringToObject = function themeStringToObject2(themeState) {
      return themeState.split(" ").map(function(theme) {
        return theme.split(":");
      }).reduce(function(themeObject, _ref) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2), kind = _ref2[0], id = _ref2[1];
        if (kind === "colorMode" && isColorMode(id)) {
          themeObject[kind] = id;
        }
        if (isThemeKind(kind) && isThemeIds(id)) {
          themeObject[kind] = id;
        }
        return themeObject;
      }, {});
    };
    exports.themeStringToObject = themeStringToObject;
    var themeObjectToString = function themeObjectToString2(themeState) {
      return Object.entries(themeState).reduce(function(themeString, _ref3) {
        var _ref4 = (0, _slicedToArray2.default)(_ref3, 2), kind = _ref4[0], id = _ref4[1];
        return (kind === "colorMode" || isThemeKind(kind)) && (isThemeIds(id) || isColorMode(id)) ? themeString + "".concat(themeString ? " " : "") + "".concat(kind, ":").concat(id) : themeString;
      }, "");
    };
    exports.themeObjectToString = themeObjectToString;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/set-global-theme.js
var require_set_global_theme = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/set-global-theme.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getThemeStyles = exports.getThemeHtmlAttrs = exports.getSSRAutoScript = exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _bindEventListener = require_dist2();
    var _noop = _interopRequireDefault(require_noop());
    var _platformFeatureFlags = require_cjs2();
    var _constants = require_constants();
    var _themeLoading = require_theme_loading();
    var _themeStateTransformer = require_theme_state_transformer();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      };
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", { value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return { value: record.arg, done: context.done };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; ) {
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              }
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      function doneResult() {
        return { value: void 0, done: true };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return { __await: arg };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          }
      }, stop: function stop() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      }, dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      }, complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      }, finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      }, catch: function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = { iterator: values(iterable), resultName, nextLoc }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      } }, exports2;
    }
    var defaultColorMode = "light";
    var isMatchMediaAvailable = typeof window !== "undefined" && "matchMedia" in window;
    var darkModeMediaQuery = "(prefers-color-scheme: dark)";
    var darkModeMql = isMatchMediaAvailable && window.matchMedia(darkModeMediaQuery);
    var unbindThemeChangeListener = _noop.default;
    var themeStateDefaults = {
      colorMode: "auto",
      dark: "dark",
      light: "light",
      spacing: void 0,
      typography: void 0
    };
    var checkNativeListener = function checkNativeListener2(e) {
      var element = document.documentElement;
      element.setAttribute(_constants.COLOR_MODE_ATTRIBUTE, e.matches ? "dark" : "light");
    };
    var setGlobalTheme = /* @__PURE__ */ function() {
      var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
        var _ref2, _ref2$colorMode, colorMode, _ref2$dark, dark, _ref2$light, light, _ref2$spacing, spacing, _ref2$typography, typography, themePreferences, themeAttributes, _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref2$colorMode = _ref2.colorMode, colorMode = _ref2$colorMode === void 0 ? themeStateDefaults["colorMode"] : _ref2$colorMode, _ref2$dark = _ref2.dark, dark = _ref2$dark === void 0 ? themeStateDefaults["dark"] : _ref2$dark, _ref2$light = _ref2.light, light = _ref2$light === void 0 ? themeStateDefaults["light"] : _ref2$light, _ref2$spacing = _ref2.spacing, spacing = _ref2$spacing === void 0 ? themeStateDefaults["spacing"] : _ref2$spacing, _ref2$typography = _ref2.typography, typography = _ref2$typography === void 0 ? themeStateDefaults["typography"] : _ref2$typography;
                themePreferences = /* @__PURE__ */ new Set([dark, light, spacing, typography]);
                if (
                  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
                  (0, _platformFeatureFlags.getBooleanFF)("design-system-team.dark-theme-iteration_dk1ln") && themePreferences.has("dark")
                ) {
                  themePreferences.add("dark-iteration");
                }
                _context2.next = 5;
                return Promise.all((0, _toConsumableArray2.default)(themePreferences).filter(function(themeId) {
                  return themeId !== void 0;
                }).map(/* @__PURE__ */ function() {
                  var _ref3 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(themeId) {
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return (0, _themeLoading.loadAndAppendThemeCss)(themeId);
                          case 2:
                            return _context.abrupt("return", _context.sent);
                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  return function(_x) {
                    return _ref3.apply(this, arguments);
                  };
                }()));
              case 5:
                if (colorMode === "auto" && darkModeMql) {
                  colorMode = darkModeMql.matches ? "dark" : "light";
                  unbindThemeChangeListener = (0, _bindEventListener.bind)(darkModeMql, {
                    type: "change",
                    listener: checkNativeListener
                  });
                } else {
                  unbindThemeChangeListener();
                }
                themeAttributes = getThemeHtmlAttrs({
                  colorMode,
                  dark,
                  light,
                  spacing,
                  typography
                });
                Object.entries(themeAttributes).forEach(function(_ref4) {
                  var _ref5 = (0, _slicedToArray2.default)(_ref4, 2), key = _ref5[0], value = _ref5[1];
                  document.documentElement.setAttribute(key, value);
                });
                return _context2.abrupt("return", unbindThemeChangeListener);
              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function setGlobalTheme2() {
        return _ref.apply(this, arguments);
      };
    }();
    var getThemeStyles = /* @__PURE__ */ function() {
      var _ref6 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4() {
        var _ref7, _ref7$colorMode, colorMode, _ref7$dark, dark, _ref7$light, light, _ref7$spacing, spacing, _ref7$typography, typography, themePreferences, results, _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref7 = _args4.length > 0 && _args4[0] !== void 0 ? _args4[0] : {}, _ref7$colorMode = _ref7.colorMode, colorMode = _ref7$colorMode === void 0 ? themeStateDefaults["colorMode"] : _ref7$colorMode, _ref7$dark = _ref7.dark, dark = _ref7$dark === void 0 ? themeStateDefaults["dark"] : _ref7$dark, _ref7$light = _ref7.light, light = _ref7$light === void 0 ? themeStateDefaults["light"] : _ref7$light, _ref7$spacing = _ref7.spacing, spacing = _ref7$spacing === void 0 ? themeStateDefaults["spacing"] : _ref7$spacing, _ref7$typography = _ref7.typography, typography = _ref7$typography === void 0 ? themeStateDefaults["typography"] : _ref7$typography;
                themePreferences = colorMode === "auto" ? [light, dark] : [colorMode];
                [spacing, typography].forEach(function(themeId) {
                  if (themeId) {
                    themePreferences.push(themeId);
                  }
                });
                if (
                  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
                  (0, _platformFeatureFlags.getBooleanFF)("design-system-team.dark-theme-iteration_dk1ln") && themePreferences.includes("dark")
                ) {
                  themePreferences.push("dark-iteration");
                }
                _context4.next = 6;
                return Promise.all(themePreferences.map(/* @__PURE__ */ function() {
                  var _ref8 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(themeId) {
                    var css;
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.prev = 0;
                            _context3.next = 3;
                            return (0, _themeLoading.loadThemeCss)(themeId);
                          case 3:
                            css = _context3.sent;
                            return _context3.abrupt("return", {
                              id: themeId,
                              attrs: {
                                "data-theme": themeId
                              },
                              css
                            });
                          case 7:
                            _context3.prev = 7;
                            _context3.t0 = _context3["catch"](0);
                            return _context3.abrupt("return", void 0);
                          case 10:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, null, [[0, 7]]);
                  }));
                  return function(_x2) {
                    return _ref8.apply(this, arguments);
                  };
                }()));
              case 6:
                results = _context4.sent;
                return _context4.abrupt("return", results.filter(function(theme) {
                  return theme !== void 0;
                }));
              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return function getThemeStyles2() {
        return _ref6.apply(this, arguments);
      };
    }();
    exports.getThemeStyles = getThemeStyles;
    var getThemeHtmlAttrs = function getThemeHtmlAttrs2() {
      var _ref10;
      var _ref9 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref9$colorMode = _ref9.colorMode, colorMode = _ref9$colorMode === void 0 ? themeStateDefaults["colorMode"] : _ref9$colorMode, _ref9$dark = _ref9.dark, dark = _ref9$dark === void 0 ? themeStateDefaults["dark"] : _ref9$dark, _ref9$light = _ref9.light, light = _ref9$light === void 0 ? themeStateDefaults["light"] : _ref9$light, _ref9$spacing = _ref9.spacing, spacing = _ref9$spacing === void 0 ? themeStateDefaults["spacing"] : _ref9$spacing, _ref9$typography = _ref9.typography, typography = _ref9$typography === void 0 ? themeStateDefaults["typography"] : _ref9$typography;
      var themePreferences = {
        dark,
        light,
        spacing,
        typography
      };
      var themeAttribute = (0, _themeStateTransformer.themeObjectToString)(themePreferences);
      return _ref10 = {}, (0, _defineProperty2.default)(_ref10, _constants.THEME_DATA_ATTRIBUTE, themeAttribute), (0, _defineProperty2.default)(_ref10, _constants.COLOR_MODE_ATTRIBUTE, colorMode === "auto" ? defaultColorMode : colorMode), _ref10;
    };
    exports.getThemeHtmlAttrs = getThemeHtmlAttrs;
    var getSSRAutoScript = function getSSRAutoScript2(colorMode) {
      return colorMode === "auto" ? "(\n  () => {\n    try {\n      const mql = window.matchMedia('".concat(darkModeMediaQuery, "');\n      const colorMode = mql.matches ? 'dark' : 'light';\n      document.documentElement.setAttribute('").concat(_constants.COLOR_MODE_ATTRIBUTE, "', colorMode);\n    } catch (e) {}\n  }\n)()") : void 0;
    };
    exports.getSSRAutoScript = getSSRAutoScript;
    var _default = setGlobalTheme;
    exports.default = _default;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = require_object_assign();
    var n = "function" === typeof Symbol && Symbol.for;
    var p = n ? Symbol.for("react.element") : 60103;
    var q = n ? Symbol.for("react.portal") : 60106;
    var r = n ? Symbol.for("react.fragment") : 60107;
    var t = n ? Symbol.for("react.strict_mode") : 60108;
    var u = n ? Symbol.for("react.profiler") : 60114;
    var v = n ? Symbol.for("react.provider") : 60109;
    var w = n ? Symbol.for("react.context") : 60110;
    var x = n ? Symbol.for("react.forward_ref") : 60112;
    var y = n ? Symbol.for("react.suspense") : 60113;
    var z = n ? Symbol.for("react.memo") : 60115;
    var A = n ? Symbol.for("react.lazy") : 60116;
    var B = "function" === typeof Symbol && Symbol.iterator;
    function C(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var D = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var E = {};
    function F(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = E;
      this.updater = c || D;
    }
    F.prototype.isReactComponent = {};
    F.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error(C(85));
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    F.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function G() {
    }
    G.prototype = F.prototype;
    function H(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = E;
      this.updater = c || D;
    }
    var I = H.prototype = new G();
    I.constructor = H;
    l(I, F.prototype);
    I.isPureReactComponent = true;
    var J = { current: null };
    var K = Object.prototype.hasOwnProperty;
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, c) {
      var e, d = {}, g = null, k = null;
      if (null != b)
        for (e in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b)
          K.call(b, e) && !L.hasOwnProperty(e) && (d[e] = b[e]);
      var f = arguments.length - 2;
      if (1 === f)
        d.children = c;
      else if (1 < f) {
        for (var h = Array(f), m = 0; m < f; m++)
          h[m] = arguments[m + 2];
        d.children = h;
      }
      if (a && a.defaultProps)
        for (e in f = a.defaultProps, f)
          void 0 === d[e] && (d[e] = f[e]);
      return { $$typeof: p, type: a, key: g, ref: k, props: d, _owner: J.current };
    }
    function N(a, b) {
      return { $$typeof: p, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === p;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + ("" + a).replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    var Q = [];
    function R(a, b, c, e) {
      if (Q.length) {
        var d = Q.pop();
        d.result = a;
        d.keyPrefix = b;
        d.func = c;
        d.context = e;
        d.count = 0;
        return d;
      }
      return { result: a, keyPrefix: b, func: c, context: e, count: 0 };
    }
    function S(a) {
      a.result = null;
      a.keyPrefix = null;
      a.func = null;
      a.context = null;
      a.count = 0;
      10 > Q.length && Q.push(a);
    }
    function T(a, b, c, e) {
      var d = typeof a;
      if ("undefined" === d || "boolean" === d)
        a = null;
      var g = false;
      if (null === a)
        g = true;
      else
        switch (d) {
          case "string":
          case "number":
            g = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case p:
              case q:
                g = true;
            }
        }
      if (g)
        return c(e, a, "" === b ? "." + U(a, 0) : b), 1;
      g = 0;
      b = "" === b ? "." : b + ":";
      if (Array.isArray(a))
        for (var k = 0; k < a.length; k++) {
          d = a[k];
          var f = b + U(d, k);
          g += T(d, f, c, e);
        }
      else if (null === a || "object" !== typeof a ? f = null : (f = B && a[B] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f)
        for (a = f.call(a), k = 0; !(d = a.next()).done; )
          d = d.value, f = b + U(d, k++), g += T(d, f, c, e);
      else if ("object" === d)
        throw c = "" + a, Error(C(31, "[object Object]" === c ? "object with keys {" + Object.keys(a).join(", ") + "}" : c, ""));
      return g;
    }
    function V(a, b, c) {
      return null == a ? 0 : T(a, "", b, c);
    }
    function U(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
    }
    function W(a, b) {
      a.func.call(a.context, b, a.count++);
    }
    function aa(a, b, c) {
      var e = a.result, d = a.keyPrefix;
      a = a.func.call(a.context, b, a.count++);
      Array.isArray(a) ? X(a, e, c, function(a2) {
        return a2;
      }) : null != a && (O(a) && (a = N(a, d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(P, "$&/") + "/") + c)), e.push(a));
    }
    function X(a, b, c, e, d) {
      var g = "";
      null != c && (g = ("" + c).replace(P, "$&/") + "/");
      b = R(b, g, e, d);
      V(a, aa, b);
      S(b);
    }
    var Y = { current: null };
    function Z() {
      var a = Y.current;
      if (null === a)
        throw Error(C(321));
      return a;
    }
    var ba = { ReactCurrentDispatcher: Y, ReactCurrentBatchConfig: { suspense: null }, ReactCurrentOwner: J, IsSomeRendererActing: { current: false }, assign: l };
    exports.Children = { map: function(a, b, c) {
      if (null == a)
        return a;
      var e = [];
      X(a, e, null, b, c);
      return e;
    }, forEach: function(a, b, c) {
      if (null == a)
        return a;
      b = R(null, null, b, c);
      V(a, W, b);
      S(b);
    }, count: function(a) {
      return V(a, function() {
        return null;
      }, null);
    }, toArray: function(a) {
      var b = [];
      X(a, b, null, function(a2) {
        return a2;
      });
      return b;
    }, only: function(a) {
      if (!O(a))
        throw Error(C(143));
      return a;
    } };
    exports.Component = F;
    exports.Fragment = r;
    exports.Profiler = u;
    exports.PureComponent = H;
    exports.StrictMode = t;
    exports.Suspense = y;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ba;
    exports.cloneElement = function(a, b, c) {
      if (null === a || void 0 === a)
        throw Error(C(267, a));
      var e = l({}, a.props), d = a.key, g = a.ref, k = a._owner;
      if (null != b) {
        void 0 !== b.ref && (g = b.ref, k = J.current);
        void 0 !== b.key && (d = "" + b.key);
        if (a.type && a.type.defaultProps)
          var f = a.type.defaultProps;
        for (h in b)
          K.call(b, h) && !L.hasOwnProperty(h) && (e[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
      }
      var h = arguments.length - 2;
      if (1 === h)
        e.children = c;
      else if (1 < h) {
        f = Array(h);
        for (var m = 0; m < h; m++)
          f[m] = arguments[m + 2];
        e.children = f;
      }
      return {
        $$typeof: p,
        type: a.type,
        key: d,
        ref: g,
        props: e,
        _owner: k
      };
    };
    exports.createContext = function(a, b) {
      void 0 === b && (b = null);
      a = { $$typeof: w, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
      a.Provider = { $$typeof: v, _context: a };
      return a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: x, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: A, _ctor: a, _status: -1, _result: null };
    };
    exports.memo = function(a, b) {
      return { $$typeof: z, type: a, compare: void 0 === b ? null : b };
    };
    exports.useCallback = function(a, b) {
      return Z().useCallback(a, b);
    };
    exports.useContext = function(a, b) {
      return Z().useContext(a, b);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a, b) {
      return Z().useEffect(a, b);
    };
    exports.useImperativeHandle = function(a, b, c) {
      return Z().useImperativeHandle(a, b, c);
    };
    exports.useLayoutEffect = function(a, b) {
      return Z().useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return Z().useMemo(a, b);
    };
    exports.useReducer = function(a, b, c) {
      return Z().useReducer(a, b, c);
    };
    exports.useRef = function(a) {
      return Z().useRef(a);
    };
    exports.useState = function(a) {
      return Z().useState(a);
    };
    exports.version = "16.14.0";
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (process.env.NODE_ENV !== "production") {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (process.env.NODE_ENV !== "production") {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (process.env.NODE_ENV !== "production") {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var checkPropTypes = require_checkPropTypes();
        var ReactVersion = "16.14.0";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          suspense: null
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        function describeComponentFrame(name, source, ownerName) {
          var sourceInfo = "";
          if (source) {
            var path = source.fileName;
            var fileName = path.replace(BEFORE_SLASH_RE, "");
            {
              if (/^index\./.test(fileName)) {
                var match = path.match(BEFORE_SLASH_RE);
                if (match) {
                  var pathBeforeSlash = match[1];
                  if (pathBeforeSlash) {
                    var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                    fileName = folderName + "/" + fileName;
                  }
                }
              }
            }
            sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
          } else if (ownerName) {
            sourceInfo = " (created by " + ownerName + ")";
          }
          return "\n    in " + (name || "Unknown") + sourceInfo;
        }
        var Resolved = 1;
        function refineResolvedLazyComponent(lazyComponent) {
          return lazyComponent._status === Resolved ? lazyComponent._result : null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return "Context.Consumer";
              case REACT_PROVIDER_TYPE:
                return "Context.Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE: {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);
                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
                break;
              }
            }
          }
          return null;
        }
        var ReactDebugCurrentFrame = {};
        var currentlyValidatingElement = null;
        function setCurrentlyValidatingElement(element) {
          {
            currentlyValidatingElement = element;
          }
        }
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentlyValidatingElement) {
              var name = getComponentName(currentlyValidatingElement.type);
              var owner = currentlyValidatingElement._owner;
              stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          // Used by renderers to avoid bundling object-assign twice in UMD bundles:
          assign: _assign
        };
        {
          _assign(ReactSharedInternals, {
            // These should not be included in production.
            ReactDebugCurrentFrame,
            // Shim for React DOM 16.0.0 which still destructured (but not used) this.
            // TODO: remove in React 17.0.
            ReactComponentTreeHook: {}
          });
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args2[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args2);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args2[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args2);
          }
        }
        function printWarning(level, format, args2) {
          {
            var hasExistingStack = args2.length > 0 && typeof args2[args2.length - 1] === "string" && args2[args2.length - 1].indexOf("\n    in") === 0;
            if (!hasExistingStack) {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args2 = args2.concat([stack]);
              }
            }
            var argsWithFormat = args2.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
            try {
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args2[argIndex++];
              });
              throw new Error(message);
            } catch (x) {
            }
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = ("" + key).replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
        }
        var POOL_SIZE = 10;
        var traverseContextPool = [];
        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
          if (traverseContextPool.length) {
            var traverseContext = traverseContextPool.pop();
            traverseContext.result = mapResult;
            traverseContext.keyPrefix = keyPrefix;
            traverseContext.func = mapFunction;
            traverseContext.context = mapContext;
            traverseContext.count = 0;
            return traverseContext;
          } else {
            return {
              result: mapResult,
              keyPrefix,
              func: mapFunction,
              context: mapContext,
              count: 0
            };
          }
        }
        function releaseTraverseContext(traverseContext) {
          traverseContext.result = null;
          traverseContext.keyPrefix = null;
          traverseContext.func = null;
          traverseContext.context = null;
          traverseContext.count = 0;
          if (traverseContextPool.length < POOL_SIZE) {
            traverseContextPool.push(traverseContext);
          }
        }
        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            callback(
              traverseContext,
              children,
              // If it's the only child, treat the name as if it was wrapped in an array
              // so that it's consistent if the number of children grows.
              nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
            );
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getComponentKey(child, i);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              {
                if (iteratorFn === children.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(children);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getComponentKey(child, ii++);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            } else if (type === "object") {
              var addendum = "";
              {
                addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
              }
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + ")." + addendum);
                }
              }
            }
          }
          return subtreeCount;
        }
        function traverseAllChildren(children, callback, traverseContext) {
          if (children == null) {
            return 0;
          }
          return traverseAllChildrenImpl(children, "", callback, traverseContext);
        }
        function getComponentKey(component, index) {
          if (typeof component === "object" && component !== null && component.key != null) {
            return escape(component.key);
          }
          return index.toString(36);
        }
        function forEachSingleChild(bookKeeping, child, name) {
          var func = bookKeeping.func, context = bookKeeping.context;
          func.call(context, child, bookKeeping.count++);
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          if (children == null) {
            return children;
          }
          var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
          traverseAllChildren(children, forEachSingleChild, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
          var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
          var mappedChild = func.call(context, child, bookKeeping.count++);
          if (Array.isArray(mappedChild)) {
            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              mappedChild = cloneAndReplaceKey(
                mappedChild,
                // Keep both the (mapped) and old keys if they differ, just as
                // traverseAllChildren used to do for objects as children
                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey
              );
            }
            result.push(mappedChild);
          }
        }
        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
          var escapedPrefix = "";
          if (prefix != null) {
            escapedPrefix = escapeUserProvidedKey(prefix) + "/";
          }
          var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
          traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, func, context);
          return result;
        }
        function countChildren(children) {
          return traverseAllChildren(children, function() {
            return null;
          }, null);
        }
        function toArray(children) {
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, function(child) {
            return child;
          });
          return result;
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        function lazy(ctor) {
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _ctor: ctor,
            // React uses these fields to store the result.
            _status: -1,
            _result: null
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          return {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
        }
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          return {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement(element);
          {
            error('Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
          }
          setCurrentlyValidatingElement(null);
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var name = getComponentName(type);
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              setCurrentlyValidatingElement(element);
              checkPropTypes(propTypes, element.props, "prop", name, ReactDebugCurrentFrame.getStackAddendum);
              setCurrentlyValidatingElement(null);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            setCurrentlyValidatingElement(fragment);
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                break;
              }
            }
            if (fragment.ref !== null) {
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
            }
            setCurrentlyValidatingElement(null);
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            var testMap = /* @__PURE__ */ new Map([[frozenObject, null]]);
            var testSet = /* @__PURE__ */ new Set([frozenObject]);
            testMap.set(0, 0);
            testSet.add(0);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/get-global-theme.js
var require_get_global_theme = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/get-global-theme.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getGlobalTheme = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _constants = require_constants();
    var _themeConfig = require_theme_config();
    var _themeStateTransformer = require_theme_state_transformer();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var isThemeColorMode = function isThemeColorMode2(colorMode) {
      return _themeConfig.themeColorModes.find(function(mode) {
        return mode === colorMode;
      }) !== void 0;
    };
    var getGlobalTheme = function getGlobalTheme2() {
      if (typeof document === "undefined") {
        return {};
      }
      var element = document.documentElement;
      var colorMode = element.getAttribute(_constants.COLOR_MODE_ATTRIBUTE) || "";
      var theme = element.getAttribute(_constants.THEME_DATA_ATTRIBUTE) || "";
      return _objectSpread(_objectSpread({}, (0, _themeStateTransformer.themeStringToObject)(theme)), isThemeColorMode(colorMode) && {
        colorMode
      });
    };
    exports.getGlobalTheme = getGlobalTheme;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/theme-mutation-observer.js
var require_theme_mutation_observer = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/theme-mutation-observer.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ThemeMutationObserver = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _constants = require_constants();
    var _getGlobalTheme = require_get_global_theme();
    var ThemeMutationObserver = /* @__PURE__ */ function() {
      function ThemeMutationObserver2(callback) {
        (0, _classCallCheck2.default)(this, ThemeMutationObserver2);
        (0, _defineProperty2.default)(this, "observer", null);
        (0, _defineProperty2.default)(this, "mediaObserver", null);
        this.callback = callback;
      }
      (0, _createClass2.default)(ThemeMutationObserver2, [{
        key: "observe",
        value: function observe() {
          var _this = this;
          if (!this.observer) {
            this.observer = new MutationObserver(function() {
              _this.callback((0, _getGlobalTheme.getGlobalTheme)());
            });
          }
          this.observer.observe(document.documentElement, {
            attributeFilter: [_constants.THEME_DATA_ATTRIBUTE, _constants.COLOR_MODE_ATTRIBUTE]
          });
        }
      }, {
        key: "disconnect",
        value: function disconnect() {
          this.observer && this.observer.disconnect();
        }
      }]);
      return ThemeMutationObserver2;
    }();
    exports.ThemeMutationObserver = ThemeMutationObserver;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/use-theme-observer.js
var require_use_theme_observer = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/use-theme-observer.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useThemeObserver = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _react = require_react();
    var _getGlobalTheme = require_get_global_theme();
    var _themeMutationObserver = require_theme_mutation_observer();
    var useThemeObserver = function useThemeObserver2() {
      var _useState = (0, _react.useState)((0, _getGlobalTheme.getGlobalTheme)()), _useState2 = (0, _slicedToArray2.default)(_useState, 2), theme = _useState2[0], setTheme = _useState2[1];
      (0, _react.useEffect)(function() {
        var observer = new _themeMutationObserver.ThemeMutationObserver(function(theme2) {
          return setTheme(theme2);
        });
        observer.observe();
        return function() {
          return observer.disconnect();
        };
      }, []);
      return theme;
    };
    exports.useThemeObserver = useThemeObserver;
  }
});

// node_modules/@atlaskit/tokens/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@atlaskit/tokens/dist/cjs/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ThemeMutationObserver", {
      enumerable: true,
      get: function get() {
        return _themeMutationObserver.ThemeMutationObserver;
      }
    });
    Object.defineProperty(exports, "getGlobalTheme", {
      enumerable: true,
      get: function get() {
        return _getGlobalTheme.getGlobalTheme;
      }
    });
    Object.defineProperty(exports, "getSSRAutoScript", {
      enumerable: true,
      get: function get() {
        return _setGlobalTheme.getSSRAutoScript;
      }
    });
    Object.defineProperty(exports, "getThemeHtmlAttrs", {
      enumerable: true,
      get: function get() {
        return _setGlobalTheme.getThemeHtmlAttrs;
      }
    });
    Object.defineProperty(exports, "getThemeStyles", {
      enumerable: true,
      get: function get() {
        return _setGlobalTheme.getThemeStyles;
      }
    });
    Object.defineProperty(exports, "getTokenValue", {
      enumerable: true,
      get: function get() {
        return _getTokenValue.default;
      }
    });
    Object.defineProperty(exports, "setGlobalTheme", {
      enumerable: true,
      get: function get() {
        return _setGlobalTheme.default;
      }
    });
    Object.defineProperty(exports, "themeConfig", {
      enumerable: true,
      get: function get() {
        return _themeConfig.default;
      }
    });
    Object.defineProperty(exports, "themeObjectToString", {
      enumerable: true,
      get: function get() {
        return _themeStateTransformer.themeObjectToString;
      }
    });
    Object.defineProperty(exports, "themeStringToObject", {
      enumerable: true,
      get: function get() {
        return _themeStateTransformer.themeStringToObject;
      }
    });
    Object.defineProperty(exports, "token", {
      enumerable: true,
      get: function get() {
        return _getToken.default;
      }
    });
    Object.defineProperty(exports, "useThemeObserver", {
      enumerable: true,
      get: function get() {
        return _useThemeObserver.useThemeObserver;
      }
    });
    var _getToken = _interopRequireDefault(require_get_token());
    var _getTokenValue = _interopRequireDefault(require_get_token_value());
    var _setGlobalTheme = _interopRequireWildcard(require_set_global_theme());
    var _themeConfig = _interopRequireDefault(require_theme_config());
    var _useThemeObserver = require_use_theme_observer();
    var _themeMutationObserver = require_theme_mutation_observer();
    var _getGlobalTheme = require_get_global_theme();
    var _themeStateTransformer = require_theme_state_transformer();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uuid = exports.generateUuid = void 0;
    var generateUuid = function generateUuid2() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        return (c === "x" ? r : r & 3 | 8).toString(16);
      });
    };
    exports.generateUuid = generateUuid;
    var staticValue = false;
    var uuid = {
      setStatic: function setStatic(value) {
        staticValue = value;
      },
      generate: function generate() {
        return staticValue || generateUuid();
      }
    };
    exports.uuid = uuid;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/tableNodes.js
var require_tableNodes = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/tableNodes.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSONTableHeader = exports.toJSONTableCell = exports.tableToJSON = exports.tableRow = exports.tablePrefixSelector = exports.tableHeaderSelector = exports.tableHeader = exports.tableCellSelector = exports.tableCellContentWrapperSelector = exports.tableCellContentDomSelector = exports.tableCell = exports.tableBackgroundColorPalette = exports.tableBackgroundColorNames = exports.tableBackgroundBorderColor = exports.table = exports.getCellDomAttrs = exports.getCellAttrs = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _editorPalette = require_cjs();
    var _tokens = require_cjs3();
    var _colors = require_colors();
    var _uuid = require_uuid();
    var tablePrefixSelector = "pm-table";
    exports.tablePrefixSelector = tablePrefixSelector;
    var tableCellSelector = "".concat(tablePrefixSelector, "-cell-content-wrap");
    exports.tableCellSelector = tableCellSelector;
    var tableHeaderSelector = "".concat(tablePrefixSelector, "-header-content-wrap");
    exports.tableHeaderSelector = tableHeaderSelector;
    var tableCellContentWrapperSelector = "".concat(tablePrefixSelector, "-cell-nodeview-wrapper");
    exports.tableCellContentWrapperSelector = tableCellContentWrapperSelector;
    var tableCellContentDomSelector = "".concat(tablePrefixSelector, "-cell-nodeview-content-dom");
    exports.tableCellContentDomSelector = tableCellContentDomSelector;
    var DEFAULT_TABLE_HEADER_CELL_BACKGROUND = _colors.N20.toLocaleLowerCase();
    var getCellAttrs = function getCellAttrs2(dom) {
      var defaultValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var widthAttr = dom.getAttribute("data-colwidth");
      var width = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map(function(str) {
        return Number(str);
      }) : null;
      var colspan = Number(dom.getAttribute("colspan") || 1);
      var backgroundColor = dom.style.backgroundColor;
      var dataCellBackground = dom.getAttribute("data-cell-background");
      var dataCellBackgroundHexCode = dataCellBackground && (0, _colors.isHex)(dataCellBackground) ? dataCellBackground : void 0;
      if (backgroundColor.includes("--ds-background-neutral")) {
        backgroundColor = "";
      } else {
        if (backgroundColor && (0, _colors.isRgb)(backgroundColor)) {
          var result = (0, _colors.rgbToHex)(backgroundColor);
          if (result !== null) {
            backgroundColor = result;
          }
        }
      }
      var backgroundHexCode = dataCellBackgroundHexCode || (backgroundColor && backgroundColor !== defaultValues["background"] ? backgroundColor : null);
      return {
        colspan,
        rowspan: Number(dom.getAttribute("rowspan") || 1),
        colwidth: width && width.length === colspan ? width : null,
        background: backgroundHexCode
      };
    };
    exports.getCellAttrs = getCellAttrs;
    var getCellDomAttrs = function getCellDomAttrs2(node) {
      var attrs = {};
      var nodeType = node.type.name;
      if (node.attrs.colspan !== 1) {
        attrs.colspan = node.attrs.colspan;
      }
      if (node.attrs.rowspan !== 1) {
        attrs.rowspan = node.attrs.rowspan;
      }
      if (node.attrs.colwidth) {
        attrs["data-colwidth"] = node.attrs.colwidth.join(",");
      }
      if (node.attrs.background) {
        var background = node.attrs.background;
        var ignored = nodeType === "tableHeader" && background === tableBackgroundColorNames.get("light gray") || nodeType === "tableCell" && background === tableBackgroundColorNames.get("white") || nodeType === "tableHeader" && background.includes("--ds-background-neutral");
        if (ignored) {
          attrs.style = "";
        } else {
          var color = (0, _colors.isRgb)(background) ? (0, _colors.rgbToHex)(background) : background;
          var tokenName = (0, _editorPalette.hexToEditorBackgroundPaletteColorTokenName)(color);
          var tokenColor = tokenName ? (0, _tokens.getTokenValue)(tokenName) : color;
          attrs.style = "".concat(attrs.style || "", "background-color: ").concat(tokenColor, ";");
          if (color) {
            attrs["data-cell-background"] = color;
          }
          attrs.colorname = tableBackgroundColorPalette.get(color);
        }
      }
      if (nodeType === "tableHeader") {
        attrs.class = tableHeaderSelector;
      } else {
        attrs.class = tableCellSelector;
      }
      return attrs;
    };
    exports.getCellDomAttrs = getCellDomAttrs;
    var tableBackgroundColorPalette = /* @__PURE__ */ new Map();
    exports.tableBackgroundColorPalette = tableBackgroundColorPalette;
    var tableBackgroundBorderColor = (0, _colors.hexToRgba)(_colors.N800, 0.12) || _colors.N0;
    exports.tableBackgroundBorderColor = tableBackgroundBorderColor;
    var tableBackgroundColorNames = /* @__PURE__ */ new Map();
    exports.tableBackgroundColorNames = tableBackgroundColorNames;
    [[_colors.N0, "White"], [_colors.B50, "Light blue"], [_colors.T50, "Light teal"], [_colors.G50, "Light green"], [_colors.Y50, "Light yellow"], [_colors.R50, "Light red"], [_colors.P50, "Light purple"], [_colors.N20, "Light gray"], [_colors.B75, "Blue"], [_colors.T75, "Teal"], [_colors.G75, "Green"], [_colors.Y75, "Yellow"], [_colors.R75, "Red"], [_colors.P75, "Purple"], [_colors.N60, "Gray"], [_colors.B100, "Dark blue"], [_colors.T100, "Dark teal"], [_colors.G200, "Dark green"], [_colors.Y200, "Dark yellow"], [_colors.R100, "Dark red"], [_colors.P100, "Dark purple"]].forEach(function(_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2), colorValue = _ref2[0], colorName = _ref2[1];
      tableBackgroundColorPalette.set(colorValue.toLowerCase(), colorName);
      tableBackgroundColorNames.set(colorName.toLowerCase(), colorValue.toLowerCase());
    });
    var createTableSpec = function createTableSpec2() {
      var attrs = {
        isNumberColumnEnabled: {
          default: false
        },
        layout: {
          default: "default"
        },
        __autoSize: {
          default: false
        },
        localId: {
          default: ""
        }
      };
      var tableNodeSpec = {
        content: "tableRow+",
        attrs,
        marks: "unsupportedMark unsupportedNodeAttribute",
        tableRole: "table",
        isolating: true,
        selectable: true,
        group: "block",
        parseDOM: [{
          tag: "table",
          getAttrs: function getAttrs(node) {
            var _dom$parentElement;
            var dom = node;
            var breakoutWrapper = (_dom$parentElement = dom.parentElement) === null || _dom$parentElement === void 0 ? void 0 : _dom$parentElement.parentElement;
            return {
              isNumberColumnEnabled: dom.getAttribute("data-number-column") === "true" ? true : false,
              layout: (
                // copying from editor
                dom.getAttribute("data-layout") || // copying from renderer
                (breakoutWrapper === null || breakoutWrapper === void 0 ? void 0 : breakoutWrapper.getAttribute("data-layout")) || "default"
              ),
              __autoSize: dom.getAttribute("data-autosize") === "true" ? true : false,
              localId: dom.getAttribute("data-table-local-id") || _uuid.uuid.generate()
            };
          }
        }],
        toDOM: function toDOM(node) {
          var attrs2 = {
            "data-number-column": node.attrs.isNumberColumnEnabled,
            "data-layout": node.attrs.layout,
            "data-autosize": node.attrs.__autoSize,
            "data-table-local-id": node.attrs.localId
          };
          return ["table", attrs2, ["tbody", 0]];
        }
      };
      return tableNodeSpec;
    };
    var table = createTableSpec();
    exports.table = table;
    var shouldIncludeAttribute = function shouldIncludeAttribute2(key, value) {
      return !key.startsWith("__") && (key !== "localId" || !!value);
    };
    var tableToJSON = function tableToJSON2(node) {
      return {
        attrs: Object.keys(node.attrs).filter(function(key) {
          return shouldIncludeAttribute(key, node.attrs[key]);
        }).reduce(function(obj, key) {
          obj[key] = node.attrs[key];
          return obj;
        }, {})
      };
    };
    exports.tableToJSON = tableToJSON;
    var tableRow = {
      selectable: false,
      content: "(tableCell | tableHeader)+",
      marks: "unsupportedMark unsupportedNodeAttribute",
      tableRole: "row",
      parseDOM: [{
        tag: "tr"
      }],
      toDOM: function toDOM() {
        return ["tr", 0];
      }
    };
    exports.tableRow = tableRow;
    var cellAttrs = {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null
      },
      background: {
        default: null
      }
    };
    var tableCell = {
      selectable: false,
      content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle |  mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand | unsupportedBlock)+",
      attrs: cellAttrs,
      tableRole: "cell",
      marks: "alignment dataConsumer fragment unsupportedMark unsupportedNodeAttribute",
      isolating: true,
      parseDOM: [
        // Ignore number cell copied from renderer
        {
          tag: ".ak-renderer-table-number-column",
          ignore: true
        },
        {
          tag: "td",
          getAttrs: function getAttrs(dom) {
            return getCellAttrs(dom);
          }
        }
      ],
      toDOM: function toDOM(node) {
        return ["td", getCellDomAttrs(node), 0];
      }
    };
    exports.tableCell = tableCell;
    var toJSONTableCell = function toJSONTableCell2(node) {
      return {
        attrs: Object.keys(node.attrs).reduce(function(obj, key) {
          if (cellAttrs[key].default !== node.attrs[key]) {
            obj[key] = node.attrs[key];
          }
          return obj;
        }, {})
      };
    };
    exports.toJSONTableCell = toJSONTableCell;
    var tableHeader = {
      selectable: false,
      content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle |  mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand)+",
      attrs: cellAttrs,
      tableRole: "header_cell",
      isolating: true,
      marks: "alignment dataConsumer fragment unsupportedMark unsupportedNodeAttribute",
      parseDOM: [{
        tag: "th",
        getAttrs: function getAttrs(dom) {
          return getCellAttrs(dom, {
            background: DEFAULT_TABLE_HEADER_CELL_BACKGROUND
          });
        }
      }],
      toDOM: function toDOM(node) {
        return ["th", getCellDomAttrs(node), 0];
      }
    };
    exports.tableHeader = tableHeader;
    var toJSONTableHeader = toJSONTableCell;
    exports.toJSONTableHeader = toJSONTableHeader;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/decision-list.js
var require_decision_list = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/decision-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decisionListSelector = exports.decisionList = void 0;
    var _uuid = require_uuid();
    var name = "decisionList";
    var decisionListSelector = '[data-node-type="'.concat(name, '"]');
    exports.decisionListSelector = decisionListSelector;
    var decisionList = {
      group: "block",
      defining: true,
      content: "(decisionItem|unsupportedBlock)+",
      marks: "unsupportedMark unsupportedNodeAttribute",
      selectable: false,
      attrs: {
        localId: {
          default: ""
        }
      },
      parseDOM: [{
        tag: "ol".concat(decisionListSelector),
        // Default priority is 50. We normally don't change this but since this node type is
        // also used by ordered-list we need to make sure that we run this parser first.
        priority: 100,
        getAttrs: function getAttrs() {
          return {
            localId: _uuid.uuid.generate()
          };
        }
      }],
      toDOM: function toDOM(node) {
        var localId = node.attrs.localId;
        var attrs = {
          "data-node-type": name,
          "data-decision-list-local-id": localId || "local-decision-list",
          style: "list-style: none; padding-left: 0"
        };
        return ["ol", attrs, 0];
      }
    };
    exports.decisionList = decisionList;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/decision-item.js
var require_decision_item = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/decision-item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decisionItem = void 0;
    var _uuid = require_uuid();
    var decisionItem = {
      content: "inline*",
      defining: true,
      marks: "_",
      attrs: {
        localId: {
          default: ""
        },
        state: {
          default: "DECIDED"
        }
      },
      parseDOM: [{
        tag: "li[data-decision-local-id]",
        // Default priority is 50. We normally don't change this but since this node type is
        // also used by list-item we need to make sure that we run this parser first.
        priority: 100,
        getAttrs: function getAttrs(dom) {
          return {
            localId: _uuid.uuid.generate(),
            state: dom.getAttribute("data-decision-state")
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, localId = _node$attrs.localId, state = _node$attrs.state;
        var attrs = {
          "data-decision-local-id": localId || "local-decision",
          "data-decision-state": state
        };
        return ["li", attrs, 0];
      }
    };
    exports.decisionItem = decisionItem;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/task-list.js
var require_task_list = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/task-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.taskListSelector = exports.taskList = void 0;
    var _uuid = require_uuid();
    var name = "actionList";
    var taskListSelector = '[data-node-type="'.concat(name, '"]');
    exports.taskListSelector = taskListSelector;
    var taskList = {
      group: "block",
      defining: true,
      selectable: false,
      content: "(taskItem|unsupportedBlock)+ (taskItem|taskList|unsupportedBlock)*",
      marks: "unsupportedMark unsupportedNodeAttribute",
      attrs: {
        localId: {
          default: ""
        }
      },
      parseDOM: [{
        tag: "div".concat(taskListSelector),
        // Default priority is 50. We normally don't change this but since this node type is
        // also used by ordered-list we need to make sure that we run this parser first.
        priority: 100,
        getAttrs: function getAttrs() {
          return {
            localId: _uuid.uuid.generate()
          };
        }
      }],
      toDOM: function toDOM(node) {
        var localId = node.attrs.localId;
        var attrs = {
          "data-node-type": name,
          "data-task-list-local-id": localId || "local-task-list",
          style: "list-style: none; padding-left: 0"
        };
        return ["div", attrs, 0];
      }
    };
    exports.taskList = taskList;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/task-item.js
var require_task_item = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/task-item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.taskItem = void 0;
    var _uuid = require_uuid();
    var taskItem = {
      content: "inline*",
      defining: true,
      selectable: false,
      marks: "_",
      attrs: {
        localId: {
          default: ""
        },
        state: {
          default: "TODO"
        }
      },
      parseDOM: [{
        tag: "div[data-task-local-id]",
        // Default priority is 50. We normally don't change this but since this node type is
        // also used by list-item we need to make sure that we run this parser first.
        priority: 100,
        getAttrs: function getAttrs(dom) {
          return {
            localId: _uuid.uuid.generate(),
            state: dom.getAttribute("data-task-state") || "TODO"
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, localId = _node$attrs.localId, state = _node$attrs.state;
        var attrs = {
          "data-task-local-id": localId || "local-task",
          "data-task-state": state || "TODO"
        };
        return ["div", attrs, 0];
      }
    };
    exports.taskItem = taskItem;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/extensions.js
var require_extensions = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/extensions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isValidLayout = exports.getExtensionAttrs = void 0;
    var isValidLayout = function isValidLayout2(name) {
      return !!name && ["default", "wide", "full-width"].includes(name);
    };
    exports.isValidLayout = isValidLayout;
    var getExtensionAttrs = function getExtensionAttrs2(dom) {
      var isInline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var extensionType = dom.getAttribute("data-extension-type");
      var extensionKey = dom.getAttribute("data-extension-key");
      if (!extensionType || !extensionKey) {
        return false;
      }
      var attrs = {
        extensionType,
        extensionKey,
        text: dom.getAttribute("data-text") || void 0,
        parameters: JSON.parse(dom.getAttribute("data-parameters") || "{}"),
        localId: dom.getAttribute("data-local-id") || void 0
      };
      if (!isInline) {
        var rawLayout = dom.getAttribute("data-layout");
        attrs.layout = isValidLayout(rawLayout) ? rawLayout : "default";
      }
      return attrs;
    };
    exports.getExtensionAttrs = getExtensionAttrs;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/extension.js
var require_extension = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/extension.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extension = void 0;
    var _extensions = require_extensions();
    var createExtensionNodeSpec = function createExtensionNodeSpec2() {
      var nodeSpec = {
        inline: false,
        group: "block",
        atom: true,
        selectable: true,
        attrs: {
          extensionType: {
            default: ""
          },
          extensionKey: {
            default: ""
          },
          parameters: {
            default: null
          },
          text: {
            default: null
          },
          layout: {
            default: "default"
          },
          localId: {
            default: null
          }
        },
        parseDOM: [{
          tag: '[data-node-type="extension"]',
          getAttrs: function getAttrs(domNode) {
            return (0, _extensions.getExtensionAttrs)(domNode);
          }
        }],
        toDOM: function toDOM(node) {
          var attrs = {
            "data-node-type": "extension",
            "data-extension-type": node.attrs.extensionType,
            "data-extension-key": node.attrs.extensionKey,
            "data-text": node.attrs.text,
            "data-parameters": JSON.stringify(node.attrs.parameters),
            "data-layout": node.attrs.layout,
            "data-local-id:": node.attrs.localId
          };
          return ["div", attrs];
        }
      };
      return nodeSpec;
    };
    var extension = createExtensionNodeSpec();
    exports.extension = extension;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/inline-extension.js
var require_inline_extension = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/inline-extension.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inlineExtension = void 0;
    var _extensions = require_extensions();
    var createInlineExtensionNodeSpec = function createInlineExtensionNodeSpec2() {
      var nodeSpec = {
        inline: true,
        group: "inline",
        selectable: true,
        attrs: {
          extensionType: {
            default: ""
          },
          extensionKey: {
            default: ""
          },
          parameters: {
            default: null
          },
          text: {
            default: null
          },
          localId: {
            default: null
          }
        },
        parseDOM: [{
          tag: "span[data-extension-type]",
          getAttrs: function getAttrs(domNode) {
            return (0, _extensions.getExtensionAttrs)(domNode, true);
          }
        }],
        toDOM: function toDOM(node) {
          var attrs = {
            "data-extension-type": node.attrs.extensionType,
            "data-extension-key": node.attrs.extensionKey,
            "data-text": node.attrs.text,
            "data-parameters": JSON.stringify(node.attrs.parameters),
            "data-local-id:": node.attrs.localId,
            contenteditable: "false"
          };
          return ["span", attrs];
        }
      };
      return nodeSpec;
    };
    var inlineExtension = createInlineExtensionNodeSpec();
    exports.inlineExtension = inlineExtension;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/bodied-extension.js
var require_bodied_extension = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/bodied-extension.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bodiedExtension = void 0;
    var _extensions = require_extensions();
    var createBodiedExtensionNodeSpec = function createBodiedExtensionNodeSpec2() {
      var nodeSpec = {
        inline: false,
        group: "block",
        marks: "dataConsumer fragment",
        content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | extension | unsupportedBlock | embedCard)+",
        defining: true,
        selectable: true,
        isolating: true,
        attrs: {
          extensionType: {
            default: ""
          },
          extensionKey: {
            default: ""
          },
          parameters: {
            default: null
          },
          text: {
            default: null
          },
          layout: {
            default: "default"
          },
          localId: {
            default: null
          }
        },
        parseDOM: [{
          context: "bodiedExtension//",
          tag: '[data-node-type="bodied-extension"]',
          skip: true
        }, {
          tag: '[data-node-type="bodied-extension"]',
          getAttrs: function getAttrs(domNode) {
            return (0, _extensions.getExtensionAttrs)(domNode);
          }
        }],
        toDOM: function toDOM(node) {
          var attrs = {
            "data-node-type": "bodied-extension",
            "data-extension-type": node.attrs.extensionType,
            "data-extension-key": node.attrs.extensionKey,
            "data-text": node.attrs.text,
            "data-parameters": JSON.stringify(node.attrs.parameters),
            "data-layout": node.attrs.layout,
            "data-local-id:": node.attrs.localId
          };
          return ["div", attrs, 0];
        }
      };
      return nodeSpec;
    };
    var bodiedExtension = createBodiedExtensionNodeSpec();
    exports.bodiedExtension = bodiedExtension;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/date.js
var require_date = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.date = void 0;
    var date = {
      inline: true,
      group: "inline",
      selectable: true,
      attrs: {
        timestamp: {
          default: ""
        }
      },
      parseDOM: [{
        tag: 'span[data-node-type="date"]',
        getAttrs: function getAttrs(dom) {
          return {
            timestamp: dom.getAttribute("data-timestamp")
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": "date",
          "data-timestamp": node.attrs.timestamp
        };
        return ["span", attrs];
      }
    };
    exports.date = date;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/placeholder.js
var require_placeholder = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/placeholder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.placeholder = void 0;
    var placeholder = {
      inline: true,
      group: "inline",
      selectable: false,
      marks: "",
      attrs: {
        text: {
          default: ""
        }
      },
      parseDOM: [{
        tag: "span[data-placeholder]",
        getAttrs: function getAttrs(dom) {
          return {
            text: dom.getAttribute("data-placeholder") || placeholder.attrs.text.default
          };
        }
      }],
      toDOM: function toDOM(node) {
        var text = node.attrs.text;
        var attrs = {
          "data-placeholder": text,
          // Needs to be edtiable for mobile to not close keyboard
          contenteditable: "true"
        };
        return ["span", attrs, text];
      }
    };
    exports.placeholder = placeholder;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/layout-section.js
var require_layout_section = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/layout-section.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.layoutSectionWithSingleColumn = exports.layoutSection = void 0;
    var layoutSection = {
      content: "(layoutColumn | unsupportedBlock){1,3} unsupportedBlock* | unsupportedBlock+",
      marks: "unsupportedMark unsupportedNodeAttribute",
      isolating: true,
      parseDOM: [{
        context: "layoutSection//|layoutColumn//",
        tag: "div[data-layout-section]",
        skip: true
      }, {
        tag: "div[data-layout-section]"
      }],
      toDOM: function toDOM() {
        var attrs = {
          "data-layout-section": "true"
        };
        return ["div", attrs, 0];
      }
    };
    exports.layoutSection = layoutSection;
    var layoutSectionWithSingleColumn = {
      content: "(layoutColumn | unsupportedBlock){1,3} unsupportedBlock* | unsupportedBlock+",
      marks: "unsupportedMark unsupportedNodeAttribute",
      isolating: true,
      parseDOM: [{
        context: "layoutSection//|layoutColumn//",
        tag: "div[data-layout-section]",
        skip: true
      }, {
        tag: "div[data-layout-section]"
      }],
      toDOM: function toDOM() {
        var attrs = {
          "data-layout-section": "true"
        };
        return ["div", attrs, 0];
      }
    };
    exports.layoutSectionWithSingleColumn = layoutSectionWithSingleColumn;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/layout-column.js
var require_layout_column = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/layout-column.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.layoutColumn = void 0;
    var layoutColumn = {
      content: "(block|unsupportedBlock)+",
      isolating: true,
      marks: "alignment indentation dataConsumer fragment unsupportedMark unsupportedNodeAttribute",
      selectable: false,
      attrs: {
        width: {
          default: void 0
        }
      },
      parseDOM: [{
        context: "layoutColumn//",
        tag: "div[data-layout-column]",
        skip: true
      }, {
        tag: "div[data-layout-column]",
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          return {
            width: Number(dom.getAttribute("data-column-width")) || void 0
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-layout-column": "true"
        };
        var width = node.attrs.width;
        if (width) {
          attrs["style"] = "flex-basis: ".concat(width, "%");
          attrs["data-column-width"] = width;
        }
        var contentAttrs = {
          "data-layout-content": "true"
        };
        return ["div", attrs, ["div", contentAttrs, 0]];
      }
    };
    exports.layoutColumn = layoutColumn;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/inline-card.js
var require_inline_card = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/inline-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inlineCard = void 0;
    var inlineCard = {
      inline: true,
      group: "inline",
      selectable: true,
      draggable: true,
      attrs: {
        url: {
          default: null
        },
        data: {
          default: null
        }
      },
      parseDOM: [
        {
          tag: "a[data-inline-card], span[data-inline-card]",
          // bump priority higher than hyperlink
          priority: 100,
          getAttrs: function getAttrs(dom) {
            var anchor = dom;
            var data = anchor.getAttribute("data-card-data");
            return {
              url: anchor.getAttribute("href") || anchor.getAttribute("data-card-url") || null,
              data: data ? JSON.parse(data) : null
            };
          }
        },
        // for renderer
        {
          tag: "div[data-inline-card]",
          getAttrs: function getAttrs(dom) {
            var anchor = dom;
            var data = anchor.getAttribute("data-card-data");
            return {
              url: anchor.getAttribute("data-card-url"),
              data: data ? JSON.parse(data) : null
            };
          }
        }
      ],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-inline-card": "",
          href: node.attrs.url || "",
          "data-card-data": node.attrs.data ? JSON.stringify(node.attrs.data) : ""
        };
        if (node.attrs.url) {
          return ["a", attrs, node.attrs.url];
        } else {
          return ["a", attrs];
        }
      }
    };
    exports.inlineCard = inlineCard;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/block-card.js
var require_block_card = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/block-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.blockCard = void 0;
    var blockCard = {
      inline: false,
      group: "block",
      draggable: true,
      selectable: true,
      attrs: {
        url: {
          default: null
        },
        data: {
          default: null
        }
      },
      parseDOM: [{
        tag: "a[data-block-card]",
        // bump priority higher than hyperlink
        priority: 100,
        getAttrs: function getAttrs(dom) {
          var anchor = dom;
          var data = anchor.getAttribute("data-card-data");
          return {
            url: anchor.getAttribute("href") || null,
            data: data ? JSON.parse(data) : null
          };
        }
      }, {
        tag: "div[data-block-card]",
        getAttrs: function getAttrs(dom) {
          var anchor = dom;
          var data = anchor.getAttribute("data-card-data");
          return {
            url: anchor.getAttribute("data-card-url") || null,
            data: data ? JSON.parse(data) : null
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs;
        var attrs = {
          "data-block-card": "",
          href: node.attrs.url || "",
          "data-card-data": node.attrs.data ? JSON.stringify(node.attrs.data) : ""
        };
        return ["a", attrs, (node === null || node === void 0 ? void 0 : (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.url) || " "];
      }
    };
    exports.blockCard = blockCard;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unsupported-block.js
var require_unsupported_block = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unsupported-block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unsupportedBlock = void 0;
    var unsupportedBlock = {
      inline: false,
      group: "block",
      atom: true,
      selectable: true,
      attrs: {
        originalValue: {
          default: {}
        }
      },
      parseDOM: [{
        tag: '[data-node-type="unsupportedBlock"]',
        getAttrs: function getAttrs(dom) {
          return {
            originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": "unsupportedBlock",
          "data-original-value": JSON.stringify(node.attrs.originalValue)
        };
        return ["div", attrs, "Unsupported content"];
      }
    };
    exports.unsupportedBlock = unsupportedBlock;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unsupported-inline.js
var require_unsupported_inline = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/unsupported-inline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unsupportedInline = void 0;
    var unsupportedInline = {
      inline: true,
      group: "inline",
      selectable: true,
      attrs: {
        originalValue: {
          default: {}
        }
      },
      parseDOM: [{
        tag: '[data-node-type="unsupportedInline"]',
        getAttrs: function getAttrs(dom) {
          return {
            originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": "unsupportedInline",
          "data-original-value": JSON.stringify(node.attrs.originalValue)
        };
        return ["span", attrs, "Unsupported content"];
      }
    };
    exports.unsupportedInline = unsupportedInline;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/status.js
var require_status = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/status.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.status = void 0;
    var _uuid = require_uuid();
    var status = {
      inline: true,
      group: "inline",
      selectable: true,
      attrs: {
        text: {
          default: ""
        },
        color: {
          default: ""
        },
        localId: {
          default: _uuid.uuid.generate()
        },
        style: {
          default: ""
        }
      },
      parseDOM: [{
        tag: 'span[data-node-type="status"]',
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          return {
            text: dom.textContent.replace(/\n/, "").trim(),
            color: dom.getAttribute("data-color"),
            localId: _uuid.uuid.generate(),
            style: dom.getAttribute("data-style")
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, text = _node$attrs.text, color = _node$attrs.color, localId = _node$attrs.localId, style = _node$attrs.style;
        var attrs = {
          "data-node-type": "status",
          "data-color": color,
          "data-local-id": localId,
          "data-style": style,
          contenteditable: "false"
        };
        return ["span", attrs, text];
      }
    };
    exports.status = status;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/nested-expand.js
var require_nested_expand = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/nested-expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nestedExpand = void 0;
    var nestedExpand = {
      inline: false,
      marks: "unsupportedMark unsupportedNodeAttribute",
      content: "(paragraph | heading | mediaSingle | mediaGroup | unsupportedBlock)+",
      isolating: true,
      selectable: true,
      attrs: {
        title: {
          default: ""
        },
        __expanded: {
          default: true
        }
      },
      parseDOM: [{
        context: "nestedExpand//",
        tag: '[data-node-type="nestedExpand"]',
        skip: true
      }, {
        tag: '[data-node-type="nestedExpand"] button',
        ignore: true
      }, {
        tag: '[data-node-type="expand"] button',
        ignore: true
      }, {
        tag: 'div[data-node-type="nestedExpand"]',
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          return {
            title: dom.getAttribute("data-title"),
            __expanded: true
          };
        }
      }],
      toDOM: function toDOM(node) {
        var attrs = {
          "data-node-type": "nestedExpand",
          "data-title": node.attrs.title,
          "data-expanded": node.attrs.__expanded
        };
        return ["div", attrs, 0];
      }
    };
    exports.nestedExpand = nestedExpand;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/embed-card.js
var require_embed_card = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/embed-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.embedCard = void 0;
    var embedCard = {
      inline: false,
      group: "block",
      selectable: true,
      attrs: {
        url: {
          default: ""
        },
        layout: {
          default: "center"
        },
        width: {
          default: 100
        },
        originalWidth: {
          default: null
        },
        originalHeight: {
          default: null
        }
      },
      parseDOM: [{
        tag: "div[data-embed-card]",
        getAttrs: function getAttrs(dom) {
          return {
            url: dom.getAttribute("data-card-url"),
            layout: dom.getAttribute("data-layout") || "center",
            width: Number(dom.getAttribute("data-width")) || null,
            originalWidth: Number(dom.getAttribute("data-card-original-width")) || null,
            originalHeight: Number(dom.getAttribute("data-card-original-height")) || null
          };
        }
      }],
      toDOM: function toDOM(node) {
        var _node$attrs = node.attrs, url = _node$attrs.url, layout = _node$attrs.layout, width = _node$attrs.width, originalWidth = _node$attrs.originalWidth, originalHeight = _node$attrs.originalHeight;
        var attrs = {
          "data-embed-card": "",
          "data-card-url": url,
          "data-layout": layout,
          "data-width": width,
          "data-original-width": originalWidth,
          "data-original-height": originalHeight
        };
        return ["div", attrs];
      }
    };
    exports.embedCard = embedCard;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/index.js
var require_nodes = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/nodes/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PanelType", {
      enumerable: true,
      get: function get() {
        return _panel.PanelType;
      }
    });
    Object.defineProperty(exports, "blockCard", {
      enumerable: true,
      get: function get() {
        return _blockCard.blockCard;
      }
    });
    Object.defineProperty(exports, "blockquote", {
      enumerable: true,
      get: function get() {
        return _blockquote.blockquote;
      }
    });
    Object.defineProperty(exports, "bodiedExtension", {
      enumerable: true,
      get: function get() {
        return _bodiedExtension.bodiedExtension;
      }
    });
    Object.defineProperty(exports, "bulletList", {
      enumerable: true,
      get: function get() {
        return _bulletList.bulletList;
      }
    });
    Object.defineProperty(exports, "bulletListSelector", {
      enumerable: true,
      get: function get() {
        return _bulletList.bulletListSelector;
      }
    });
    Object.defineProperty(exports, "caption", {
      enumerable: true,
      get: function get() {
        return _caption.caption;
      }
    });
    Object.defineProperty(exports, "codeBlock", {
      enumerable: true,
      get: function get() {
        return _codeBlock.codeBlock;
      }
    });
    Object.defineProperty(exports, "codeBlockToJSON", {
      enumerable: true,
      get: function get() {
        return _codeBlock.toJSON;
      }
    });
    Object.defineProperty(exports, "confluenceJiraIssue", {
      enumerable: true,
      get: function get() {
        return _confluenceJiraIssue.confluenceJiraIssue;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _confluenceUnsupportedBlock.confluenceUnsupportedBlock;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedInline", {
      enumerable: true,
      get: function get() {
        return _confluenceUnsupportedInline.confluenceUnsupportedInline;
      }
    });
    Object.defineProperty(exports, "copyPrivateMediaAttributes", {
      enumerable: true,
      get: function get() {
        return _media.copyPrivateAttributes;
      }
    });
    Object.defineProperty(exports, "date", {
      enumerable: true,
      get: function get() {
        return _date.date;
      }
    });
    Object.defineProperty(exports, "decisionItem", {
      enumerable: true,
      get: function get() {
        return _decisionItem.decisionItem;
      }
    });
    Object.defineProperty(exports, "decisionList", {
      enumerable: true,
      get: function get() {
        return _decisionList.decisionList;
      }
    });
    Object.defineProperty(exports, "decisionListSelector", {
      enumerable: true,
      get: function get() {
        return _decisionList.decisionListSelector;
      }
    });
    Object.defineProperty(exports, "doc", {
      enumerable: true,
      get: function get() {
        return _doc.doc;
      }
    });
    Object.defineProperty(exports, "embedCard", {
      enumerable: true,
      get: function get() {
        return _embedCard.embedCard;
      }
    });
    Object.defineProperty(exports, "emoji", {
      enumerable: true,
      get: function get() {
        return _emoji.emoji;
      }
    });
    Object.defineProperty(exports, "expand", {
      enumerable: true,
      get: function get() {
        return _expand.expand;
      }
    });
    Object.defineProperty(exports, "expandToJSON", {
      enumerable: true,
      get: function get() {
        return _expand.toJSON;
      }
    });
    Object.defineProperty(exports, "extension", {
      enumerable: true,
      get: function get() {
        return _extension.extension;
      }
    });
    Object.defineProperty(exports, "getCellAttrs", {
      enumerable: true,
      get: function get() {
        return _tableNodes.getCellAttrs;
      }
    });
    Object.defineProperty(exports, "getCellDomAttrs", {
      enumerable: true,
      get: function get() {
        return _tableNodes.getCellDomAttrs;
      }
    });
    Object.defineProperty(exports, "hardBreak", {
      enumerable: true,
      get: function get() {
        return _hardBreak.hardBreak;
      }
    });
    Object.defineProperty(exports, "heading", {
      enumerable: true,
      get: function get() {
        return _heading.heading;
      }
    });
    Object.defineProperty(exports, "image", {
      enumerable: true,
      get: function get() {
        return _image.image;
      }
    });
    Object.defineProperty(exports, "inlineCard", {
      enumerable: true,
      get: function get() {
        return _inlineCard.inlineCard;
      }
    });
    Object.defineProperty(exports, "inlineExtension", {
      enumerable: true,
      get: function get() {
        return _inlineExtension.inlineExtension;
      }
    });
    Object.defineProperty(exports, "layoutColumn", {
      enumerable: true,
      get: function get() {
        return _layoutColumn.layoutColumn;
      }
    });
    Object.defineProperty(exports, "layoutSection", {
      enumerable: true,
      get: function get() {
        return _layoutSection.layoutSection;
      }
    });
    Object.defineProperty(exports, "layoutSectionWithSingleColumn", {
      enumerable: true,
      get: function get() {
        return _layoutSection.layoutSectionWithSingleColumn;
      }
    });
    Object.defineProperty(exports, "listItem", {
      enumerable: true,
      get: function get() {
        return _listItem.listItem;
      }
    });
    Object.defineProperty(exports, "media", {
      enumerable: true,
      get: function get() {
        return _media.media;
      }
    });
    Object.defineProperty(exports, "mediaGroup", {
      enumerable: true,
      get: function get() {
        return _mediaGroup.mediaGroup;
      }
    });
    Object.defineProperty(exports, "mediaInline", {
      enumerable: true,
      get: function get() {
        return _mediaInline.mediaInline;
      }
    });
    Object.defineProperty(exports, "mediaSingle", {
      enumerable: true,
      get: function get() {
        return _mediaSingle.mediaSingle;
      }
    });
    Object.defineProperty(exports, "mediaSingleToJSON", {
      enumerable: true,
      get: function get() {
        return _mediaSingle.toJSON;
      }
    });
    Object.defineProperty(exports, "mediaSingleWithCaption", {
      enumerable: true,
      get: function get() {
        return _mediaSingle.mediaSingleWithCaption;
      }
    });
    Object.defineProperty(exports, "mediaToJSON", {
      enumerable: true,
      get: function get() {
        return _media.toJSON;
      }
    });
    Object.defineProperty(exports, "mention", {
      enumerable: true,
      get: function get() {
        return _mention.mention;
      }
    });
    Object.defineProperty(exports, "mentionToJSON", {
      enumerable: true,
      get: function get() {
        return _mention.toJSON;
      }
    });
    Object.defineProperty(exports, "nestedExpand", {
      enumerable: true,
      get: function get() {
        return _nestedExpand.nestedExpand;
      }
    });
    Object.defineProperty(exports, "orderedList", {
      enumerable: true,
      get: function get() {
        return _orderedList.orderedList;
      }
    });
    Object.defineProperty(exports, "orderedListSelector", {
      enumerable: true,
      get: function get() {
        return _orderedList.orderedListSelector;
      }
    });
    Object.defineProperty(exports, "orderedListWithOrder", {
      enumerable: true,
      get: function get() {
        return _orderedList.orderedListWithOrder;
      }
    });
    Object.defineProperty(exports, "panel", {
      enumerable: true,
      get: function get() {
        return _panel.panel;
      }
    });
    Object.defineProperty(exports, "paragraph", {
      enumerable: true,
      get: function get() {
        return _paragraph.paragraph;
      }
    });
    Object.defineProperty(exports, "placeholder", {
      enumerable: true,
      get: function get() {
        return _placeholder.placeholder;
      }
    });
    Object.defineProperty(exports, "rule", {
      enumerable: true,
      get: function get() {
        return _rule.rule;
      }
    });
    Object.defineProperty(exports, "status", {
      enumerable: true,
      get: function get() {
        return _status.status;
      }
    });
    Object.defineProperty(exports, "table", {
      enumerable: true,
      get: function get() {
        return _tableNodes.table;
      }
    });
    Object.defineProperty(exports, "tableBackgroundBorderColor", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableBackgroundBorderColor;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorNames", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableBackgroundColorNames;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorPalette", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableBackgroundColorPalette;
      }
    });
    Object.defineProperty(exports, "tableCell", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableCell;
      }
    });
    Object.defineProperty(exports, "tableCellContentDomSelector", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableCellContentDomSelector;
      }
    });
    Object.defineProperty(exports, "tableCellContentWrapperSelector", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableCellContentWrapperSelector;
      }
    });
    Object.defineProperty(exports, "tableCellSelector", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableCellSelector;
      }
    });
    Object.defineProperty(exports, "tableHeader", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableHeader;
      }
    });
    Object.defineProperty(exports, "tableHeaderSelector", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableHeaderSelector;
      }
    });
    Object.defineProperty(exports, "tablePrefixSelector", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tablePrefixSelector;
      }
    });
    Object.defineProperty(exports, "tableRow", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableRow;
      }
    });
    Object.defineProperty(exports, "tableToJSON", {
      enumerable: true,
      get: function get() {
        return _tableNodes.tableToJSON;
      }
    });
    Object.defineProperty(exports, "taskItem", {
      enumerable: true,
      get: function get() {
        return _taskItem.taskItem;
      }
    });
    Object.defineProperty(exports, "taskList", {
      enumerable: true,
      get: function get() {
        return _taskList.taskList;
      }
    });
    Object.defineProperty(exports, "taskListSelector", {
      enumerable: true,
      get: function get() {
        return _taskList.taskListSelector;
      }
    });
    Object.defineProperty(exports, "text", {
      enumerable: true,
      get: function get() {
        return _text.text;
      }
    });
    Object.defineProperty(exports, "toJSONTableCell", {
      enumerable: true,
      get: function get() {
        return _tableNodes.toJSONTableCell;
      }
    });
    Object.defineProperty(exports, "toJSONTableHeader", {
      enumerable: true,
      get: function get() {
        return _tableNodes.toJSONTableHeader;
      }
    });
    Object.defineProperty(exports, "unknownBlock", {
      enumerable: true,
      get: function get() {
        return _unknownBlock.default;
      }
    });
    Object.defineProperty(exports, "unsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _unsupportedBlock.unsupportedBlock;
      }
    });
    Object.defineProperty(exports, "unsupportedInline", {
      enumerable: true,
      get: function get() {
        return _unsupportedInline.unsupportedInline;
      }
    });
    var _expand = require_expand();
    var _confluenceJiraIssue = require_confluence_jira_issue();
    var _confluenceUnsupportedBlock = require_confluence_unsupported_block();
    var _confluenceUnsupportedInline = require_confluence_unsupported_inline();
    var _doc = require_doc();
    var _blockquote = require_blockquote();
    var _bulletList = require_bullet_list();
    var _codeBlock = require_code_block();
    var _hardBreak = require_hard_break();
    var _heading = require_heading();
    var _rule = require_rule();
    var _orderedList = require_ordered_list();
    var _paragraph = require_paragraph();
    var _emoji = require_emoji2();
    var _image = require_image();
    var _mention = require_mention();
    var _listItem = require_list_item();
    var _panel = require_panel();
    var _text = require_text();
    var _unknownBlock = _interopRequireDefault(require_unknown_block());
    var _caption = require_caption();
    var _media = require_media();
    var _mediaGroup = require_media_group();
    var _mediaInline = require_media_inline();
    var _mediaSingle = require_media_single();
    var _tableNodes = require_tableNodes();
    var _decisionList = require_decision_list();
    var _decisionItem = require_decision_item();
    var _taskList = require_task_list();
    var _taskItem = require_task_item();
    var _extension = require_extension();
    var _inlineExtension = require_inline_extension();
    var _bodiedExtension = require_bodied_extension();
    var _date = require_date();
    var _placeholder = require_placeholder();
    var _layoutSection = require_layout_section();
    var _layoutColumn = require_layout_column();
    var _inlineCard = require_inline_card();
    var _blockCard = require_block_card();
    var _unsupportedBlock = require_unsupported_block();
    var _unsupportedInline = require_unsupported_inline();
    var _status = require_status();
    var _nestedExpand = require_nested_expand();
    var _embedCard = require_embed_card();
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/groups.js
var require_groups = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/groups.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SEARCH_QUERY = exports.LINK = exports.INDENTATION = exports.FONT_STYLE = exports.COLOR = exports.ALIGNMENT = void 0;
    var FONT_STYLE = "fontStyle";
    exports.FONT_STYLE = FONT_STYLE;
    var SEARCH_QUERY = "searchQuery";
    exports.SEARCH_QUERY = SEARCH_QUERY;
    var LINK = "link";
    exports.LINK = LINK;
    var COLOR = "color";
    exports.COLOR = COLOR;
    var ALIGNMENT = "alignment";
    exports.ALIGNMENT = ALIGNMENT;
    var INDENTATION = "indentation";
    exports.INDENTATION = INDENTATION;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/em.js
var require_em = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/em.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.em = void 0;
    var _groups = require_groups();
    var emDOM = ["em"];
    var em = {
      inclusive: true,
      group: _groups.FONT_STYLE,
      parseDOM: [{
        tag: "i"
      }, {
        tag: "em"
      }, {
        style: "font-style=italic"
      }],
      toDOM: function toDOM() {
        return emDOM;
      }
    };
    exports.em = em;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/code.js
var require_code = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.code = void 0;
    var _groups = require_groups();
    var code = {
      excludes: "".concat(_groups.FONT_STYLE, " ").concat(_groups.LINK, " ").concat(_groups.SEARCH_QUERY, " ").concat(_groups.COLOR),
      inclusive: true,
      parseDOM: [{
        tag: "span.code",
        preserveWhitespace: true
      }, {
        tag: "code",
        preserveWhitespace: true
      }, {
        tag: "tt",
        preserveWhitespace: true
      }, {
        tag: "span",
        preserveWhitespace: true,
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          if (dom.style.whiteSpace === "pre") {
            return {};
          }
          if (dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") >= 0) {
            return {};
          }
          return false;
        }
      }],
      toDOM: function toDOM() {
        return ["span", {
          class: "code",
          spellcheck: "false"
        }];
      }
    };
    exports.code = code;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/strike.js
var require_strike = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/strike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strike = void 0;
    var _groups = require_groups();
    var strike = {
      inclusive: true,
      group: _groups.FONT_STYLE,
      parseDOM: [{
        tag: "strike"
      }, {
        tag: "s"
      }, {
        tag: "del"
      }, {
        style: "text-decoration",
        getAttrs: function getAttrs(value) {
          return value === "line-through" && null;
        }
      }],
      toDOM: function toDOM() {
        return ["s"];
      }
    };
    exports.strike = strike;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/strong.js
var require_strong = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/strong.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strong = void 0;
    var _groups = require_groups();
    var strongDOM = ["strong"];
    var strong = {
      inclusive: true,
      group: _groups.FONT_STYLE,
      parseDOM: [
        {
          tag: "strong"
        },
        // This works around a Google Docs misbehavior where
        // pasted content will be inexplicably wrapped in `<b>`
        // tags with a font-weight normal.
        {
          tag: "b",
          getAttrs: function getAttrs(node) {
            var element = node;
            return element.style.fontWeight !== "normal" && null;
          }
        },
        {
          tag: "span",
          getAttrs: function getAttrs(node) {
            var element = node;
            var fontWeight = element.style.fontWeight;
            return typeof fontWeight === "string" && (fontWeight === "bold" || fontWeight === "bolder" || /^(bold(er)?|[5-9]\d{2,})$/.test(fontWeight)) && null;
          }
        }
      ],
      toDOM: function toDOM() {
        return strongDOM;
      }
    };
    exports.strong = strong;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/underline.js
var require_underline = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/underline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.underline = void 0;
    var _groups = require_groups();
    var underline = {
      inclusive: true,
      group: _groups.FONT_STYLE,
      parseDOM: [{
        tag: "u"
      }, {
        style: "text-decoration",
        getAttrs: function getAttrs(value) {
          return value === "underline" && null;
        }
      }],
      toDOM: function toDOM() {
        return ["u"];
      }
    };
    exports.underline = underline;
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module2) {
    module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module2) {
    module2.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module2) {
    module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module2) {
    module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex().source;
      re.src_Cc = require_regex2().source;
      re.src_Z = require_regex3().source;
      re.src_P = require_regex4().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + re.src_ZCc + ").|\\!(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/url.js
var require_url = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/url.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LINK_REGEXP = void 0;
    exports.getLinkMatch = getLinkMatch;
    exports.isRootRelative = isRootRelative;
    exports.linkifyMatch = exports.linkify = exports.isSafeUrl = void 0;
    exports.normalizeUrl = normalizeUrl;
    var _linkifyIt = _interopRequireDefault(require_linkify_it());
    var whitelistedURLPatterns = [/^https?:\/\//im, /^ftps?:\/\//im, /^gopher:\/\//im, /^integrity:\/\//im, /^file:\/\//im, /^smb:\/\//im, /^dynamicsnav:\/\//im, /^jamfselfservice:\/\//im, /^\//im, /^mailto:/im, /^skype:/im, /^callto:/im, /^facetime:/im, /^git:/im, /^irc6?:/im, /^news:/im, /^nntp:/im, /^feed:/im, /^cvs:/im, /^svn:/im, /^mvn:/im, /^ssh:/im, /^scp:\/\//im, /^sftp:\/\//im, /^itms:/im, /^notes:/im, /^hipchat:\/\//im, /^sourcetree:/im, /^urn:/im, /^tel:/im, /^xmpp:/im, /^telnet:/im, /^vnc:/im, /^rdp:/im, /^whatsapp:/im, /^slack:/im, /^sips?:/im, /^magnet:/im, /^#/im];
    var isSafeUrl = function isSafeUrl2(url) {
      var urlTrimmed = url.trim();
      if (urlTrimmed.length === 0) {
        return true;
      }
      return whitelistedURLPatterns.some(function(p) {
        return p.test(urlTrimmed);
      });
    };
    exports.isSafeUrl = isSafeUrl;
    var linkify = (0, _linkifyIt.default)();
    exports.linkify = linkify;
    linkify.add("sourcetree:", "http:");
    linkify.add("jamfselfservice:", "http:");
    var tlds = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    var tlds2Char = "a[cdefgilmnoqrtuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrtuvwxyz]|n[acefgilopruz]|om|p[aefghkmnrtw]|qa|r[eosuw]|s[abcdegijklmnrtuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    tlds.push(tlds2Char);
    linkify.tlds(tlds, false);
    var LINK_REGEXP = /(https?|ftp|jamfselfservice|gopher|dynamicsnav|integrity|file|smb):\/\/[^\s]+/;
    exports.LINK_REGEXP = LINK_REGEXP;
    var linkifyMatch = function linkifyMatch2(text) {
      var matches = [];
      if (!LINK_REGEXP.test(text)) {
        return matches;
      }
      var startpos = 0;
      var substr;
      while (substr = text.substr(startpos)) {
        var link = (substr.match(LINK_REGEXP) || [""])[0];
        if (link) {
          var index = substr.search(LINK_REGEXP);
          var start = index >= 0 ? index + startpos : index;
          var end = start + link.length;
          matches.push({
            index: start,
            lastIndex: end,
            raw: link,
            url: link,
            text: link,
            schema: ""
          });
          startpos += end;
        } else {
          break;
        }
      }
      return matches;
    };
    exports.linkifyMatch = linkifyMatch;
    function getLinkMatch(str) {
      if (!str) {
        return null;
      }
      var match = linkifyMatch(str);
      if (!match.length) {
        match = linkify.match(str);
      }
      return match && match[0];
    }
    function normalizeUrl(url) {
      var match = getLinkMatch(url);
      return match && match.url || "";
    }
    function isRootRelative(url) {
      return url.startsWith("/");
    }
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/link.js
var require_link = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/link.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.link = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _groups = require_groups();
    var _url = require_url();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var getLinkAttrs = function getLinkAttrs2(attribute) {
      return function(domNode) {
        var dom = domNode;
        var href = dom.getAttribute(attribute) || "";
        var attrs = {
          __confluenceMetadata: dom.hasAttribute("__confluenceMetadata") ? JSON.parse(dom.getAttribute("__confluenceMetadata") || "") : void 0
        };
        if (!(0, _url.isSafeUrl)(href)) {
          return false;
        }
        if ((0, _url.isRootRelative)(href)) {
          attrs.href = href;
          return attrs;
        }
        attrs.href = (0, _url.normalizeUrl)(href);
        return attrs;
      };
    };
    var link = {
      excludes: "".concat(_groups.LINK),
      // ED-5844 No multiple links in media node
      group: _groups.LINK,
      attrs: {
        href: {},
        __confluenceMetadata: {
          default: null
        }
      },
      inclusive: false,
      parseDOM: [{
        tag: "[data-block-link]",
        getAttrs: getLinkAttrs("data-block-link"),
        contentElement: function contentElement(node) {
          var clone = node.cloneNode(true);
          clone.removeAttribute("data-block-link");
          clone.setAttribute("data-skip-paste", "true");
          var wrapper = document.createElement("div");
          wrapper.appendChild(clone);
          return wrapper;
        }
      }, {
        tag: "a[href]",
        getAttrs: getLinkAttrs("href")
      }],
      toDOM: function toDOM(node, isInline) {
        var _objectSpread2;
        var attrs = Object.keys(node.attrs).reduce(function(attrs2, key) {
          if (key === "__confluenceMetadata") {
            if (node.attrs[key] !== null) {
              attrs2[key] = JSON.stringify(node.attrs[key]);
            }
          } else if (key === "href") {
            attrs2[key] = (0, _url.isSafeUrl)(node.attrs[key]) ? node.attrs[key] : void 0;
          } else {
            attrs2[key] = node.attrs[key];
          }
          return attrs2;
        }, {});
        if (isInline) {
          return ["a", attrs];
        }
        return ["a", _objectSpread(_objectSpread({}, attrs), {}, (_objectSpread2 = {}, (0, _defineProperty2.default)(_objectSpread2, "data-block-link", "true"), (0, _defineProperty2.default)(_objectSpread2, "class", "blockLink"), _objectSpread2)), 0];
      }
    };
    exports.link = link;
    var OPTIONAL_ATTRS = ["title", "id", "collection", "occurrenceKey", "__confluenceMetadata"];
    var toJSON = function toJSON2(mark) {
      return {
        type: mark.type.name,
        attrs: Object.keys(mark.attrs).reduce(function(attrs, key) {
          if (OPTIONAL_ATTRS.indexOf(key) === -1 || mark.attrs[key] !== null) {
            attrs[key] = mark.attrs[key];
          }
          return attrs;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/type-ahead-query.js
var require_type_ahead_query = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/type-ahead-query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeAheadQuery = void 0;
    var _groups = require_groups();
    var _colors = require_colors();
    var typeAheadQuery = {
      inclusive: true,
      group: _groups.SEARCH_QUERY,
      parseDOM: [{
        tag: "span[data-type-ahead-query]"
      }],
      toDOM: function toDOM(node) {
        return ["span", {
          "data-type-ahead-query": "true",
          "data-trigger": node.attrs.trigger,
          style: "color: ".concat(_colors.B400)
        }];
      },
      attrs: {
        trigger: {
          default: ""
        }
      }
    };
    exports.typeAheadQuery = typeAheadQuery;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/subsup.js
var require_subsup = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/subsup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subsup = void 0;
    var _groups = require_groups();
    function getAttrFromVerticalAlign(node) {
      if (node.style.verticalAlign) {
        var type = node.style.verticalAlign.slice(0, 3);
        if (type === "sub" || type === "sup") {
          return {
            type
          };
        }
      }
      return false;
    }
    var subsup = {
      inclusive: true,
      group: _groups.FONT_STYLE,
      attrs: {
        type: {
          default: "sub"
        }
      },
      parseDOM: [{
        tag: "sub",
        attrs: {
          type: "sub"
        }
      }, {
        tag: "sup",
        attrs: {
          type: "sup"
        }
      }, {
        // Special case for pasting from Google Docs
        // Google Docs uses vertical align to denote subscript and super script
        tag: "span",
        style: "vertical-align=super",
        getAttrs: function getAttrs(node) {
          return getAttrFromVerticalAlign(node);
        }
      }, {
        tag: "span",
        style: "vertical-align=sub",
        getAttrs: function getAttrs(node) {
          return getAttrFromVerticalAlign(node);
        }
      }],
      toDOM: function toDOM(mark) {
        return [mark.attrs.type];
      }
    };
    exports.subsup = subsup;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/text-color.js
var require_text_color = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/text-color.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.textColor = exports.colorPaletteExtended = exports.colorPalette = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _editorPalette = require_cjs();
    var _groups = require_groups();
    var _colors = require_colors();
    var colorArrayPalette = [
      // default row - first color is added programatically
      // [N800, 'Squid ink'], // default dark gray
      [_colors.B500, "Dark blue"],
      // Chore coat
      [_colors.T500, "Dark teal"],
      // Shabby chic
      [_colors.G500, "Dark green"],
      // Keen green
      [_colors.Y400, "Orange"],
      // Cheezy blasters
      [_colors.R500, "Dark red"],
      // Dragon's blood
      [_colors.P500, "Dark purple"],
      // Prince
      // row 2
      [_colors.N80, "Light gray"],
      // Spooky ghost
      [_colors.B100, "Blue"],
      // Arvo breeze
      [_colors.T300, "Teal"],
      // Tamarama
      [_colors.G300, "Green"],
      // Fine pine
      [_colors.Y200, "Yellow"],
      // Pub mix
      [_colors.R300, "Red"],
      // Poppy surprise
      [_colors.P300, "Purple"],
      // Da' juice
      // row 3
      [_colors.N0, "White"],
      [_colors.B75, "Light blue"],
      // Schwag
      [_colors.T75, "Light teal"],
      // Arctic chill
      [_colors.G75, "Light green"],
      // Mintie
      [_colors.Y75, "Light yellow"],
      // Dandelion whisper
      [_colors.R75, "Light red"],
      // Bondi sunburn
      [_colors.P50, "Light purple"]
      // Lavender secret
    ];
    var colorPalette = /* @__PURE__ */ new Map();
    exports.colorPalette = colorPalette;
    var colorPaletteExtended = colorPalette;
    exports.colorPaletteExtended = colorPaletteExtended;
    colorArrayPalette.forEach(function(_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2), color = _ref2[0], label = _ref2[1];
      return colorPalette.set(color.toLowerCase(), label);
    });
    var textColor = {
      attrs: {
        color: {}
      },
      inclusive: true,
      group: _groups.COLOR,
      parseDOM: [
        {
          style: "color",
          getAttrs: function getAttrs(maybeValue) {
            var value = maybeValue;
            var hexColor;
            if (value.match(/^rgb/i)) {
              hexColor = (0, _colors.rgbToHex)(value);
            } else if (value[0] === "#") {
              hexColor = value.toLowerCase();
            }
            return hexColor && colorPalette.has(hexColor) ? {
              color: hexColor
            } : false;
          }
        },
        // This rule ensures when loading from a renderer or editor where the
        // presented text color does not match the stored hex color -- that the
        // text color is preserved.
        //
        // This was initially introduced to ensure text-color marks were not lost
        // when text-color was used inside a link, and is now also used to support
        // where the hex color stored in ADF is used as an ID for a design system
        // token (and based on theme mode -- the presented color will change).
        {
          tag: ".fabric-text-color-mark",
          getAttrs: function getAttrs(maybeElement) {
            if (!(maybeElement instanceof HTMLElement)) {
              return false;
            }
            var hexColor = maybeElement.dataset.textCustomColor;
            return hexColor && colorPalette.has(hexColor) ? {
              color: hexColor
            } : false;
          }
        }
      ],
      toDOM: function toDOM(mark) {
        var paletteColorValue = (0, _editorPalette.hexToEditorTextPaletteColor)(mark.attrs.color) || mark.attrs.color;
        return ["span", (0, _defineProperty2.default)({
          class: "fabric-text-color-mark",
          style: "--custom-palette-color: ".concat(paletteColorValue)
        }, "data-text-custom-color", mark.attrs.color)];
      }
    };
    exports.textColor = textColor;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/confluence-inline-comment.js
var require_confluence_inline_comment = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/confluence-inline-comment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.confluenceInlineComment = void 0;
    var confluenceInlineComment = {
      inclusive: false,
      excludes: "",
      attrs: {
        reference: {
          default: ""
        }
      },
      parseDOM: [{
        tag: 'span[data-mark-type="confluenceInlineComment"]'
      }],
      toDOM: function toDOM(node) {
        return ["span", {
          "data-mark-type": "confluenceInlineComment",
          "data-reference": node.attrs.reference
        }];
      }
    };
    exports.confluenceInlineComment = confluenceInlineComment;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/breakout.js
var require_breakout = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/breakout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.breakout = void 0;
    var allowedTypes = ["wide", "full-width"];
    var breakout = {
      spanning: false,
      inclusive: false,
      parseDOM: [{
        tag: "div.fabric-editor-breakout-mark",
        getAttrs: function getAttrs(dom) {
          var mode = dom.getAttribute("data-mode");
          return {
            mode: allowedTypes.indexOf(mode || "") === -1 ? "wide" : mode
          };
        }
      }],
      attrs: {
        mode: {
          default: "wide"
        }
      },
      toDOM: function toDOM(mark) {
        return ["div", {
          class: "fabric-editor-breakout-mark",
          "data-mode": mark.attrs.mode
        }, 0];
      }
    };
    exports.breakout = breakout;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/alignment.js
var require_alignment = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.alignmentPositionMap = exports.alignment = void 0;
    var _groups = require_groups();
    var alignmentPositionMap = {
      end: "right",
      right: "end",
      center: "center"
    };
    exports.alignmentPositionMap = alignmentPositionMap;
    var alignment = {
      excludes: "alignment ".concat(_groups.INDENTATION),
      group: _groups.ALIGNMENT,
      attrs: {
        align: {}
      },
      parseDOM: [{
        tag: "div.fabric-editor-block-mark",
        getAttrs: function getAttrs(dom) {
          var align = dom.getAttribute("data-align");
          return align ? {
            align
          } : false;
        }
      }],
      toDOM: function toDOM(mark) {
        return ["div", {
          class: "fabric-editor-block-mark fabric-editor-alignment fabric-editor-align-".concat(mark.attrs.align),
          "data-align": mark.attrs.align
        }, 0];
      }
    };
    exports.alignment = alignment;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/indentation.js
var require_indentation = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/indentation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.indentation = void 0;
    var _groups = require_groups();
    var indentation = {
      excludes: "indentation ".concat(_groups.ALIGNMENT),
      group: _groups.INDENTATION,
      attrs: {
        level: {}
      },
      parseDOM: [{
        tag: "div.fabric-editor-indentation-mark",
        getAttrs: function getAttrs(dom) {
          var level = +(dom.getAttribute("data-level") || "0");
          return {
            level: level > 6 ? 6 : level < 1 ? false : level
          };
        }
      }],
      toDOM: function toDOM(mark) {
        return ["div", {
          class: "fabric-editor-block-mark fabric-editor-indentation-mark",
          "data-level": mark.attrs.level
        }, 0];
      }
    };
    exports.indentation = indentation;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/annotation.js
var require_annotation = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/annotation.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.annotation = exports.AnnotationTypes = exports.AnnotationMarkStates = void 0;
    exports.buildDataAttributes = buildDataAttributes;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var AnnotationTypes;
    exports.AnnotationTypes = AnnotationTypes;
    (function(AnnotationTypes2) {
      AnnotationTypes2["INLINE_COMMENT"] = "inlineComment";
    })(AnnotationTypes || (exports.AnnotationTypes = AnnotationTypes = {}));
    var AnnotationMarkStates;
    exports.AnnotationMarkStates = AnnotationMarkStates;
    (function(AnnotationMarkStates2) {
      AnnotationMarkStates2["RESOLVED"] = "resolved";
      AnnotationMarkStates2["ACTIVE"] = "active";
    })(AnnotationMarkStates || (exports.AnnotationMarkStates = AnnotationMarkStates = {}));
    function buildDataAttributes(_ref) {
      var id = _ref.id, annotationType = _ref.annotationType, state = _ref.state;
      var data = {
        "data-mark-type": "annotation",
        "data-mark-annotation-type": annotationType,
        "data-id": id
      };
      if (state) {
        return _objectSpread(_objectSpread({}, data), {}, {
          "data-mark-annotation-state": state
        });
      }
      return data;
    }
    var annotation = {
      inclusive: true,
      group: "annotation",
      excludes: "",
      attrs: {
        id: {
          default: ""
        },
        annotationType: {
          default: AnnotationTypes.INLINE_COMMENT
        }
      },
      parseDOM: [{
        tag: 'span[data-mark-type="annotation"]',
        mark: "annotation",
        getAttrs: function getAttrs(domNode) {
          var dom = domNode;
          var attrs = {
            id: dom.getAttribute("data-id"),
            annotationType: dom.getAttribute("data-mark-annotation-type")
          };
          return attrs;
        }
      }],
      toDOM: function toDOM(node) {
        return ["span", _objectSpread({
          // Prettier will remove the quotes around class. This would cause some browsers
          // to not add this attribute properly, as its a reserved word.
          // prettier-ignore
          "class": "fabric-editor-annotation"
        }, buildDataAttributes({
          id: node.attrs.id,
          annotationType: node.attrs.annotationType
        })), 0];
      }
    };
    exports.annotation = annotation;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/unsupported-mark.js
var require_unsupported_mark = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/unsupported-mark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unsupportedMark = void 0;
    var unsupportedMark = {
      toDOM: function toDOM() {
        return ["span"];
      },
      excludes: "",
      attrs: {
        originalValue: {}
      }
    };
    exports.unsupportedMark = unsupportedMark;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/unsupported-node-attributes.js
var require_unsupported_node_attributes = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/unsupported-node-attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unsupportedNodeAttribute = void 0;
    var unsupportedNodeAttribute = {
      toDOM: function toDOM() {
        return ["span"];
      },
      attrs: {
        type: {},
        unsupported: {}
      }
    };
    exports.unsupportedNodeAttribute = unsupportedNodeAttribute;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/parseDOM.js
var require_parseDOM = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/parseDOM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDOMElement = void 0;
    var isDOMElement = function isDOMElement2(maybeNode) {
      return maybeNode instanceof Node && maybeNode.nodeType === Node.ELEMENT_NODE;
    };
    exports.isDOMElement = isDOMElement;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/data-consumer.js
var require_data_consumer = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/data-consumer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.dataConsumer = void 0;
    var _parseDOM = require_parseDOM();
    var parseDataConsumer = function parseDataConsumer2(maybeValue) {
      var sources = (0, _parseDOM.isDOMElement)(maybeValue) && maybeValue.getAttribute("data-sources");
      try {
        return sources ? {
          sources: JSON.parse(sources)
        } : false;
      } catch (_unused) {
        return false;
      }
    };
    var dataConsumer = {
      attrs: {
        sources: {
          default: []
        }
      },
      parseDOM: [{
        tag: '[data-mark-type="dataConsumer"]',
        getAttrs: function getAttrs(maybeValue) {
          return parseDataConsumer(maybeValue);
        }
      }],
      toDOM: function toDOM(mark, inline) {
        var wrapperStyle = inline ? "span" : "div";
        return [wrapperStyle, {
          "data-mark-type": "dataConsumer",
          "data-sources": JSON.stringify(mark.attrs.sources)
        }];
      }
    };
    exports.dataConsumer = dataConsumer;
    var toJSON = function toJSON2(mark) {
      return {
        type: mark.type.name,
        attrs: Object.keys(mark.attrs).filter(function(key) {
          return key === "sources" && mark.attrs[key].length > 0 && mark.attrs[key] !== null;
        }).reduce(function(acc, key) {
          acc[key] = mark.attrs[key];
          return acc;
        }, {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/fragment.js
var require_fragment = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/fragment.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toJSON = exports.fragment = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _parseDOM = require_parseDOM();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var parseFragment = function parseFragment2(maybeValue) {
      var _maybeValue$getAttrib;
      if (!(0, _parseDOM.isDOMElement)(maybeValue)) {
        return false;
      }
      var name = (_maybeValue$getAttrib = maybeValue.getAttribute("data-name")) !== null && _maybeValue$getAttrib !== void 0 ? _maybeValue$getAttrib : void 0;
      var localId = maybeValue.getAttribute("data-localId");
      if (!localId) {
        return false;
      }
      return {
        localId,
        name
      };
    };
    var fragment = {
      inclusive: false,
      excludes: "",
      attrs: {
        localId: {
          default: ""
        },
        name: {
          default: null
        }
      },
      parseDOM: [{
        tag: '[data-mark-type="fragment"]',
        getAttrs: function getAttrs(maybeValue) {
          return parseFragment(maybeValue);
        }
      }],
      toDOM: function toDOM(mark, inline) {
        var wrapperStyle = inline ? "span" : "div";
        return [wrapperStyle, {
          "data-mark-type": "fragment",
          "data-name": mark.attrs.name,
          "data-localId": mark.attrs.localId
        }];
      }
    };
    exports.fragment = fragment;
    var toJSON = function toJSON2(mark) {
      return {
        type: mark.type.name,
        attrs: _objectSpread({
          localId: mark.attrs.localId
        }, mark.attrs.name ? {
          name: mark.attrs.name
        } : {})
      };
    };
    exports.toJSON = toJSON;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/border.js
var require_border2 = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/border.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.borderColorPalette = exports.border = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _editorPalette = require_cjs();
    var _colors = require_colors();
    var borderColorArrayPalette = [[_colors.N300A, "Subtle gray"], [_colors.N600, "Gray"], [_colors.N1000, "Bold gray"]];
    var borderColorPalette = /* @__PURE__ */ new Map();
    exports.borderColorPalette = borderColorPalette;
    borderColorArrayPalette.forEach(function(_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2), color = _ref2[0], label = _ref2[1];
      return borderColorPalette.set(color.toLowerCase(), label);
    });
    var border = {
      inclusive: false,
      parseDOM: [{
        tag: 'div[data-mark-type="border"]',
        getAttrs: function getAttrs(domNode) {
          var _dom$getAttribute, _dom$getAttribute2;
          var dom = domNode;
          var color = ((_dom$getAttribute = dom.getAttribute("data-color")) !== null && _dom$getAttribute !== void 0 ? _dom$getAttribute : "").toLowerCase();
          var size = +((_dom$getAttribute2 = dom.getAttribute("data-size")) !== null && _dom$getAttribute2 !== void 0 ? _dom$getAttribute2 : "0");
          return {
            size: size > 3 ? 3 : size < 1 ? false : size,
            color: borderColorPalette.has(color) ? color : false
          };
        }
      }],
      attrs: {
        color: {},
        size: {}
      },
      toDOM: function toDOM(mark) {
        var paletteColorValue = (0, _editorPalette.hexToEditorBorderPaletteColor)(mark.attrs.color) || mark.attrs.color;
        return ["div", {
          "data-mark-type": "border",
          "data-color": mark.attrs.color,
          "data-size": mark.attrs.size,
          style: "--custom-palette-color: ".concat(paletteColorValue)
        }];
      }
    };
    exports.border = border;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/index.js
var require_marks = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/marks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnnotationMarkStates", {
      enumerable: true,
      get: function get() {
        return _annotation.AnnotationMarkStates;
      }
    });
    Object.defineProperty(exports, "AnnotationTypes", {
      enumerable: true,
      get: function get() {
        return _annotation.AnnotationTypes;
      }
    });
    Object.defineProperty(exports, "alignment", {
      enumerable: true,
      get: function get() {
        return _alignment.alignment;
      }
    });
    Object.defineProperty(exports, "alignmentPositionMap", {
      enumerable: true,
      get: function get() {
        return _alignment.alignmentPositionMap;
      }
    });
    Object.defineProperty(exports, "annotation", {
      enumerable: true,
      get: function get() {
        return _annotation.annotation;
      }
    });
    Object.defineProperty(exports, "border", {
      enumerable: true,
      get: function get() {
        return _border.border;
      }
    });
    Object.defineProperty(exports, "borderColorPalette", {
      enumerable: true,
      get: function get() {
        return _border.borderColorPalette;
      }
    });
    Object.defineProperty(exports, "breakout", {
      enumerable: true,
      get: function get() {
        return _breakout.breakout;
      }
    });
    Object.defineProperty(exports, "buildAnnotationMarkDataAttributes", {
      enumerable: true,
      get: function get() {
        return _annotation.buildDataAttributes;
      }
    });
    Object.defineProperty(exports, "code", {
      enumerable: true,
      get: function get() {
        return _code.code;
      }
    });
    Object.defineProperty(exports, "colorPalette", {
      enumerable: true,
      get: function get() {
        return _textColor.colorPalette;
      }
    });
    Object.defineProperty(exports, "colorPaletteExtended", {
      enumerable: true,
      get: function get() {
        return _textColor.colorPaletteExtended;
      }
    });
    Object.defineProperty(exports, "confluenceInlineComment", {
      enumerable: true,
      get: function get() {
        return _confluenceInlineComment.confluenceInlineComment;
      }
    });
    Object.defineProperty(exports, "dataConsumer", {
      enumerable: true,
      get: function get() {
        return _dataConsumer.dataConsumer;
      }
    });
    Object.defineProperty(exports, "dataConsumerToJSON", {
      enumerable: true,
      get: function get() {
        return _dataConsumer.toJSON;
      }
    });
    Object.defineProperty(exports, "em", {
      enumerable: true,
      get: function get() {
        return _em.em;
      }
    });
    Object.defineProperty(exports, "fragment", {
      enumerable: true,
      get: function get() {
        return _fragment.fragment;
      }
    });
    Object.defineProperty(exports, "fragmentToJSON", {
      enumerable: true,
      get: function get() {
        return _fragment.toJSON;
      }
    });
    Object.defineProperty(exports, "indentation", {
      enumerable: true,
      get: function get() {
        return _indentation.indentation;
      }
    });
    Object.defineProperty(exports, "link", {
      enumerable: true,
      get: function get() {
        return _link.link;
      }
    });
    Object.defineProperty(exports, "linkToJSON", {
      enumerable: true,
      get: function get() {
        return _link.toJSON;
      }
    });
    Object.defineProperty(exports, "strike", {
      enumerable: true,
      get: function get() {
        return _strike.strike;
      }
    });
    Object.defineProperty(exports, "strong", {
      enumerable: true,
      get: function get() {
        return _strong.strong;
      }
    });
    Object.defineProperty(exports, "subsup", {
      enumerable: true,
      get: function get() {
        return _subsup.subsup;
      }
    });
    Object.defineProperty(exports, "textColor", {
      enumerable: true,
      get: function get() {
        return _textColor.textColor;
      }
    });
    Object.defineProperty(exports, "typeAheadQuery", {
      enumerable: true,
      get: function get() {
        return _typeAheadQuery.typeAheadQuery;
      }
    });
    Object.defineProperty(exports, "underline", {
      enumerable: true,
      get: function get() {
        return _underline.underline;
      }
    });
    Object.defineProperty(exports, "unsupportedMark", {
      enumerable: true,
      get: function get() {
        return _unsupportedMark.unsupportedMark;
      }
    });
    Object.defineProperty(exports, "unsupportedNodeAttribute", {
      enumerable: true,
      get: function get() {
        return _unsupportedNodeAttributes.unsupportedNodeAttribute;
      }
    });
    var _em = require_em();
    var _code = require_code();
    var _strike = require_strike();
    var _strong = require_strong();
    var _underline = require_underline();
    var _link = require_link();
    var _typeAheadQuery = require_type_ahead_query();
    var _subsup = require_subsup();
    var _textColor = require_text_color();
    var _confluenceInlineComment = require_confluence_inline_comment();
    var _breakout = require_breakout();
    var _alignment = require_alignment();
    var _indentation = require_indentation();
    var _annotation = require_annotation();
    var _unsupportedMark = require_unsupported_mark();
    var _unsupportedNodeAttributes = require_unsupported_node_attributes();
    var _dataConsumer = require_data_consumer();
    var _fragment = require_fragment();
    var _border = require_border2();
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/create-schema.js
var require_create_schema = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/create-schema.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allowCustomPanel = void 0;
    exports.createSchema = createSchema;
    exports.sanitizeNodeSpecContent = sanitizeNodeSpecContent;
    exports.sanitizeNodes = sanitizeNodes;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _prosemirrorModel = require_dist();
    var _groups = require_groups();
    var _marks = require_marks();
    var _nodes = require_nodes();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function addItems(builtInItems, config) {
      var customSpecs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!config) {
        return {};
      }
      var items = builtInItems.reduce(function(items2, _ref) {
        var name = _ref.name, spec = _ref.spec;
        if (config.indexOf(name) !== -1) {
          items2[name] = customSpecs[name] || spec;
        }
        return items2;
      }, {});
      return Object.keys(customSpecs).reduce(function(items2, name) {
        if (items2[name]) {
          return items2;
        }
        items2[name] = customSpecs[name];
        return items2;
      }, items);
    }
    function groupDeclaration(name) {
      return {
        name: "__".concat(name, "GroupDeclaration"),
        spec: {
          group: name
        }
      };
    }
    var markGroupDeclarations = [groupDeclaration(_groups.COLOR), groupDeclaration(_groups.FONT_STYLE), groupDeclaration(_groups.SEARCH_QUERY), groupDeclaration(_groups.LINK)];
    var markGroupDeclarationsNames = markGroupDeclarations.map(function(groupMark) {
      return groupMark.name;
    });
    var nodesInOrder = [{
      name: "doc",
      spec: _nodes.doc
    }, {
      name: "paragraph",
      spec: _nodes.paragraph
    }, {
      name: "text",
      spec: _nodes.text
    }, {
      name: "bulletList",
      spec: _nodes.bulletList
    }, {
      name: "orderedList",
      spec: _nodes.orderedListWithOrder
    }, {
      name: "listItem",
      spec: _nodes.listItem
    }, {
      name: "heading",
      spec: _nodes.heading
    }, {
      name: "blockquote",
      spec: _nodes.blockquote
    }, {
      name: "codeBlock",
      spec: _nodes.codeBlock
    }, {
      name: "panel",
      spec: (0, _nodes.panel)(true)
    }, {
      name: "rule",
      spec: _nodes.rule
    }, {
      name: "image",
      spec: _nodes.image
    }, {
      name: "mention",
      spec: _nodes.mention
    }, {
      name: "caption",
      spec: _nodes.caption
    }, {
      name: "media",
      spec: _nodes.media
    }, {
      name: "mediaGroup",
      spec: _nodes.mediaGroup
    }, {
      name: "mediaSingle",
      spec: _nodes.mediaSingleWithCaption
    }, {
      name: "mediaInline",
      spec: _nodes.mediaInline
    }, {
      name: "placeholder",
      spec: _nodes.placeholder
    }, {
      name: "layoutSection",
      spec: _nodes.layoutSection
    }, {
      name: "layoutColumn",
      spec: _nodes.layoutColumn
    }, {
      name: "hardBreak",
      spec: _nodes.hardBreak
    }, {
      name: "emoji",
      spec: _nodes.emoji
    }, {
      name: "table",
      spec: _nodes.table
    }, {
      name: "tableCell",
      spec: _nodes.tableCell
    }, {
      name: "tableRow",
      spec: _nodes.tableRow
    }, {
      name: "tableHeader",
      spec: _nodes.tableHeader
    }, {
      name: "confluenceJiraIssue",
      spec: _nodes.confluenceJiraIssue
    }, {
      name: "confluenceUnsupportedInline",
      spec: _nodes.confluenceUnsupportedInline
    }, {
      name: "confluenceUnsupportedBlock",
      spec: _nodes.confluenceUnsupportedBlock
    }, {
      name: "decisionList",
      spec: _nodes.decisionList
    }, {
      name: "decisionItem",
      spec: _nodes.decisionItem
    }, {
      name: "taskList",
      spec: _nodes.taskList
    }, {
      name: "taskItem",
      spec: _nodes.taskItem
    }, {
      name: "date",
      spec: _nodes.date
    }, {
      name: "status",
      spec: _nodes.status
    }, {
      name: "expand",
      spec: _nodes.expand
    }, {
      name: "nestedExpand",
      spec: _nodes.nestedExpand
    }, {
      name: "extension",
      spec: _nodes.extension
    }, {
      name: "inlineExtension",
      spec: _nodes.inlineExtension
    }, {
      name: "bodiedExtension",
      spec: _nodes.bodiedExtension
    }, {
      name: "inlineCard",
      spec: _nodes.inlineCard
    }, {
      name: "blockCard",
      spec: _nodes.blockCard
    }, {
      name: "embedCard",
      spec: _nodes.embedCard
    }, {
      name: "unknownBlock",
      spec: _nodes.unknownBlock
    }, {
      name: "unsupportedBlock",
      spec: _nodes.unsupportedBlock
    }, {
      name: "unsupportedInline",
      spec: _nodes.unsupportedInline
    }];
    var marksInOrder = [{
      name: "link",
      spec: _marks.link
    }, {
      name: "em",
      spec: _marks.em
    }, {
      name: "strong",
      spec: _marks.strong
    }, {
      name: "textColor",
      spec: _marks.textColor
    }, {
      name: "strike",
      spec: _marks.strike
    }, {
      name: "subsup",
      spec: _marks.subsup
    }, {
      name: "underline",
      spec: _marks.underline
    }, {
      name: "code",
      spec: _marks.code
    }, {
      name: "typeAheadQuery",
      spec: _marks.typeAheadQuery
    }, {
      name: "alignment",
      spec: _marks.alignment
    }, {
      name: "annotation",
      spec: _marks.annotation
    }, {
      name: "confluenceInlineComment",
      spec: _marks.confluenceInlineComment
    }].concat(markGroupDeclarations, [{
      name: "breakout",
      spec: _marks.breakout
    }, {
      name: "dataConsumer",
      spec: _marks.dataConsumer
    }, {
      name: "fragment",
      spec: _marks.fragment
    }, {
      name: "indentation",
      spec: _marks.indentation
    }, {
      name: "border",
      spec: _marks.border
    }, {
      name: "unsupportedMark",
      spec: _marks.unsupportedMark
    }, {
      name: "unsupportedNodeAttribute",
      spec: _marks.unsupportedNodeAttribute
    }]);
    function createSchema(config) {
      var customNodeSpecs = config.customNodeSpecs, customMarkSpecs = config.customMarkSpecs;
      var nodesConfig = Object.keys(customNodeSpecs || {}).concat(config.nodes);
      var marksConfig = Object.keys(customMarkSpecs || {}).concat(config.marks || []).concat(markGroupDeclarationsNames);
      var nodes = addItems(nodesInOrder, nodesConfig, customNodeSpecs);
      var marks = addItems(marksInOrder, marksConfig, customMarkSpecs);
      nodes = sanitizeNodes(nodes, marks);
      return new _prosemirrorModel.Schema({
        nodes,
        marks
      });
    }
    function sanitizeNodes(nodes, supportedMarks) {
      var nodeNames = Object.keys(nodes);
      nodeNames.forEach(function(nodeKey) {
        var nodeSpec = _objectSpread({}, nodes[nodeKey]);
        if (nodeSpec.marks && nodeSpec.marks !== "_") {
          nodeSpec.marks = nodeSpec.marks.split(" ").filter(function(mark) {
            return !!supportedMarks[mark];
          }).join(" ");
        }
        if (nodeSpec.content) {
          nodeSpec.content = sanitizeNodeSpecContent(nodes, nodeSpec.content);
        }
        nodes[nodeKey] = nodeSpec;
      });
      return nodes;
    }
    function sanitizeNodeSpecContent(nodes, rawContent) {
      var content = rawContent.replace(/\W/g, " ");
      var contentKeys = content.split(" ");
      var unsupportedContentKeys = contentKeys.filter(function(contentKey) {
        return !isContentSupported(nodes, contentKey);
      });
      return unsupportedContentKeys.reduce(function(newContent, nodeName) {
        return sanitizedContent(newContent, nodeName);
      }, rawContent);
    }
    function sanitizedContent(content, invalidContent) {
      if (!invalidContent.length) {
        return content || "";
      }
      if (!content || !content.match(/\w/)) {
        return "";
      }
      var pattern = "(".concat(invalidContent, "((\\s)*\\|)+)|((\\|(\\s)*)+").concat(invalidContent, ")|(").concat(invalidContent, "$)|(").concat(invalidContent, "(\\+|\\*))");
      return content.replace(new RegExp(pattern, "g"), "").replace("  ", " ").trim();
    }
    function isContentSupported(nodes, contentKey) {
      var nodeKeys = Object.keys(nodes);
      if (nodeKeys.indexOf(contentKey) > -1) {
        return true;
      }
      for (var supportedKey in nodes) {
        var nodeSpec = nodes[supportedKey];
        if (nodeSpec && nodeSpec.group === contentKey) {
          return true;
        }
      }
      return false;
    }
    var allowCustomPanel = true;
    exports.allowCustomPanel = allowCustomPanel;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/default-schema.js
var require_default_schema = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/default-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSchemaBasedOnStage = exports.defaultSchemaConfig = exports.defaultSchema = void 0;
    var _nodes = require_nodes();
    var _marks = require_marks();
    var _createSchema = require_create_schema();
    var getDefaultSchemaConfig = function getDefaultSchemaConfig2() {
      var defaultSchemaConfig2 = {
        nodes: ["doc", "paragraph", "text", "bulletList", "orderedList", "listItem", "heading", "blockquote", "codeBlock", "panel", "rule", "image", "caption", "mention", "media", "mediaGroup", "mediaSingle", "mediaInline", "confluenceUnsupportedBlock", "confluenceUnsupportedInline", "confluenceJiraIssue", "expand", "nestedExpand", "extension", "inlineExtension", "bodiedExtension", "hardBreak", "emoji", "table", "tableCell", "tableHeader", "tableRow", "decisionList", "decisionItem", "taskList", "taskItem", "unknownBlock", "date", "status", "placeholder", "layoutSection", "layoutColumn", "inlineCard", "blockCard", "embedCard", "unsupportedBlock", "unsupportedInline"],
        marks: [
          "link",
          "em",
          "strong",
          "strike",
          "subsup",
          "underline",
          "code",
          "textColor",
          "confluenceInlineComment",
          "breakout",
          "alignment",
          "indentation",
          "annotation",
          "dataConsumer",
          "unsupportedMark",
          "unsupportedNodeAttribute",
          "typeAheadQuery",
          // https://product-fabric.atlassian.net/browse/ED-10214,
          "fragment"
        ]
      };
      return defaultSchemaConfig2;
    };
    var defaultSchemaConfig = getDefaultSchemaConfig();
    exports.defaultSchemaConfig = defaultSchemaConfig;
    var getSchemaBasedOnStage = function getSchemaBasedOnStage2() {
      var stage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "final";
      var defaultSchemaConfig2 = getDefaultSchemaConfig();
      if (stage === "stage0") {
        defaultSchemaConfig2.customNodeSpecs = {
          layoutSection: _nodes.layoutSectionWithSingleColumn
        };
        defaultSchemaConfig2.customMarkSpecs = {
          border: _marks.border
        };
      }
      return (0, _createSchema.createSchema)(defaultSchemaConfig2);
    };
    exports.getSchemaBasedOnStage = getSchemaBasedOnStage;
    var defaultSchema = getSchemaBasedOnStage();
    exports.defaultSchema = defaultSchema;
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module2) {
    "use strict";
    module2.exports = require_entities();
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module2) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module2.exports = encode;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module2) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module2.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module2) {
    "use strict";
    module2.exports = function format(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module2) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module2.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module2) {
    "use strict";
    module2.exports.encode = require_encode();
    module2.exports.decode = require_decode();
    module2.exports.format = require_format();
    module2.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module2) {
    module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex();
    exports.Cc = require_regex2();
    exports.Cf = require_regex5();
    exports.P = require_regex4();
    exports.Z = require_regex3();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name) {
      var code = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex4();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(/ẞ/g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module2) {
    "use strict";
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkDestination(str, pos, max) {
      var code, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkTitle(str, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module2) {
    "use strict";
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module2.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module2) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module2) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module2) {
    "use strict";
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module2) {
    "use strict";
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module2) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module2.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module2) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      p: "\xA7",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module2) {
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.substr(0, index) + ch + str.substr(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module2) {
    "use strict";
    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module2.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module2.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.substr(pos, max - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code2 = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module2) {
    "use strict";
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module2) {
    "use strict";
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote2 = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module2) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module2) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading2 = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module2) {
    "use strict";
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph2 = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module2) {
    "use strict";
    module2.exports = function paragraph(state, startLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module2.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code2()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote2(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading2(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph2()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module2.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text3 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module2) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape(state, silent) {
      var ch, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module2) {
    "use strict";
    module2.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module2) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module2) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module2) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match = state.src.slice(pos).match(DIGITAL_RE);
          if (match) {
            if (!silent) {
              code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
              state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            }
            state.pos += match[0].length;
            return true;
          }
        } else {
          match = state.src.slice(pos).match(NAMED_RE);
          if (match) {
            if (has(entities, match[1])) {
              if (!silent) {
                state.pending += entities[match[1]];
              }
              state.pos += match[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module2) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/text_collapse.js
var require_text_collapse = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module2) {
    "use strict";
    module2.exports = function text_collapse(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module2.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text3()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link2()],
      ["image", require_image2()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module2.exports = ParserInline;
  }
});

// node_modules/markdown-it/node_modules/linkify-it/lib/re.js
var require_re2 = __commonJS({
  "node_modules/markdown-it/node_modules/linkify-it/lib/re.js"(exports, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex().source;
      re.src_Cc = require_regex2().source;
      re.src_Z = require_regex3().source;
      re.src_P = require_regex4().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/markdown-it/node_modules/linkify-it/index.js
var require_linkify_it2 = __commonJS({
  "node_modules/markdown-it/node_modules/linkify-it/index.js"(exports, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re2()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it2();
    var mdurl = require_mdurl();
    var punycode = require("punycode");
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args2 = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args2);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// node_modules/markdown-it-table/dist/cjs/table.js
var require_table2 = __commonJS({
  "node_modules/markdown-it-table/dist/cjs/table.js"(exports, module2) {
    "use strict";
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];
      return state.src.substr(pos, max - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, escapes = 0, lastPos = 0, backTicked = false, lastBackTick = 0;
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 96) {
          if (backTicked) {
            backTicked = false;
            lastBackTick = pos;
          } else if (escapes % 2 === 0) {
            backTicked = true;
            lastBackTick = pos;
          }
        } else if (ch === 124 && escapes % 2 === 0 && !backTicked) {
          result.push(str.substring(lastPos, pos));
          lastPos = pos + 1;
        }
        if (ch === 92) {
          escapes++;
        } else {
          escapes = 0;
        }
        pos++;
        if (pos === max && backTicked) {
          backTicked = false;
          pos = lastBackTick + 1;
        }
        ch = str.charCodeAt(pos);
      }
      result.push(str.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch !== 124 && ch !== 45 && ch !== 58) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText.replace(/^\||\|$/g, ""));
      columnCount = columns.length;
      if (columnCount > aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        token.map = [startLine, startLine + 1];
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("paragraph_open", "p", 1);
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.map = [startLine, startLine + 1];
        token.children = [];
        token = state.push("paragraph_close", "p", -1);
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token.map = tbodyLines = [startLine + 2, 0];
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (lineText.indexOf("|") === -1) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText.replace(/^\||\|$/g, ""));
        token = state.push("tr_open", "tr", 1);
        for (var _i = 0, offset = 1; _i < columns.length; _i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[_i]) {
            token.attrs = [["style", "text-align:" + aligns[_i]]];
          }
          var shift = columns[_i][0] === " " || /^(\d+\.|\*|-)$/.test(columns[_i].trim()) ? 1 : 0;
          state.bMarks[nextLine] += offset + shift;
          offset = (columns[_i] || "").length + (shift ? 0 : 1);
          state.eMarks[nextLine] = state.bMarks[nextLine] + offset - 1;
          state.lineMax = 1;
          state.md.block.tokenize(state, nextLine, nextLine + 1);
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = tbodyLines[1] = nextLine;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it-table/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/markdown-it-table/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.markdownItTable = void 0;
    var _table = require_table2();
    var _table2 = _interopRequireDefault(_table);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var markdownItTable = exports.markdownItTable = function markdownItTable2(md, options) {
      md.block.ruler.before("paragraph", "table", _table2.default, {
        alt: ["paragraph", "reference"]
      });
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/entities/lib/maps/entities.json
var require_entities3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/entities.js
var require_entities4 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/entities.js"(exports, module2) {
    "use strict";
    module2.exports = require_entities3();
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/utils.js
var require_utils2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities4();
    function replaceEntityPattern(match, name) {
      var code = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex4();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(/ẞ/g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module2) {
    "use strict";
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils2().unescapeAll;
    module2.exports = function parseLinkDestination(str, pos, max) {
      var code, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils2().unescapeAll;
    module2.exports = function parseLinkTitle(str, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/index.js
var require_helpers2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label2();
    exports.parseLinkDestination = require_parse_link_destination2();
    exports.parseLinkTitle = require_parse_link_title2();
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/renderer.js
var require_renderer2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/renderer.js"(exports, module2) {
    "use strict";
    var assign = require_utils2().assign;
    var unescapeAll = require_utils2().unescapeAll;
    var escapeHtml = require_utils2().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module2.exports = Renderer;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/ruler.js
var require_ruler2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/ruler.js"(exports, module2) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module2) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/block.js
var require_block2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/block.js"(exports, module2) {
    "use strict";
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/inline.js
var require_inline2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/inline.js"(exports, module2) {
    "use strict";
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module2) {
    "use strict";
    var arrayReplaceAt = require_utils2().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module2.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module2) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module2) {
    "use strict";
    var isWhiteSpace = require_utils2().isWhiteSpace;
    var isPunctChar = require_utils2().isPunctChar;
    var isMdAsciiPunct = require_utils2().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/text_join.js"(exports, module2) {
    "use strict";
    module2.exports = function text_join(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/token.js
var require_token2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/token.js"(exports, module2) {
    "use strict";
    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module2) {
    "use strict";
    var Token = require_token2();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module2.exports = StateCore;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_core.js
var require_parser_core2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_core.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler2();
    var _rules = [
      ["normalize", require_normalize2()],
      ["block", require_block2()],
      ["inline", require_inline2()],
      ["linkify", require_linkify2()],
      ["replacements", require_replacements2()],
      ["smartquotes", require_smartquotes2()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core2();
    module2.exports = Core;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/table.js
var require_table3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/table.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/code.js
var require_code3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/code.js"(exports, module2) {
    "use strict";
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/fence.js
var require_fence2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/fence.js"(exports, module2) {
    "use strict";
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/hr.js
var require_hr2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/hr.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/list.js
var require_list2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/list.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/reference.js
var require_reference2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/reference.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils2().normalizeReference;
    var isSpace = require_utils2().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_blocks.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_re.js
var require_html_re2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_re.js"(exports, module2) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module2) {
    "use strict";
    var block_names = require_html_blocks2();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re2().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/heading.js
var require_heading3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/heading.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module2) {
    "use strict";
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module2) {
    "use strict";
    module2.exports = function paragraph(state, startLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module2) {
    "use strict";
    var Token = require_token2();
    var isSpace = require_utils2().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module2.exports = StateBlock;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_block.js
var require_parser_block2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_block.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler2();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table3(), ["paragraph", "reference"]],
      ["code", require_code3()],
      ["fence", require_fence2(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote3(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr2(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list2(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference2()],
      ["html_block", require_html_block2(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading3(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading2()],
      ["paragraph", require_paragraph3()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block2();
    module2.exports = ParserBlock;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/text.js
var require_text4 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/text.js"(exports, module2) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/linkify.js"(exports, module2) {
    "use strict";
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module2.exports = function linkify(state, silent) {
      var pos, max, match, proto, link, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link)
        return false;
      url = link.url;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils2().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module2) {
    "use strict";
    module2.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/link.js
var require_link3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/link.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils2().normalizeReference;
    var isSpace = require_utils2().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/image.js
var require_image3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/image.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils2().normalizeReference;
    var isSpace = require_utils2().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module2) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module2) {
    "use strict";
    var HTML_TAG_RE = require_html_re2().HTML_TAG_RE;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module2) {
    "use strict";
    var entities = require_entities4();
    var has = require_utils2().has;
    var isValidEntityCode = require_utils2().isValidEntityCode;
    var fromCodePoint = require_utils2().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match[1]];
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module2) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports, module2) {
    "use strict";
    module2.exports = function fragments_join(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module2) {
    "use strict";
    var Token = require_token2();
    var isWhiteSpace = require_utils2().isWhiteSpace;
    var isPunctChar = require_utils2().isPunctChar;
    var isMdAsciiPunct = require_utils2().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module2.exports = StateInline;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_inline.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler2();
    var _rules = [
      ["text", require_text4()],
      ["linkify", require_linkify3()],
      ["newline", require_newline2()],
      ["escape", require_escape2()],
      ["backticks", require_backticks2()],
      ["strikethrough", require_strikethrough2().tokenize],
      ["emphasis", require_emphasis2().tokenize],
      ["link", require_link3()],
      ["image", require_image3()],
      ["autolink", require_autolink2()],
      ["html_inline", require_html_inline2()],
      ["entity", require_entity2()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs2()],
      ["strikethrough", require_strikethrough2().postProcess],
      ["emphasis", require_emphasis2().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline2();
    module2.exports = ParserInline;
  }
});

// node_modules/prosemirror-markdown/node_modules/linkify-it/lib/re.js
var require_re3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/linkify-it/lib/re.js"(exports, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex().source;
      re.src_Cc = require_regex2().source;
      re.src_Z = require_regex3().source;
      re.src_P = require_regex4().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/linkify-it/index.js
var require_linkify_it3 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/linkify-it/index.js"(exports, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re3()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/default.js
var require_default2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/default.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/zero.js
var require_zero2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/zero.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/commonmark.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/lib/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var helpers = require_helpers2();
    var Renderer = require_renderer2();
    var ParserCore = require_parser_core2();
    var ParserBlock = require_parser_block2();
    var ParserInline = require_parser_inline2();
    var LinkifyIt = require_linkify_it3();
    var mdurl = require_mdurl();
    var punycode = require("punycode");
    var config = {
      default: require_default2(),
      zero: require_zero2(),
      commonmark: require_commonmark2()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args2 = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args2);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt;
  }
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/index.js
var require_markdown_it2 = __commonJS({
  "node_modules/prosemirror-markdown/node_modules/markdown-it/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib2();
  }
});

// node_modules/prosemirror-markdown/dist/index.cjs
var require_dist3 = __commonJS({
  "node_modules/prosemirror-markdown/dist/index.cjs"(exports) {
    "use strict";
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var prosemirrorModel = require_dist();
    var markdownit = require_markdown_it2();
    function _interopDefaultLegacy(e) {
      return e && _typeof(e) === "object" && "default" in e ? e : {
        "default": e
      };
    }
    var markdownit__default = _interopDefaultLegacy(markdownit);
    var schema = new prosemirrorModel.Schema({
      nodes: {
        doc: {
          content: "block+"
        },
        paragraph: {
          content: "inline*",
          group: "block",
          parseDOM: [{
            tag: "p"
          }],
          toDOM: function toDOM() {
            return ["p", 0];
          }
        },
        blockquote: {
          content: "block+",
          group: "block",
          parseDOM: [{
            tag: "blockquote"
          }],
          toDOM: function toDOM() {
            return ["blockquote", 0];
          }
        },
        horizontal_rule: {
          group: "block",
          parseDOM: [{
            tag: "hr"
          }],
          toDOM: function toDOM() {
            return ["div", ["hr"]];
          }
        },
        heading: {
          attrs: {
            level: {
              "default": 1
            }
          },
          content: "(text | image)*",
          group: "block",
          defining: true,
          parseDOM: [{
            tag: "h1",
            attrs: {
              level: 1
            }
          }, {
            tag: "h2",
            attrs: {
              level: 2
            }
          }, {
            tag: "h3",
            attrs: {
              level: 3
            }
          }, {
            tag: "h4",
            attrs: {
              level: 4
            }
          }, {
            tag: "h5",
            attrs: {
              level: 5
            }
          }, {
            tag: "h6",
            attrs: {
              level: 6
            }
          }],
          toDOM: function toDOM(node) {
            return ["h" + node.attrs.level, 0];
          }
        },
        code_block: {
          content: "text*",
          group: "block",
          code: true,
          defining: true,
          marks: "",
          attrs: {
            params: {
              "default": ""
            }
          },
          parseDOM: [{
            tag: "pre",
            preserveWhitespace: "full",
            getAttrs: function getAttrs(node) {
              return {
                params: node.getAttribute("data-params") || ""
              };
            }
          }],
          toDOM: function toDOM(node) {
            return ["pre", node.attrs.params ? {
              "data-params": node.attrs.params
            } : {}, ["code", 0]];
          }
        },
        ordered_list: {
          content: "list_item+",
          group: "block",
          attrs: {
            order: {
              "default": 1
            },
            tight: {
              "default": false
            }
          },
          parseDOM: [{
            tag: "ol",
            getAttrs: function getAttrs(dom) {
              return {
                order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1,
                tight: dom.hasAttribute("data-tight")
              };
            }
          }],
          toDOM: function toDOM(node) {
            return ["ol", {
              start: node.attrs.order == 1 ? null : node.attrs.order,
              "data-tight": node.attrs.tight ? "true" : null
            }, 0];
          }
        },
        bullet_list: {
          content: "list_item+",
          group: "block",
          attrs: {
            tight: {
              "default": false
            }
          },
          parseDOM: [{
            tag: "ul",
            getAttrs: function getAttrs(dom) {
              return {
                tight: dom.hasAttribute("data-tight")
              };
            }
          }],
          toDOM: function toDOM(node) {
            return ["ul", {
              "data-tight": node.attrs.tight ? "true" : null
            }, 0];
          }
        },
        list_item: {
          content: "paragraph block*",
          defining: true,
          parseDOM: [{
            tag: "li"
          }],
          toDOM: function toDOM() {
            return ["li", 0];
          }
        },
        text: {
          group: "inline"
        },
        image: {
          inline: true,
          attrs: {
            src: {},
            alt: {
              "default": null
            },
            title: {
              "default": null
            }
          },
          group: "inline",
          draggable: true,
          parseDOM: [{
            tag: "img[src]",
            getAttrs: function getAttrs(dom) {
              return {
                src: dom.getAttribute("src"),
                title: dom.getAttribute("title"),
                alt: dom.getAttribute("alt")
              };
            }
          }],
          toDOM: function toDOM(node) {
            return ["img", node.attrs];
          }
        },
        hard_break: {
          inline: true,
          group: "inline",
          selectable: false,
          parseDOM: [{
            tag: "br"
          }],
          toDOM: function toDOM() {
            return ["br"];
          }
        }
      },
      marks: {
        em: {
          parseDOM: [{
            tag: "i"
          }, {
            tag: "em"
          }, {
            style: "font-style",
            getAttrs: function getAttrs(value) {
              return value == "italic" && null;
            }
          }],
          toDOM: function toDOM() {
            return ["em"];
          }
        },
        strong: {
          parseDOM: [{
            tag: "b"
          }, {
            tag: "strong"
          }, {
            style: "font-weight",
            getAttrs: function getAttrs(value) {
              return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
            }
          }],
          toDOM: function toDOM() {
            return ["strong"];
          }
        },
        link: {
          attrs: {
            href: {},
            title: {
              "default": null
            }
          },
          inclusive: false,
          parseDOM: [{
            tag: "a[href]",
            getAttrs: function getAttrs(dom) {
              return {
                href: dom.getAttribute("href"),
                title: dom.getAttribute("title")
              };
            }
          }],
          toDOM: function toDOM(node) {
            return ["a", node.attrs];
          }
        },
        code: {
          parseDOM: [{
            tag: "code"
          }],
          toDOM: function toDOM() {
            return ["code"];
          }
        }
      }
    });
    function maybeMerge(a, b) {
      if (a.isText && b.isText && prosemirrorModel.Mark.sameSet(a.marks, b.marks))
        return a.withText(a.text + b.text);
    }
    var MarkdownParseState = function() {
      function MarkdownParseState2(schema2, tokenHandlers2) {
        _classCallCheck(this, MarkdownParseState2);
        this.schema = schema2;
        this.tokenHandlers = tokenHandlers2;
        this.stack = [{
          type: schema2.topNodeType,
          attrs: null,
          content: [],
          marks: prosemirrorModel.Mark.none
        }];
      }
      _createClass(MarkdownParseState2, [{
        key: "top",
        value: function top() {
          return this.stack[this.stack.length - 1];
        }
      }, {
        key: "push",
        value: function push(elt) {
          if (this.stack.length)
            this.top().content.push(elt);
        }
      }, {
        key: "addText",
        value: function addText(text) {
          if (!text)
            return;
          var top = this.top(), nodes = top.content, last = nodes[nodes.length - 1];
          var node = this.schema.text(text, top.marks), merged;
          if (last && (merged = maybeMerge(last, node)))
            nodes[nodes.length - 1] = merged;
          else
            nodes.push(node);
        }
      }, {
        key: "openMark",
        value: function openMark(mark) {
          var top = this.top();
          top.marks = mark.addToSet(top.marks);
        }
      }, {
        key: "closeMark",
        value: function closeMark(mark) {
          var top = this.top();
          top.marks = mark.removeFromSet(top.marks);
        }
      }, {
        key: "parseTokens",
        value: function parseTokens(toks) {
          for (var i = 0; i < toks.length; i++) {
            var tok = toks[i];
            var handler = this.tokenHandlers[tok.type];
            if (!handler)
              throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
            handler(this, tok, toks, i);
          }
        }
      }, {
        key: "addNode",
        value: function addNode(type, attrs2, content) {
          var top = this.top();
          var node = type.createAndFill(attrs2, content, top ? top.marks : []);
          if (!node)
            return null;
          this.push(node);
          return node;
        }
      }, {
        key: "openNode",
        value: function openNode(type, attrs2) {
          this.stack.push({
            type,
            attrs: attrs2,
            content: [],
            marks: prosemirrorModel.Mark.none
          });
        }
      }, {
        key: "closeNode",
        value: function closeNode() {
          var info = this.stack.pop();
          return this.addNode(info.type, info.attrs, info.content);
        }
      }]);
      return MarkdownParseState2;
    }();
    function attrs(spec, token, tokens, i) {
      if (spec.getAttrs)
        return spec.getAttrs(token, tokens, i);
      else if (spec.attrs instanceof Function)
        return spec.attrs(token);
      else
        return spec.attrs;
    }
    function noCloseToken(spec, type) {
      return spec.noCloseToken || type == "code_inline" || type == "code_block" || type == "fence";
    }
    function withoutTrailingNewline(str) {
      return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
    }
    function noOp() {
    }
    function tokenHandlers(schema2, tokens) {
      var handlers = /* @__PURE__ */ Object.create(null);
      var _loop = function _loop2(type2) {
        var spec = tokens[type2];
        if (spec.block) {
          var nodeType = schema2.nodeType(spec.block);
          if (noCloseToken(spec, type2)) {
            handlers[type2] = function(state, tok, tokens2, i) {
              state.openNode(nodeType, attrs(spec, tok, tokens2, i));
              state.addText(withoutTrailingNewline(tok.content));
              state.closeNode();
            };
          } else {
            handlers[type2 + "_open"] = function(state, tok, tokens2, i) {
              return state.openNode(nodeType, attrs(spec, tok, tokens2, i));
            };
            handlers[type2 + "_close"] = function(state) {
              return state.closeNode();
            };
          }
        } else if (spec.node) {
          var _nodeType = schema2.nodeType(spec.node);
          handlers[type2] = function(state, tok, tokens2, i) {
            return state.addNode(_nodeType, attrs(spec, tok, tokens2, i));
          };
        } else if (spec.mark) {
          var markType = schema2.marks[spec.mark];
          if (noCloseToken(spec, type2)) {
            handlers[type2] = function(state, tok, tokens2, i) {
              state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
              state.addText(withoutTrailingNewline(tok.content));
              state.closeMark(markType);
            };
          } else {
            handlers[type2 + "_open"] = function(state, tok, tokens2, i) {
              return state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
            };
            handlers[type2 + "_close"] = function(state) {
              return state.closeMark(markType);
            };
          }
        } else if (spec.ignore) {
          if (noCloseToken(spec, type2)) {
            handlers[type2] = noOp;
          } else {
            handlers[type2 + "_open"] = noOp;
            handlers[type2 + "_close"] = noOp;
          }
        } else {
          throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
        }
      };
      for (var type in tokens) {
        _loop(type);
      }
      handlers.text = function(state, tok) {
        return state.addText(tok.content);
      };
      handlers.inline = function(state, tok) {
        return state.parseTokens(tok.children);
      };
      handlers.softbreak = handlers.softbreak || function(state) {
        return state.addText("\n");
      };
      return handlers;
    }
    var MarkdownParser = function() {
      function MarkdownParser2(schema2, tokenizer, tokens) {
        _classCallCheck(this, MarkdownParser2);
        this.schema = schema2;
        this.tokenizer = tokenizer;
        this.tokens = tokens;
        this.tokenHandlers = tokenHandlers(schema2, tokens);
      }
      _createClass(MarkdownParser2, [{
        key: "parse",
        value: function parse(text) {
          var markdownEnv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var state = new MarkdownParseState(this.schema, this.tokenHandlers), doc;
          state.parseTokens(this.tokenizer.parse(text, markdownEnv));
          do {
            doc = state.closeNode();
          } while (state.stack.length);
          return doc || this.schema.topNodeType.createAndFill();
        }
      }]);
      return MarkdownParser2;
    }();
    function listIsTight(tokens, i) {
      while (++i < tokens.length) {
        if (tokens[i].type != "list_item_open")
          return tokens[i].hidden;
      }
      return false;
    }
    var defaultMarkdownParser = new MarkdownParser(schema, markdownit__default["default"]("commonmark", {
      html: false
    }), {
      blockquote: {
        block: "blockquote"
      },
      paragraph: {
        block: "paragraph"
      },
      list_item: {
        block: "list_item"
      },
      bullet_list: {
        block: "bullet_list",
        getAttrs: function getAttrs(_, tokens, i) {
          return {
            tight: listIsTight(tokens, i)
          };
        }
      },
      ordered_list: {
        block: "ordered_list",
        getAttrs: function getAttrs(tok, tokens, i) {
          return {
            order: +tok.attrGet("start") || 1,
            tight: listIsTight(tokens, i)
          };
        }
      },
      heading: {
        block: "heading",
        getAttrs: function getAttrs(tok) {
          return {
            level: +tok.tag.slice(1)
          };
        }
      },
      code_block: {
        block: "code_block",
        noCloseToken: true
      },
      fence: {
        block: "code_block",
        getAttrs: function getAttrs(tok) {
          return {
            params: tok.info || ""
          };
        },
        noCloseToken: true
      },
      hr: {
        node: "horizontal_rule"
      },
      image: {
        node: "image",
        getAttrs: function getAttrs(tok) {
          return {
            src: tok.attrGet("src"),
            title: tok.attrGet("title") || null,
            alt: tok.children[0] && tok.children[0].content || null
          };
        }
      },
      hardbreak: {
        node: "hard_break"
      },
      em: {
        mark: "em"
      },
      strong: {
        mark: "strong"
      },
      link: {
        mark: "link",
        getAttrs: function getAttrs(tok) {
          return {
            href: tok.attrGet("href"),
            title: tok.attrGet("title") || null
          };
        }
      },
      code_inline: {
        mark: "code",
        noCloseToken: true
      }
    });
    var MarkdownSerializer = function() {
      function MarkdownSerializer2(nodes, marks) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        _classCallCheck(this, MarkdownSerializer2);
        this.nodes = nodes;
        this.marks = marks;
        this.options = options;
      }
      _createClass(MarkdownSerializer2, [{
        key: "serialize",
        value: function serialize(content) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          options = Object.assign(this.options, options);
          var state = new MarkdownSerializerState(this.nodes, this.marks, options);
          state.renderContent(content);
          return state.out;
        }
      }]);
      return MarkdownSerializer2;
    }();
    var defaultMarkdownSerializer = new MarkdownSerializer({
      blockquote: function blockquote(state, node) {
        state.wrapBlock("> ", null, node, function() {
          return state.renderContent(node);
        });
      },
      code_block: function code_block(state, node) {
        var backticks = node.textContent.match(/`{3,}/gm);
        var fence = backticks ? backticks.sort().slice(-1)[0] + "`" : "```";
        state.write(fence + (node.attrs.params || "") + "\n");
        state.text(node.textContent, false);
        state.ensureNewLine();
        state.write(fence);
        state.closeBlock(node);
      },
      heading: function heading(state, node) {
        state.write(state.repeat("#", node.attrs.level) + " ");
        state.renderInline(node);
        state.closeBlock(node);
      },
      horizontal_rule: function horizontal_rule(state, node) {
        state.write(node.attrs.markup || "---");
        state.closeBlock(node);
      },
      bullet_list: function bullet_list(state, node) {
        state.renderList(node, "  ", function() {
          return (node.attrs.bullet || "*") + " ";
        });
      },
      ordered_list: function ordered_list(state, node) {
        var start = node.attrs.order || 1;
        var maxW = String(start + node.childCount - 1).length;
        var space = state.repeat(" ", maxW + 2);
        state.renderList(node, space, function(i) {
          var nStr = String(start + i);
          return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
        });
      },
      list_item: function list_item(state, node) {
        state.renderContent(node);
      },
      paragraph: function paragraph(state, node) {
        state.renderInline(node);
        state.closeBlock(node);
      },
      image: function image(state, node) {
        state.write("![" + state.esc(node.attrs.alt || "") + "](" + node.attrs.src.replace(/[\(\)]/g, "\\$&") + (node.attrs.title ? ' "' + node.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
      },
      hard_break: function hard_break(state, node, parent, index) {
        for (var i = index + 1; i < parent.childCount; i++) {
          if (parent.child(i).type != node.type) {
            state.write("\\\n");
            return;
          }
        }
      },
      text: function text(state, node) {
        state.text(node.text, !state.inAutolink);
      }
    }, {
      em: {
        open: "*",
        close: "*",
        mixable: true,
        expelEnclosingWhitespace: true
      },
      strong: {
        open: "**",
        close: "**",
        mixable: true,
        expelEnclosingWhitespace: true
      },
      link: {
        open: function open(state, mark, parent, index) {
          state.inAutolink = isPlainURL(mark, parent, index);
          return state.inAutolink ? "<" : "[";
        },
        close: function close(state, mark, parent, index) {
          var inAutolink = state.inAutolink;
          state.inAutolink = void 0;
          return inAutolink ? ">" : "](" + mark.attrs.href.replace(/[\(\)"]/g, "\\$&") + (mark.attrs.title ? ' "'.concat(mark.attrs.title.replace(/"/g, '\\"'), '"') : "") + ")";
        },
        mixable: true
      },
      code: {
        open: function open(_state, _mark, parent, index) {
          return backticksFor(parent.child(index), -1);
        },
        close: function close(_state, _mark, parent, index) {
          return backticksFor(parent.child(index - 1), 1);
        },
        escape: false
      }
    });
    function backticksFor(node, side) {
      var ticks = /`+/g, m, len = 0;
      if (node.isText)
        while (m = ticks.exec(node.text)) {
          len = Math.max(len, m[0].length);
        }
      var result = len > 0 && side > 0 ? " `" : "`";
      for (var i = 0; i < len; i++) {
        result += "`";
      }
      if (len > 0 && side < 0)
        result += " ";
      return result;
    }
    function isPlainURL(link, parent, index) {
      if (link.attrs.title || !/^\w+:/.test(link.attrs.href))
        return false;
      var content = parent.child(index);
      if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link)
        return false;
      return index == parent.childCount - 1 || !link.isInSet(parent.child(index + 1).marks);
    }
    var MarkdownSerializerState = function() {
      function MarkdownSerializerState2(nodes, marks, options) {
        _classCallCheck(this, MarkdownSerializerState2);
        this.nodes = nodes;
        this.marks = marks;
        this.options = options;
        this.delim = "";
        this.out = "";
        this.closed = null;
        this.inAutolink = void 0;
        this.atBlockStart = false;
        this.inTightList = false;
        if (typeof this.options.tightLists == "undefined")
          this.options.tightLists = false;
      }
      _createClass(MarkdownSerializerState2, [{
        key: "flushClose",
        value: function flushClose() {
          var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
          if (this.closed) {
            if (!this.atBlank())
              this.out += "\n";
            if (size > 1) {
              var delimMin = this.delim;
              var trim = /\s+$/.exec(delimMin);
              if (trim)
                delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
              for (var i = 1; i < size; i++) {
                this.out += delimMin + "\n";
              }
            }
            this.closed = null;
          }
        }
      }, {
        key: "wrapBlock",
        value: function wrapBlock(delim, firstDelim, node, f) {
          var old = this.delim;
          this.write(firstDelim != null ? firstDelim : delim);
          this.delim += delim;
          f();
          this.delim = old;
          this.closeBlock(node);
        }
      }, {
        key: "atBlank",
        value: function atBlank() {
          return /(^|\n)$/.test(this.out);
        }
      }, {
        key: "ensureNewLine",
        value: function ensureNewLine() {
          if (!this.atBlank())
            this.out += "\n";
        }
      }, {
        key: "write",
        value: function write(content) {
          this.flushClose();
          if (this.delim && this.atBlank())
            this.out += this.delim;
          if (content)
            this.out += content;
        }
      }, {
        key: "closeBlock",
        value: function closeBlock(node) {
          this.closed = node;
        }
      }, {
        key: "text",
        value: function text(_text) {
          var escape = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var lines = _text.split("\n");
          for (var i = 0; i < lines.length; i++) {
            this.write();
            if (!escape && lines[i][0] == "[" && /(^|[^\\])\!$/.test(this.out))
              this.out = this.out.slice(0, this.out.length - 1) + "\\!";
            this.out += escape ? this.esc(lines[i], this.atBlockStart) : lines[i];
            if (i != lines.length - 1)
              this.out += "\n";
          }
        }
      }, {
        key: "render",
        value: function render(node, parent, index) {
          if (typeof parent == "number")
            throw new Error("!");
          if (!this.nodes[node.type.name])
            throw new Error("Token type `" + node.type.name + "` not supported by Markdown renderer");
          this.nodes[node.type.name](this, node, parent, index);
        }
      }, {
        key: "renderContent",
        value: function renderContent(parent) {
          var _this = this;
          parent.forEach(function(node, _, i) {
            return _this.render(node, parent, i);
          });
        }
      }, {
        key: "renderInline",
        value: function renderInline(parent) {
          var _this2 = this;
          this.atBlockStart = true;
          var active = [], trailing = "";
          var progress = function progress2(node, offset, index) {
            var marks = node ? node.marks : [];
            if (node && node.type.name === "hard_break")
              marks = marks.filter(function(m) {
                if (index + 1 == parent.childCount)
                  return false;
                var next = parent.child(index + 1);
                return m.isInSet(next.marks) && (!next.isText || /\S/.test(next.text));
              });
            var leading = trailing;
            trailing = "";
            if (node && node.isText && marks.some(function(mark2) {
              var info = _this2.marks[mark2.type.name];
              return info && info.expelEnclosingWhitespace && !(mark2.isInSet(active) || index < parent.childCount - 1 && mark2.isInSet(parent.child(index + 1).marks));
            })) {
              var _$exec = /^(\s*)(.*?)(\s*)$/m.exec(node.text), _$exec2 = _slicedToArray(_$exec, 4), _ = _$exec2[0], lead = _$exec2[1], _inner = _$exec2[2], trail = _$exec2[3];
              leading += lead;
              trailing = trail;
              if (lead || trail) {
                node = _inner ? node.withText(_inner) : null;
                if (!node)
                  marks = active;
              }
            }
            var inner = marks.length ? marks[marks.length - 1] : null;
            var noEsc = inner && _this2.marks[inner.type.name].escape === false;
            var len = marks.length - (noEsc ? 1 : 0);
            outer:
              for (var i = 0; i < len; i++) {
                var mark = marks[i];
                if (!_this2.marks[mark.type.name].mixable)
                  break;
                for (var j = 0; j < active.length; j++) {
                  var other = active[j];
                  if (!_this2.marks[other.type.name].mixable)
                    break;
                  if (mark.eq(other)) {
                    if (i > j)
                      marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));
                    else if (j > i)
                      marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));
                    continue outer;
                  }
                }
              }
            var keep = 0;
            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {
              ++keep;
            }
            while (keep < active.length) {
              _this2.text(_this2.markString(active.pop(), false, parent, index), false);
            }
            if (leading)
              _this2.text(leading);
            if (node) {
              while (active.length < len) {
                var add = marks[active.length];
                active.push(add);
                _this2.text(_this2.markString(add, true, parent, index), false);
              }
              if (noEsc && node.isText)
                _this2.text(_this2.markString(inner, true, parent, index) + node.text + _this2.markString(inner, false, parent, index + 1), false);
              else
                _this2.render(node, parent, index);
            }
          };
          parent.forEach(progress);
          progress(null, 0, parent.childCount);
          this.atBlockStart = false;
        }
      }, {
        key: "renderList",
        value: function renderList(node, delim, firstDelim) {
          var _this3 = this;
          if (this.closed && this.closed.type == node.type)
            this.flushClose(3);
          else if (this.inTightList)
            this.flushClose(1);
          var isTight = typeof node.attrs.tight != "undefined" ? node.attrs.tight : this.options.tightLists;
          var prevTight = this.inTightList;
          this.inTightList = isTight;
          node.forEach(function(child, _, i) {
            if (i && isTight)
              _this3.flushClose(1);
            _this3.wrapBlock(delim, firstDelim(i), node, function() {
              return _this3.render(child, node, i);
            });
          });
          this.inTightList = prevTight;
        }
      }, {
        key: "esc",
        value: function esc(str) {
          var startOfLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          str = str.replace(/[`*\\~\[\]_]/g, function(m, i) {
            return m == "_" && i > 0 && i + 1 < str.length && str[i - 1].match(/\w/) && str[i + 1].match(/\w/) ? m : "\\" + m;
          });
          if (startOfLine)
            str = str.replace(/^[#\-*+>]/, "\\$&").replace(/^(\s*\d+)\./, "$1\\.");
          if (this.options.escapeExtraCharacters)
            str = str.replace(this.options.escapeExtraCharacters, "\\$&");
          return str;
        }
      }, {
        key: "quote",
        value: function quote(str) {
          var wrap = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
          return wrap[0] + str + wrap[1];
        }
      }, {
        key: "repeat",
        value: function repeat(str, n) {
          var out = "";
          for (var i = 0; i < n; i++) {
            out += str;
          }
          return out;
        }
      }, {
        key: "markString",
        value: function markString(mark, open, parent, index) {
          var info = this.marks[mark.type.name];
          var value = open ? info.open : info.close;
          return typeof value == "string" ? value : value(this, mark, parent, index);
        }
      }, {
        key: "getEnclosingWhitespace",
        value: function getEnclosingWhitespace(text) {
          return {
            leading: (text.match(/^(\s+)/) || [void 0])[0],
            trailing: (text.match(/(\s+)$/) || [void 0])[0]
          };
        }
      }]);
      return MarkdownSerializerState2;
    }();
    exports.MarkdownParser = MarkdownParser;
    exports.MarkdownSerializer = MarkdownSerializer;
    exports.MarkdownSerializerState = MarkdownSerializerState;
    exports.defaultMarkdownParser = defaultMarkdownParser;
    exports.defaultMarkdownSerializer = defaultMarkdownSerializer;
    exports.schema = schema;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/dist/cjs/media.js
var require_media2 = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/dist/cjs/media.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.markdownItMedia = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    function createRule() {
      var regx = /!\[[^\]]*\]\([^)]+\)/g;
      var validParentTokens = ["th_open", "td_open", "list_item_open"];
      return function media(State) {
        var getUrl = function getUrl2(str) {
          var res = State.md.helpers.parseLinkDestination(str, str.indexOf("(") + 1, str.length);
          if (res.ok) {
            var href = State.md.normalizeLink(res.str);
            if (State.md.validateLink(href)) {
              return href;
            }
          }
          return "";
        };
        var createMediaTokens = function createMediaTokens2(url) {
          var mediaSingleOpen = new State.Token("media_single_open", "", 1);
          var media2 = new State.Token("media", "", 0);
          media2.attrs = [["url", getUrl(url)], ["type", "external"]];
          var mediaSingleClose = new State.Token("media_single_close", "", -1);
          return [mediaSingleOpen, media2, mediaSingleClose];
        };
        var createInlineTokens = function createInlineTokens2(str, openingTokens, closingTokens) {
          if (!str || str.length === 0) {
            return [];
          }
          var inlineBefore = new State.Token("inline", "", 1);
          inlineBefore.content = str;
          inlineBefore.children = [];
          return [].concat((0, _toConsumableArray2.default)(openingTokens), [inlineBefore], (0, _toConsumableArray2.default)(closingTokens));
        };
        var processedTokens = [];
        var newTokens = State.tokens.reduce(function(tokens, token, i, arr) {
          if (token.type === "inline" && regx.test(token.content)) {
            var openingTokens = [];
            var cursor = i - 1;
            var previousToken = arr[cursor];
            var subTree = [];
            while (previousToken && previousToken.level > 0 && validParentTokens.indexOf(previousToken.type) === -1) {
              openingTokens.unshift(previousToken);
              cursor--;
              previousToken = arr[cursor];
            }
            if (validParentTokens.indexOf(previousToken.type) === -1) {
              openingTokens.unshift(previousToken);
            } else {
              cursor++;
            }
            var closingTokens = openingTokens.map(function(token2) {
              return new State.Token(token2.type.replace("_open", "_close"), token2.tag, -1);
            }).reverse();
            var matches = token.content.match(regx);
            var inlineContentStack = token.content;
            matches.forEach(function(match) {
              var start = inlineContentStack.indexOf(match);
              var contentBefore = inlineContentStack.substr(0, start);
              inlineContentStack = inlineContentStack.substr(start + match.length);
              subTree = [].concat((0, _toConsumableArray2.default)(subTree), (0, _toConsumableArray2.default)(createInlineTokens(contentBefore, openingTokens, closingTokens)), (0, _toConsumableArray2.default)(createMediaTokens(match)));
            });
            if (inlineContentStack.length) {
              subTree = [].concat((0, _toConsumableArray2.default)(subTree), (0, _toConsumableArray2.default)(createInlineTokens(inlineContentStack, openingTokens, closingTokens)));
            }
            processedTokens = [].concat((0, _toConsumableArray2.default)(processedTokens), (0, _toConsumableArray2.default)(closingTokens.map(function(c) {
              return c.type;
            })));
            tokens = [].concat((0, _toConsumableArray2.default)(tokens.slice(0, cursor)), (0, _toConsumableArray2.default)(subTree));
          } else if (processedTokens.indexOf(token.type) !== -1) {
            processedTokens.splice(processedTokens.indexOf(token.type), 1);
          } else {
            tokens.push(token);
          }
          return tokens;
        }, []);
        State.tokens = newTokens;
        return true;
      };
    }
    var markdownItMedia = function markdownItMedia2(md) {
      md.core.ruler.before("inline", "media", createRule());
    };
    exports.markdownItMedia = markdownItMedia;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/dist/cjs/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MarkdownTransformer = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _schemaDefault = require_default_schema();
    var _markdownIt = _interopRequireDefault(require_markdown_it());
    var _markdownItTable = require_cjs4();
    var _prosemirrorMarkdown = require_dist3();
    var _media = require_media2();
    function filterMdToPmSchemaMapping(schema, map) {
      return Object.keys(map).reduce(function(newMap, key) {
        var value = map[key];
        var block = value.block || value.node;
        var mark = value.mark;
        if (block && schema.nodes[block] || mark && schema.marks[mark]) {
          newMap[key] = value;
        }
        return newMap;
      }, {});
    }
    var pmSchemaToMdMapping = {
      nodes: {
        blockquote: "blockquote",
        paragraph: "paragraph",
        rule: "hr",
        // lheading (---, ===)
        heading: ["heading", "lheading"],
        codeBlock: ["code", "fence"],
        listItem: "list",
        image: "image"
      },
      marks: {
        em: "emphasis",
        strong: "text",
        link: ["link", "autolink", "reference", "linkify"],
        strike: "strikethrough",
        code: "backticks"
      }
    };
    var mdToPmMapping = {
      blockquote: {
        block: "blockquote"
      },
      paragraph: {
        block: "paragraph"
      },
      em: {
        mark: "em"
      },
      strong: {
        mark: "strong"
      },
      link: {
        mark: "link",
        attrs: function attrs(tok) {
          return {
            href: tok.attrGet("href"),
            title: tok.attrGet("title") || null
          };
        }
      },
      hr: {
        node: "rule"
      },
      heading: {
        block: "heading",
        attrs: function attrs(tok) {
          return {
            level: +tok.tag.slice(1)
          };
        }
      },
      softbreak: {
        node: "hardBreak"
      },
      hardbreak: {
        node: "hardBreak"
      },
      code_block: {
        block: "codeBlock"
      },
      list_item: {
        block: "listItem"
      },
      bullet_list: {
        block: "bulletList"
      },
      ordered_list: {
        block: "orderedList",
        attrs: function attrs(tok) {
          return {
            order: typeof tok.attrGet("start") === "number" ? tok.attrGet("start") : 1
          };
        }
      },
      code_inline: {
        mark: "code"
      },
      fence: {
        block: "codeBlock",
        // we trim any whitespaces around language definition
        attrs: function attrs(tok) {
          return {
            language: tok.info && tok.info.trim() || null
          };
        }
      },
      media_single: {
        block: "mediaSingle",
        attrs: function attrs() {
          return {};
        }
      },
      media: {
        node: "media",
        attrs: function attrs(tok) {
          return {
            url: tok.attrGet("url"),
            type: "external"
          };
        }
      },
      emoji: {
        node: "emoji",
        attrs: function attrs(tok) {
          return {
            shortName: ":".concat(tok.markup, ":"),
            text: tok.content
          };
        }
      },
      table: {
        block: "table"
      },
      tr: {
        block: "tableRow"
      },
      th: {
        block: "tableHeader"
      },
      td: {
        block: "tableCell"
      },
      s: {
        mark: "strike"
      }
    };
    var md = (0, _markdownIt.default)("zero", {
      html: false
    });
    md.enable([
      // Process html entity - &#123;, &#xAF;, &quot;, ...
      "entity",
      // Process escaped chars and hardbreaks
      "escape"
    ]);
    var MarkdownTransformer2 = /* @__PURE__ */ function() {
      function MarkdownTransformer3() {
        var schema = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _schemaDefault.defaultSchema;
        var tokenizer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : md;
        (0, _classCallCheck2.default)(this, MarkdownTransformer3);
        ["nodes", "marks"].forEach(function(key) {
          for (var idx in pmSchemaToMdMapping[key]) {
            if (schema[key][idx]) {
              tokenizer.enable(pmSchemaToMdMapping[key][idx]);
            }
          }
        });
        if (schema.nodes.table) {
          tokenizer.use(_markdownItTable.markdownItTable);
        }
        if (schema.nodes.media && schema.nodes.mediaSingle) {
          tokenizer.use(_media.markdownItMedia);
        }
        this.markdownParser = new _prosemirrorMarkdown.MarkdownParser(schema, tokenizer, filterMdToPmSchemaMapping(schema, mdToPmMapping));
      }
      (0, _createClass2.default)(MarkdownTransformer3, [{
        key: "encode",
        value: function encode(_node) {
          throw new Error("This is not implemented yet");
        }
      }, {
        key: "parse",
        value: function parse(content) {
          return this.markdownParser.parse(content);
        }
      }]);
      return MarkdownTransformer3;
    }();
    exports.MarkdownTransformer = MarkdownTransformer2;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module2) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    module2.exports = _objectWithoutPropertiesLoose, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module2) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module2.exports = _objectWithoutProperties, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/unsupported.js
var require_unsupported = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/unsupported.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unsupportedNodeTypesForMediaCards = void 0;
    var unsupportedNodeTypesForMediaCards = /* @__PURE__ */ new Set(["decisionItem", "taskItem"]);
    exports.unsupportedNodeTypesForMediaCards = unsupportedNodeTypesForMediaCards;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/inline-nodes.js
var require_inline_nodes = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/inline-nodes.js"(exports) {
    "use strict";
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inlineNodes = void 0;
    var nodes = _interopRequireWildcard(require_nodes());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var typedNodes = nodes;
    var inlineNodes = new Set(Object.keys(typedNodes).filter(function(key) {
      return typedNodes[key] && typedNodes[key].group === "inline";
    }));
    exports.inlineNodes = inlineNodes;
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/schema/index.js
var require_schema = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/schema/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnnotationMarkStates", {
      enumerable: true,
      get: function get() {
        return _marks.AnnotationMarkStates;
      }
    });
    Object.defineProperty(exports, "AnnotationTypes", {
      enumerable: true,
      get: function get() {
        return _marks.AnnotationTypes;
      }
    });
    Object.defineProperty(exports, "PanelType", {
      enumerable: true,
      get: function get() {
        return _nodes.PanelType;
      }
    });
    Object.defineProperty(exports, "alignment", {
      enumerable: true,
      get: function get() {
        return _marks.alignment;
      }
    });
    Object.defineProperty(exports, "alignmentPositionMap", {
      enumerable: true,
      get: function get() {
        return _marks.alignmentPositionMap;
      }
    });
    Object.defineProperty(exports, "annotation", {
      enumerable: true,
      get: function get() {
        return _marks.annotation;
      }
    });
    Object.defineProperty(exports, "blockCard", {
      enumerable: true,
      get: function get() {
        return _nodes.blockCard;
      }
    });
    Object.defineProperty(exports, "blockquote", {
      enumerable: true,
      get: function get() {
        return _nodes.blockquote;
      }
    });
    Object.defineProperty(exports, "bodiedExtension", {
      enumerable: true,
      get: function get() {
        return _nodes.bodiedExtension;
      }
    });
    Object.defineProperty(exports, "border", {
      enumerable: true,
      get: function get() {
        return _marks.border;
      }
    });
    Object.defineProperty(exports, "borderColorPalette", {
      enumerable: true,
      get: function get() {
        return _marks.borderColorPalette;
      }
    });
    Object.defineProperty(exports, "breakout", {
      enumerable: true,
      get: function get() {
        return _marks.breakout;
      }
    });
    Object.defineProperty(exports, "buildAnnotationMarkDataAttributes", {
      enumerable: true,
      get: function get() {
        return _marks.buildAnnotationMarkDataAttributes;
      }
    });
    Object.defineProperty(exports, "bulletList", {
      enumerable: true,
      get: function get() {
        return _nodes.bulletList;
      }
    });
    Object.defineProperty(exports, "bulletListSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.bulletListSelector;
      }
    });
    Object.defineProperty(exports, "caption", {
      enumerable: true,
      get: function get() {
        return _nodes.caption;
      }
    });
    Object.defineProperty(exports, "code", {
      enumerable: true,
      get: function get() {
        return _marks.code;
      }
    });
    Object.defineProperty(exports, "codeBlock", {
      enumerable: true,
      get: function get() {
        return _nodes.codeBlock;
      }
    });
    Object.defineProperty(exports, "codeBlockToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.codeBlockToJSON;
      }
    });
    Object.defineProperty(exports, "colorPalette", {
      enumerable: true,
      get: function get() {
        return _marks.colorPalette;
      }
    });
    Object.defineProperty(exports, "colorPaletteExtended", {
      enumerable: true,
      get: function get() {
        return _marks.colorPaletteExtended;
      }
    });
    Object.defineProperty(exports, "confluenceInlineComment", {
      enumerable: true,
      get: function get() {
        return _marks.confluenceInlineComment;
      }
    });
    Object.defineProperty(exports, "confluenceJiraIssue", {
      enumerable: true,
      get: function get() {
        return _nodes.confluenceJiraIssue;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _nodes.confluenceUnsupportedBlock;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedInline", {
      enumerable: true,
      get: function get() {
        return _nodes.confluenceUnsupportedInline;
      }
    });
    Object.defineProperty(exports, "copyPrivateMediaAttributes", {
      enumerable: true,
      get: function get() {
        return _nodes.copyPrivateMediaAttributes;
      }
    });
    Object.defineProperty(exports, "createSchema", {
      enumerable: true,
      get: function get() {
        return _createSchema.createSchema;
      }
    });
    Object.defineProperty(exports, "dataConsumer", {
      enumerable: true,
      get: function get() {
        return _marks.dataConsumer;
      }
    });
    Object.defineProperty(exports, "dataConsumerToJSON", {
      enumerable: true,
      get: function get() {
        return _marks.dataConsumerToJSON;
      }
    });
    Object.defineProperty(exports, "date", {
      enumerable: true,
      get: function get() {
        return _nodes.date;
      }
    });
    Object.defineProperty(exports, "decisionItem", {
      enumerable: true,
      get: function get() {
        return _nodes.decisionItem;
      }
    });
    Object.defineProperty(exports, "decisionList", {
      enumerable: true,
      get: function get() {
        return _nodes.decisionList;
      }
    });
    Object.defineProperty(exports, "decisionListSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.decisionListSelector;
      }
    });
    Object.defineProperty(exports, "doc", {
      enumerable: true,
      get: function get() {
        return _nodes.doc;
      }
    });
    Object.defineProperty(exports, "em", {
      enumerable: true,
      get: function get() {
        return _marks.em;
      }
    });
    Object.defineProperty(exports, "embedCard", {
      enumerable: true,
      get: function get() {
        return _nodes.embedCard;
      }
    });
    Object.defineProperty(exports, "emoji", {
      enumerable: true,
      get: function get() {
        return _nodes.emoji;
      }
    });
    Object.defineProperty(exports, "expand", {
      enumerable: true,
      get: function get() {
        return _nodes.expand;
      }
    });
    Object.defineProperty(exports, "expandToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.expandToJSON;
      }
    });
    Object.defineProperty(exports, "extension", {
      enumerable: true,
      get: function get() {
        return _nodes.extension;
      }
    });
    Object.defineProperty(exports, "fragment", {
      enumerable: true,
      get: function get() {
        return _marks.fragment;
      }
    });
    Object.defineProperty(exports, "fragmentToJSON", {
      enumerable: true,
      get: function get() {
        return _marks.fragmentToJSON;
      }
    });
    Object.defineProperty(exports, "getCellAttrs", {
      enumerable: true,
      get: function get() {
        return _nodes.getCellAttrs;
      }
    });
    Object.defineProperty(exports, "getCellDomAttrs", {
      enumerable: true,
      get: function get() {
        return _nodes.getCellDomAttrs;
      }
    });
    Object.defineProperty(exports, "hardBreak", {
      enumerable: true,
      get: function get() {
        return _nodes.hardBreak;
      }
    });
    Object.defineProperty(exports, "heading", {
      enumerable: true,
      get: function get() {
        return _nodes.heading;
      }
    });
    Object.defineProperty(exports, "image", {
      enumerable: true,
      get: function get() {
        return _nodes.image;
      }
    });
    Object.defineProperty(exports, "indentation", {
      enumerable: true,
      get: function get() {
        return _marks.indentation;
      }
    });
    Object.defineProperty(exports, "inlineCard", {
      enumerable: true,
      get: function get() {
        return _nodes.inlineCard;
      }
    });
    Object.defineProperty(exports, "inlineExtension", {
      enumerable: true,
      get: function get() {
        return _nodes.inlineExtension;
      }
    });
    Object.defineProperty(exports, "inlineNodes", {
      enumerable: true,
      get: function get() {
        return _inlineNodes.inlineNodes;
      }
    });
    Object.defineProperty(exports, "layoutColumn", {
      enumerable: true,
      get: function get() {
        return _nodes.layoutColumn;
      }
    });
    Object.defineProperty(exports, "layoutSection", {
      enumerable: true,
      get: function get() {
        return _nodes.layoutSection;
      }
    });
    Object.defineProperty(exports, "layoutSectionWithSingleColumn", {
      enumerable: true,
      get: function get() {
        return _nodes.layoutSectionWithSingleColumn;
      }
    });
    Object.defineProperty(exports, "link", {
      enumerable: true,
      get: function get() {
        return _marks.link;
      }
    });
    Object.defineProperty(exports, "linkToJSON", {
      enumerable: true,
      get: function get() {
        return _marks.linkToJSON;
      }
    });
    Object.defineProperty(exports, "listItem", {
      enumerable: true,
      get: function get() {
        return _nodes.listItem;
      }
    });
    Object.defineProperty(exports, "media", {
      enumerable: true,
      get: function get() {
        return _nodes.media;
      }
    });
    Object.defineProperty(exports, "mediaGroup", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaGroup;
      }
    });
    Object.defineProperty(exports, "mediaInline", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaInline;
      }
    });
    Object.defineProperty(exports, "mediaSingle", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaSingle;
      }
    });
    Object.defineProperty(exports, "mediaSingleToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaSingleToJSON;
      }
    });
    Object.defineProperty(exports, "mediaSingleWithCaption", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaSingleWithCaption;
      }
    });
    Object.defineProperty(exports, "mediaToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.mediaToJSON;
      }
    });
    Object.defineProperty(exports, "mention", {
      enumerable: true,
      get: function get() {
        return _nodes.mention;
      }
    });
    Object.defineProperty(exports, "mentionToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.mentionToJSON;
      }
    });
    Object.defineProperty(exports, "nestedExpand", {
      enumerable: true,
      get: function get() {
        return _nodes.nestedExpand;
      }
    });
    Object.defineProperty(exports, "orderedList", {
      enumerable: true,
      get: function get() {
        return _nodes.orderedList;
      }
    });
    Object.defineProperty(exports, "orderedListSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.orderedListSelector;
      }
    });
    Object.defineProperty(exports, "orderedListWithOrder", {
      enumerable: true,
      get: function get() {
        return _nodes.orderedListWithOrder;
      }
    });
    Object.defineProperty(exports, "panel", {
      enumerable: true,
      get: function get() {
        return _nodes.panel;
      }
    });
    Object.defineProperty(exports, "paragraph", {
      enumerable: true,
      get: function get() {
        return _nodes.paragraph;
      }
    });
    Object.defineProperty(exports, "placeholder", {
      enumerable: true,
      get: function get() {
        return _nodes.placeholder;
      }
    });
    Object.defineProperty(exports, "rule", {
      enumerable: true,
      get: function get() {
        return _nodes.rule;
      }
    });
    Object.defineProperty(exports, "sanitizeNodes", {
      enumerable: true,
      get: function get() {
        return _createSchema.sanitizeNodes;
      }
    });
    Object.defineProperty(exports, "status", {
      enumerable: true,
      get: function get() {
        return _nodes.status;
      }
    });
    Object.defineProperty(exports, "strike", {
      enumerable: true,
      get: function get() {
        return _marks.strike;
      }
    });
    Object.defineProperty(exports, "strong", {
      enumerable: true,
      get: function get() {
        return _marks.strong;
      }
    });
    Object.defineProperty(exports, "subsup", {
      enumerable: true,
      get: function get() {
        return _marks.subsup;
      }
    });
    Object.defineProperty(exports, "table", {
      enumerable: true,
      get: function get() {
        return _nodes.table;
      }
    });
    Object.defineProperty(exports, "tableBackgroundBorderColor", {
      enumerable: true,
      get: function get() {
        return _nodes.tableBackgroundBorderColor;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorNames", {
      enumerable: true,
      get: function get() {
        return _nodes.tableBackgroundColorNames;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorPalette", {
      enumerable: true,
      get: function get() {
        return _nodes.tableBackgroundColorPalette;
      }
    });
    Object.defineProperty(exports, "tableCell", {
      enumerable: true,
      get: function get() {
        return _nodes.tableCell;
      }
    });
    Object.defineProperty(exports, "tableCellContentDomSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.tableCellContentDomSelector;
      }
    });
    Object.defineProperty(exports, "tableCellContentWrapperSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.tableCellContentWrapperSelector;
      }
    });
    Object.defineProperty(exports, "tableCellSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.tableCellSelector;
      }
    });
    Object.defineProperty(exports, "tableHeader", {
      enumerable: true,
      get: function get() {
        return _nodes.tableHeader;
      }
    });
    Object.defineProperty(exports, "tableHeaderSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.tableHeaderSelector;
      }
    });
    Object.defineProperty(exports, "tablePrefixSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.tablePrefixSelector;
      }
    });
    Object.defineProperty(exports, "tableRow", {
      enumerable: true,
      get: function get() {
        return _nodes.tableRow;
      }
    });
    Object.defineProperty(exports, "tableToJSON", {
      enumerable: true,
      get: function get() {
        return _nodes.tableToJSON;
      }
    });
    Object.defineProperty(exports, "taskItem", {
      enumerable: true,
      get: function get() {
        return _nodes.taskItem;
      }
    });
    Object.defineProperty(exports, "taskList", {
      enumerable: true,
      get: function get() {
        return _nodes.taskList;
      }
    });
    Object.defineProperty(exports, "taskListSelector", {
      enumerable: true,
      get: function get() {
        return _nodes.taskListSelector;
      }
    });
    Object.defineProperty(exports, "text", {
      enumerable: true,
      get: function get() {
        return _nodes.text;
      }
    });
    Object.defineProperty(exports, "textColor", {
      enumerable: true,
      get: function get() {
        return _marks.textColor;
      }
    });
    Object.defineProperty(exports, "toJSONTableCell", {
      enumerable: true,
      get: function get() {
        return _nodes.toJSONTableCell;
      }
    });
    Object.defineProperty(exports, "toJSONTableHeader", {
      enumerable: true,
      get: function get() {
        return _nodes.toJSONTableHeader;
      }
    });
    Object.defineProperty(exports, "typeAheadQuery", {
      enumerable: true,
      get: function get() {
        return _marks.typeAheadQuery;
      }
    });
    Object.defineProperty(exports, "underline", {
      enumerable: true,
      get: function get() {
        return _marks.underline;
      }
    });
    Object.defineProperty(exports, "unknownBlock", {
      enumerable: true,
      get: function get() {
        return _nodes.unknownBlock;
      }
    });
    Object.defineProperty(exports, "unsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _nodes.unsupportedBlock;
      }
    });
    Object.defineProperty(exports, "unsupportedInline", {
      enumerable: true,
      get: function get() {
        return _nodes.unsupportedInline;
      }
    });
    Object.defineProperty(exports, "unsupportedMark", {
      enumerable: true,
      get: function get() {
        return _marks.unsupportedMark;
      }
    });
    Object.defineProperty(exports, "unsupportedNodeAttribute", {
      enumerable: true,
      get: function get() {
        return _marks.unsupportedNodeAttribute;
      }
    });
    Object.defineProperty(exports, "unsupportedNodeTypesForMediaCards", {
      enumerable: true,
      get: function get() {
        return _unsupported.unsupportedNodeTypesForMediaCards;
      }
    });
    var _nodes = require_nodes();
    var _marks = require_marks();
    var _unsupported = require_unsupported();
    var _inlineNodes = require_inline_nodes();
    var _createSchema = require_create_schema();
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "B100", {
      enumerable: true,
      get: function get() {
        return _colors.B100;
      }
    });
    Object.defineProperty(exports, "B400", {
      enumerable: true,
      get: function get() {
        return _colors.B400;
      }
    });
    Object.defineProperty(exports, "B50", {
      enumerable: true,
      get: function get() {
        return _colors.B50;
      }
    });
    Object.defineProperty(exports, "B500", {
      enumerable: true,
      get: function get() {
        return _colors.B500;
      }
    });
    Object.defineProperty(exports, "B75", {
      enumerable: true,
      get: function get() {
        return _colors.B75;
      }
    });
    Object.defineProperty(exports, "G200", {
      enumerable: true,
      get: function get() {
        return _colors.G200;
      }
    });
    Object.defineProperty(exports, "G300", {
      enumerable: true,
      get: function get() {
        return _colors.G300;
      }
    });
    Object.defineProperty(exports, "G400", {
      enumerable: true,
      get: function get() {
        return _colors.G400;
      }
    });
    Object.defineProperty(exports, "G50", {
      enumerable: true,
      get: function get() {
        return _colors.G50;
      }
    });
    Object.defineProperty(exports, "G500", {
      enumerable: true,
      get: function get() {
        return _colors.G500;
      }
    });
    Object.defineProperty(exports, "G75", {
      enumerable: true,
      get: function get() {
        return _colors.G75;
      }
    });
    Object.defineProperty(exports, "N0", {
      enumerable: true,
      get: function get() {
        return _colors.N0;
      }
    });
    Object.defineProperty(exports, "N20", {
      enumerable: true,
      get: function get() {
        return _colors.N20;
      }
    });
    Object.defineProperty(exports, "N200", {
      enumerable: true,
      get: function get() {
        return _colors.N200;
      }
    });
    Object.defineProperty(exports, "N30", {
      enumerable: true,
      get: function get() {
        return _colors.N30;
      }
    });
    Object.defineProperty(exports, "N300", {
      enumerable: true,
      get: function get() {
        return _colors.N300;
      }
    });
    Object.defineProperty(exports, "N40", {
      enumerable: true,
      get: function get() {
        return _colors.N40;
      }
    });
    Object.defineProperty(exports, "N50", {
      enumerable: true,
      get: function get() {
        return _colors.N50;
      }
    });
    Object.defineProperty(exports, "N500", {
      enumerable: true,
      get: function get() {
        return _colors.N500;
      }
    });
    Object.defineProperty(exports, "N60", {
      enumerable: true,
      get: function get() {
        return _colors.N60;
      }
    });
    Object.defineProperty(exports, "N80", {
      enumerable: true,
      get: function get() {
        return _colors.N80;
      }
    });
    Object.defineProperty(exports, "N800", {
      enumerable: true,
      get: function get() {
        return _colors.N800;
      }
    });
    Object.defineProperty(exports, "N90", {
      enumerable: true,
      get: function get() {
        return _colors.N90;
      }
    });
    Object.defineProperty(exports, "P100", {
      enumerable: true,
      get: function get() {
        return _colors.P100;
      }
    });
    Object.defineProperty(exports, "P300", {
      enumerable: true,
      get: function get() {
        return _colors.P300;
      }
    });
    Object.defineProperty(exports, "P400", {
      enumerable: true,
      get: function get() {
        return _colors.P400;
      }
    });
    Object.defineProperty(exports, "P50", {
      enumerable: true,
      get: function get() {
        return _colors.P50;
      }
    });
    Object.defineProperty(exports, "P500", {
      enumerable: true,
      get: function get() {
        return _colors.P500;
      }
    });
    Object.defineProperty(exports, "P75", {
      enumerable: true,
      get: function get() {
        return _colors.P75;
      }
    });
    Object.defineProperty(exports, "R100", {
      enumerable: true,
      get: function get() {
        return _colors.R100;
      }
    });
    Object.defineProperty(exports, "R300", {
      enumerable: true,
      get: function get() {
        return _colors.R300;
      }
    });
    Object.defineProperty(exports, "R400", {
      enumerable: true,
      get: function get() {
        return _colors.R400;
      }
    });
    Object.defineProperty(exports, "R50", {
      enumerable: true,
      get: function get() {
        return _colors.R50;
      }
    });
    Object.defineProperty(exports, "R500", {
      enumerable: true,
      get: function get() {
        return _colors.R500;
      }
    });
    Object.defineProperty(exports, "R75", {
      enumerable: true,
      get: function get() {
        return _colors.R75;
      }
    });
    Object.defineProperty(exports, "T100", {
      enumerable: true,
      get: function get() {
        return _colors.T100;
      }
    });
    Object.defineProperty(exports, "T300", {
      enumerable: true,
      get: function get() {
        return _colors.T300;
      }
    });
    Object.defineProperty(exports, "T50", {
      enumerable: true,
      get: function get() {
        return _colors.T50;
      }
    });
    Object.defineProperty(exports, "T500", {
      enumerable: true,
      get: function get() {
        return _colors.T500;
      }
    });
    Object.defineProperty(exports, "T75", {
      enumerable: true,
      get: function get() {
        return _colors.T75;
      }
    });
    Object.defineProperty(exports, "Y200", {
      enumerable: true,
      get: function get() {
        return _colors.Y200;
      }
    });
    Object.defineProperty(exports, "Y400", {
      enumerable: true,
      get: function get() {
        return _colors.Y400;
      }
    });
    Object.defineProperty(exports, "Y50", {
      enumerable: true,
      get: function get() {
        return _colors.Y50;
      }
    });
    Object.defineProperty(exports, "Y500", {
      enumerable: true,
      get: function get() {
        return _colors.Y500;
      }
    });
    Object.defineProperty(exports, "Y75", {
      enumerable: true,
      get: function get() {
        return _colors.Y75;
      }
    });
    Object.defineProperty(exports, "acNameToEmoji", {
      enumerable: true,
      get: function get() {
        return _emoji.acNameToEmoji;
      }
    });
    Object.defineProperty(exports, "acShortcutToEmoji", {
      enumerable: true,
      get: function get() {
        return _emoji.acShortcutToEmoji;
      }
    });
    Object.defineProperty(exports, "emojiIdToAcName", {
      enumerable: true,
      get: function get() {
        return _emoji.emojiIdToAcName;
      }
    });
    Object.defineProperty(exports, "generateUuid", {
      enumerable: true,
      get: function get() {
        return _uuid.generateUuid;
      }
    });
    Object.defineProperty(exports, "getEmojiAcName", {
      enumerable: true,
      get: function get() {
        return _emoji.getEmojiAcName;
      }
    });
    Object.defineProperty(exports, "getLinkMatch", {
      enumerable: true,
      get: function get() {
        return _url.getLinkMatch;
      }
    });
    Object.defineProperty(exports, "hexToRgb", {
      enumerable: true,
      get: function get() {
        return _colors.hexToRgb;
      }
    });
    Object.defineProperty(exports, "hexToRgba", {
      enumerable: true,
      get: function get() {
        return _colors.hexToRgba;
      }
    });
    Object.defineProperty(exports, "isHex", {
      enumerable: true,
      get: function get() {
        return _colors.isHex;
      }
    });
    Object.defineProperty(exports, "isRgb", {
      enumerable: true,
      get: function get() {
        return _colors.isRgb;
      }
    });
    Object.defineProperty(exports, "isSafeUrl", {
      enumerable: true,
      get: function get() {
        return _url.isSafeUrl;
      }
    });
    Object.defineProperty(exports, "linkify", {
      enumerable: true,
      get: function get() {
        return _url.linkify;
      }
    });
    Object.defineProperty(exports, "linkifyMatch", {
      enumerable: true,
      get: function get() {
        return _url.linkifyMatch;
      }
    });
    Object.defineProperty(exports, "normalizeHexColor", {
      enumerable: true,
      get: function get() {
        return _colors.normalizeHexColor;
      }
    });
    Object.defineProperty(exports, "normalizeUrl", {
      enumerable: true,
      get: function get() {
        return _url.normalizeUrl;
      }
    });
    Object.defineProperty(exports, "rgbToHex", {
      enumerable: true,
      get: function get() {
        return _colors.rgbToHex;
      }
    });
    Object.defineProperty(exports, "uuid", {
      enumerable: true,
      get: function get() {
        return _uuid.uuid;
      }
    });
    var _emoji = require_emoji();
    var _uuid = require_uuid();
    var _colors = require_colors();
    var _url = require_url();
  }
});

// node_modules/@atlaskit/adf-schema/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@atlaskit/adf-schema/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnnotationMarkStates", {
      enumerable: true,
      get: function get() {
        return _schema.AnnotationMarkStates;
      }
    });
    Object.defineProperty(exports, "AnnotationTypes", {
      enumerable: true,
      get: function get() {
        return _schema.AnnotationTypes;
      }
    });
    Object.defineProperty(exports, "B100", {
      enumerable: true,
      get: function get() {
        return _utils.B100;
      }
    });
    Object.defineProperty(exports, "B400", {
      enumerable: true,
      get: function get() {
        return _utils.B400;
      }
    });
    Object.defineProperty(exports, "B50", {
      enumerable: true,
      get: function get() {
        return _utils.B50;
      }
    });
    Object.defineProperty(exports, "B500", {
      enumerable: true,
      get: function get() {
        return _utils.B500;
      }
    });
    Object.defineProperty(exports, "B75", {
      enumerable: true,
      get: function get() {
        return _utils.B75;
      }
    });
    Object.defineProperty(exports, "G200", {
      enumerable: true,
      get: function get() {
        return _utils.G200;
      }
    });
    Object.defineProperty(exports, "G300", {
      enumerable: true,
      get: function get() {
        return _utils.G300;
      }
    });
    Object.defineProperty(exports, "G400", {
      enumerable: true,
      get: function get() {
        return _utils.G400;
      }
    });
    Object.defineProperty(exports, "G50", {
      enumerable: true,
      get: function get() {
        return _utils.G50;
      }
    });
    Object.defineProperty(exports, "G500", {
      enumerable: true,
      get: function get() {
        return _utils.G500;
      }
    });
    Object.defineProperty(exports, "G75", {
      enumerable: true,
      get: function get() {
        return _utils.G75;
      }
    });
    Object.defineProperty(exports, "N0", {
      enumerable: true,
      get: function get() {
        return _utils.N0;
      }
    });
    Object.defineProperty(exports, "N20", {
      enumerable: true,
      get: function get() {
        return _utils.N20;
      }
    });
    Object.defineProperty(exports, "N200", {
      enumerable: true,
      get: function get() {
        return _utils.N200;
      }
    });
    Object.defineProperty(exports, "N30", {
      enumerable: true,
      get: function get() {
        return _utils.N30;
      }
    });
    Object.defineProperty(exports, "N300", {
      enumerable: true,
      get: function get() {
        return _utils.N300;
      }
    });
    Object.defineProperty(exports, "N40", {
      enumerable: true,
      get: function get() {
        return _utils.N40;
      }
    });
    Object.defineProperty(exports, "N50", {
      enumerable: true,
      get: function get() {
        return _utils.N50;
      }
    });
    Object.defineProperty(exports, "N500", {
      enumerable: true,
      get: function get() {
        return _utils.N500;
      }
    });
    Object.defineProperty(exports, "N60", {
      enumerable: true,
      get: function get() {
        return _utils.N60;
      }
    });
    Object.defineProperty(exports, "N80", {
      enumerable: true,
      get: function get() {
        return _utils.N80;
      }
    });
    Object.defineProperty(exports, "N800", {
      enumerable: true,
      get: function get() {
        return _utils.N800;
      }
    });
    Object.defineProperty(exports, "N90", {
      enumerable: true,
      get: function get() {
        return _utils.N90;
      }
    });
    Object.defineProperty(exports, "P100", {
      enumerable: true,
      get: function get() {
        return _utils.P100;
      }
    });
    Object.defineProperty(exports, "P300", {
      enumerable: true,
      get: function get() {
        return _utils.P300;
      }
    });
    Object.defineProperty(exports, "P400", {
      enumerable: true,
      get: function get() {
        return _utils.P400;
      }
    });
    Object.defineProperty(exports, "P50", {
      enumerable: true,
      get: function get() {
        return _utils.P50;
      }
    });
    Object.defineProperty(exports, "P500", {
      enumerable: true,
      get: function get() {
        return _utils.P500;
      }
    });
    Object.defineProperty(exports, "P75", {
      enumerable: true,
      get: function get() {
        return _utils.P75;
      }
    });
    Object.defineProperty(exports, "PanelType", {
      enumerable: true,
      get: function get() {
        return _schema.PanelType;
      }
    });
    Object.defineProperty(exports, "R100", {
      enumerable: true,
      get: function get() {
        return _utils.R100;
      }
    });
    Object.defineProperty(exports, "R300", {
      enumerable: true,
      get: function get() {
        return _utils.R300;
      }
    });
    Object.defineProperty(exports, "R400", {
      enumerable: true,
      get: function get() {
        return _utils.R400;
      }
    });
    Object.defineProperty(exports, "R50", {
      enumerable: true,
      get: function get() {
        return _utils.R50;
      }
    });
    Object.defineProperty(exports, "R500", {
      enumerable: true,
      get: function get() {
        return _utils.R500;
      }
    });
    Object.defineProperty(exports, "R75", {
      enumerable: true,
      get: function get() {
        return _utils.R75;
      }
    });
    Object.defineProperty(exports, "T100", {
      enumerable: true,
      get: function get() {
        return _utils.T100;
      }
    });
    Object.defineProperty(exports, "T300", {
      enumerable: true,
      get: function get() {
        return _utils.T300;
      }
    });
    Object.defineProperty(exports, "T50", {
      enumerable: true,
      get: function get() {
        return _utils.T50;
      }
    });
    Object.defineProperty(exports, "T500", {
      enumerable: true,
      get: function get() {
        return _utils.T500;
      }
    });
    Object.defineProperty(exports, "T75", {
      enumerable: true,
      get: function get() {
        return _utils.T75;
      }
    });
    Object.defineProperty(exports, "Y200", {
      enumerable: true,
      get: function get() {
        return _utils.Y200;
      }
    });
    Object.defineProperty(exports, "Y400", {
      enumerable: true,
      get: function get() {
        return _utils.Y400;
      }
    });
    Object.defineProperty(exports, "Y50", {
      enumerable: true,
      get: function get() {
        return _utils.Y50;
      }
    });
    Object.defineProperty(exports, "Y500", {
      enumerable: true,
      get: function get() {
        return _utils.Y500;
      }
    });
    Object.defineProperty(exports, "Y75", {
      enumerable: true,
      get: function get() {
        return _utils.Y75;
      }
    });
    Object.defineProperty(exports, "acNameToEmoji", {
      enumerable: true,
      get: function get() {
        return _utils.acNameToEmoji;
      }
    });
    Object.defineProperty(exports, "acShortcutToEmoji", {
      enumerable: true,
      get: function get() {
        return _utils.acShortcutToEmoji;
      }
    });
    Object.defineProperty(exports, "alignment", {
      enumerable: true,
      get: function get() {
        return _schema.alignment;
      }
    });
    Object.defineProperty(exports, "alignmentPositionMap", {
      enumerable: true,
      get: function get() {
        return _schema.alignmentPositionMap;
      }
    });
    Object.defineProperty(exports, "annotation", {
      enumerable: true,
      get: function get() {
        return _schema.annotation;
      }
    });
    Object.defineProperty(exports, "blockCard", {
      enumerable: true,
      get: function get() {
        return _schema.blockCard;
      }
    });
    Object.defineProperty(exports, "blockquote", {
      enumerable: true,
      get: function get() {
        return _schema.blockquote;
      }
    });
    Object.defineProperty(exports, "bodiedExtension", {
      enumerable: true,
      get: function get() {
        return _schema.bodiedExtension;
      }
    });
    Object.defineProperty(exports, "border", {
      enumerable: true,
      get: function get() {
        return _schema.border;
      }
    });
    Object.defineProperty(exports, "borderColorPalette", {
      enumerable: true,
      get: function get() {
        return _schema.borderColorPalette;
      }
    });
    Object.defineProperty(exports, "breakout", {
      enumerable: true,
      get: function get() {
        return _schema.breakout;
      }
    });
    Object.defineProperty(exports, "buildAnnotationMarkDataAttributes", {
      enumerable: true,
      get: function get() {
        return _schema.buildAnnotationMarkDataAttributes;
      }
    });
    Object.defineProperty(exports, "bulletList", {
      enumerable: true,
      get: function get() {
        return _schema.bulletList;
      }
    });
    Object.defineProperty(exports, "bulletListSelector", {
      enumerable: true,
      get: function get() {
        return _schema.bulletListSelector;
      }
    });
    Object.defineProperty(exports, "caption", {
      enumerable: true,
      get: function get() {
        return _schema.caption;
      }
    });
    Object.defineProperty(exports, "code", {
      enumerable: true,
      get: function get() {
        return _schema.code;
      }
    });
    Object.defineProperty(exports, "codeBlock", {
      enumerable: true,
      get: function get() {
        return _schema.codeBlock;
      }
    });
    Object.defineProperty(exports, "codeBlockToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.codeBlockToJSON;
      }
    });
    Object.defineProperty(exports, "colorPalette", {
      enumerable: true,
      get: function get() {
        return _schema.colorPalette;
      }
    });
    Object.defineProperty(exports, "colorPaletteExtended", {
      enumerable: true,
      get: function get() {
        return _schema.colorPaletteExtended;
      }
    });
    Object.defineProperty(exports, "confluenceInlineComment", {
      enumerable: true,
      get: function get() {
        return _schema.confluenceInlineComment;
      }
    });
    Object.defineProperty(exports, "confluenceJiraIssue", {
      enumerable: true,
      get: function get() {
        return _schema.confluenceJiraIssue;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _schema.confluenceUnsupportedBlock;
      }
    });
    Object.defineProperty(exports, "confluenceUnsupportedInline", {
      enumerable: true,
      get: function get() {
        return _schema.confluenceUnsupportedInline;
      }
    });
    Object.defineProperty(exports, "copyPrivateMediaAttributes", {
      enumerable: true,
      get: function get() {
        return _schema.copyPrivateMediaAttributes;
      }
    });
    Object.defineProperty(exports, "createSchema", {
      enumerable: true,
      get: function get() {
        return _schema.createSchema;
      }
    });
    Object.defineProperty(exports, "dataConsumer", {
      enumerable: true,
      get: function get() {
        return _schema.dataConsumer;
      }
    });
    Object.defineProperty(exports, "dataConsumerToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.dataConsumerToJSON;
      }
    });
    Object.defineProperty(exports, "date", {
      enumerable: true,
      get: function get() {
        return _schema.date;
      }
    });
    Object.defineProperty(exports, "decisionItem", {
      enumerable: true,
      get: function get() {
        return _schema.decisionItem;
      }
    });
    Object.defineProperty(exports, "decisionList", {
      enumerable: true,
      get: function get() {
        return _schema.decisionList;
      }
    });
    Object.defineProperty(exports, "decisionListSelector", {
      enumerable: true,
      get: function get() {
        return _schema.decisionListSelector;
      }
    });
    Object.defineProperty(exports, "doc", {
      enumerable: true,
      get: function get() {
        return _schema.doc;
      }
    });
    Object.defineProperty(exports, "em", {
      enumerable: true,
      get: function get() {
        return _schema.em;
      }
    });
    Object.defineProperty(exports, "embedCard", {
      enumerable: true,
      get: function get() {
        return _schema.embedCard;
      }
    });
    Object.defineProperty(exports, "emoji", {
      enumerable: true,
      get: function get() {
        return _schema.emoji;
      }
    });
    Object.defineProperty(exports, "emojiIdToAcName", {
      enumerable: true,
      get: function get() {
        return _utils.emojiIdToAcName;
      }
    });
    Object.defineProperty(exports, "expand", {
      enumerable: true,
      get: function get() {
        return _schema.expand;
      }
    });
    Object.defineProperty(exports, "expandToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.expandToJSON;
      }
    });
    Object.defineProperty(exports, "extension", {
      enumerable: true,
      get: function get() {
        return _schema.extension;
      }
    });
    Object.defineProperty(exports, "fragment", {
      enumerable: true,
      get: function get() {
        return _schema.fragment;
      }
    });
    Object.defineProperty(exports, "fragmentToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.fragmentToJSON;
      }
    });
    Object.defineProperty(exports, "generateUuid", {
      enumerable: true,
      get: function get() {
        return _utils.generateUuid;
      }
    });
    Object.defineProperty(exports, "getCellAttrs", {
      enumerable: true,
      get: function get() {
        return _schema.getCellAttrs;
      }
    });
    Object.defineProperty(exports, "getCellDomAttrs", {
      enumerable: true,
      get: function get() {
        return _schema.getCellDomAttrs;
      }
    });
    Object.defineProperty(exports, "getEmojiAcName", {
      enumerable: true,
      get: function get() {
        return _utils.getEmojiAcName;
      }
    });
    Object.defineProperty(exports, "getLinkMatch", {
      enumerable: true,
      get: function get() {
        return _utils.getLinkMatch;
      }
    });
    Object.defineProperty(exports, "hardBreak", {
      enumerable: true,
      get: function get() {
        return _schema.hardBreak;
      }
    });
    Object.defineProperty(exports, "heading", {
      enumerable: true,
      get: function get() {
        return _schema.heading;
      }
    });
    Object.defineProperty(exports, "hexToRgb", {
      enumerable: true,
      get: function get() {
        return _utils.hexToRgb;
      }
    });
    Object.defineProperty(exports, "hexToRgba", {
      enumerable: true,
      get: function get() {
        return _utils.hexToRgba;
      }
    });
    Object.defineProperty(exports, "image", {
      enumerable: true,
      get: function get() {
        return _schema.image;
      }
    });
    Object.defineProperty(exports, "indentation", {
      enumerable: true,
      get: function get() {
        return _schema.indentation;
      }
    });
    Object.defineProperty(exports, "inlineCard", {
      enumerable: true,
      get: function get() {
        return _schema.inlineCard;
      }
    });
    Object.defineProperty(exports, "inlineExtension", {
      enumerable: true,
      get: function get() {
        return _schema.inlineExtension;
      }
    });
    Object.defineProperty(exports, "inlineNodes", {
      enumerable: true,
      get: function get() {
        return _schema.inlineNodes;
      }
    });
    Object.defineProperty(exports, "isHex", {
      enumerable: true,
      get: function get() {
        return _utils.isHex;
      }
    });
    Object.defineProperty(exports, "isRgb", {
      enumerable: true,
      get: function get() {
        return _utils.isRgb;
      }
    });
    Object.defineProperty(exports, "isSafeUrl", {
      enumerable: true,
      get: function get() {
        return _utils.isSafeUrl;
      }
    });
    Object.defineProperty(exports, "layoutColumn", {
      enumerable: true,
      get: function get() {
        return _schema.layoutColumn;
      }
    });
    Object.defineProperty(exports, "layoutSection", {
      enumerable: true,
      get: function get() {
        return _schema.layoutSection;
      }
    });
    Object.defineProperty(exports, "link", {
      enumerable: true,
      get: function get() {
        return _schema.link;
      }
    });
    Object.defineProperty(exports, "linkToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.linkToJSON;
      }
    });
    Object.defineProperty(exports, "linkify", {
      enumerable: true,
      get: function get() {
        return _utils.linkify;
      }
    });
    Object.defineProperty(exports, "linkifyMatch", {
      enumerable: true,
      get: function get() {
        return _utils.linkifyMatch;
      }
    });
    Object.defineProperty(exports, "listItem", {
      enumerable: true,
      get: function get() {
        return _schema.listItem;
      }
    });
    Object.defineProperty(exports, "media", {
      enumerable: true,
      get: function get() {
        return _schema.media;
      }
    });
    Object.defineProperty(exports, "mediaGroup", {
      enumerable: true,
      get: function get() {
        return _schema.mediaGroup;
      }
    });
    Object.defineProperty(exports, "mediaInline", {
      enumerable: true,
      get: function get() {
        return _schema.mediaInline;
      }
    });
    Object.defineProperty(exports, "mediaSingle", {
      enumerable: true,
      get: function get() {
        return _schema.mediaSingle;
      }
    });
    Object.defineProperty(exports, "mediaSingleToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.mediaSingleToJSON;
      }
    });
    Object.defineProperty(exports, "mediaSingleWithCaption", {
      enumerable: true,
      get: function get() {
        return _schema.mediaSingleWithCaption;
      }
    });
    Object.defineProperty(exports, "mediaToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.mediaToJSON;
      }
    });
    Object.defineProperty(exports, "mention", {
      enumerable: true,
      get: function get() {
        return _schema.mention;
      }
    });
    Object.defineProperty(exports, "mentionToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.mentionToJSON;
      }
    });
    Object.defineProperty(exports, "nestedExpand", {
      enumerable: true,
      get: function get() {
        return _schema.nestedExpand;
      }
    });
    Object.defineProperty(exports, "normalizeHexColor", {
      enumerable: true,
      get: function get() {
        return _utils.normalizeHexColor;
      }
    });
    Object.defineProperty(exports, "normalizeUrl", {
      enumerable: true,
      get: function get() {
        return _utils.normalizeUrl;
      }
    });
    Object.defineProperty(exports, "orderedList", {
      enumerable: true,
      get: function get() {
        return _schema.orderedList;
      }
    });
    Object.defineProperty(exports, "orderedListSelector", {
      enumerable: true,
      get: function get() {
        return _schema.orderedListSelector;
      }
    });
    Object.defineProperty(exports, "orderedListWithOrder", {
      enumerable: true,
      get: function get() {
        return _schema.orderedListWithOrder;
      }
    });
    Object.defineProperty(exports, "panel", {
      enumerable: true,
      get: function get() {
        return _schema.panel;
      }
    });
    Object.defineProperty(exports, "paragraph", {
      enumerable: true,
      get: function get() {
        return _schema.paragraph;
      }
    });
    Object.defineProperty(exports, "placeholder", {
      enumerable: true,
      get: function get() {
        return _schema.placeholder;
      }
    });
    Object.defineProperty(exports, "rgbToHex", {
      enumerable: true,
      get: function get() {
        return _utils.rgbToHex;
      }
    });
    Object.defineProperty(exports, "rule", {
      enumerable: true,
      get: function get() {
        return _schema.rule;
      }
    });
    Object.defineProperty(exports, "sanitizeNodes", {
      enumerable: true,
      get: function get() {
        return _schema.sanitizeNodes;
      }
    });
    Object.defineProperty(exports, "status", {
      enumerable: true,
      get: function get() {
        return _schema.status;
      }
    });
    Object.defineProperty(exports, "strike", {
      enumerable: true,
      get: function get() {
        return _schema.strike;
      }
    });
    Object.defineProperty(exports, "strong", {
      enumerable: true,
      get: function get() {
        return _schema.strong;
      }
    });
    Object.defineProperty(exports, "subsup", {
      enumerable: true,
      get: function get() {
        return _schema.subsup;
      }
    });
    Object.defineProperty(exports, "table", {
      enumerable: true,
      get: function get() {
        return _schema.table;
      }
    });
    Object.defineProperty(exports, "tableBackgroundBorderColor", {
      enumerable: true,
      get: function get() {
        return _schema.tableBackgroundBorderColor;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorNames", {
      enumerable: true,
      get: function get() {
        return _schema.tableBackgroundColorNames;
      }
    });
    Object.defineProperty(exports, "tableBackgroundColorPalette", {
      enumerable: true,
      get: function get() {
        return _schema.tableBackgroundColorPalette;
      }
    });
    Object.defineProperty(exports, "tableCell", {
      enumerable: true,
      get: function get() {
        return _schema.tableCell;
      }
    });
    Object.defineProperty(exports, "tableCellContentDomSelector", {
      enumerable: true,
      get: function get() {
        return _schema.tableCellContentDomSelector;
      }
    });
    Object.defineProperty(exports, "tableCellContentWrapperSelector", {
      enumerable: true,
      get: function get() {
        return _schema.tableCellContentWrapperSelector;
      }
    });
    Object.defineProperty(exports, "tableCellSelector", {
      enumerable: true,
      get: function get() {
        return _schema.tableCellSelector;
      }
    });
    Object.defineProperty(exports, "tableHeader", {
      enumerable: true,
      get: function get() {
        return _schema.tableHeader;
      }
    });
    Object.defineProperty(exports, "tableHeaderSelector", {
      enumerable: true,
      get: function get() {
        return _schema.tableHeaderSelector;
      }
    });
    Object.defineProperty(exports, "tablePrefixSelector", {
      enumerable: true,
      get: function get() {
        return _schema.tablePrefixSelector;
      }
    });
    Object.defineProperty(exports, "tableRow", {
      enumerable: true,
      get: function get() {
        return _schema.tableRow;
      }
    });
    Object.defineProperty(exports, "tableToJSON", {
      enumerable: true,
      get: function get() {
        return _schema.tableToJSON;
      }
    });
    Object.defineProperty(exports, "taskItem", {
      enumerable: true,
      get: function get() {
        return _schema.taskItem;
      }
    });
    Object.defineProperty(exports, "taskList", {
      enumerable: true,
      get: function get() {
        return _schema.taskList;
      }
    });
    Object.defineProperty(exports, "taskListSelector", {
      enumerable: true,
      get: function get() {
        return _schema.taskListSelector;
      }
    });
    Object.defineProperty(exports, "text", {
      enumerable: true,
      get: function get() {
        return _schema.text;
      }
    });
    Object.defineProperty(exports, "textColor", {
      enumerable: true,
      get: function get() {
        return _schema.textColor;
      }
    });
    Object.defineProperty(exports, "toJSONTableCell", {
      enumerable: true,
      get: function get() {
        return _schema.toJSONTableCell;
      }
    });
    Object.defineProperty(exports, "toJSONTableHeader", {
      enumerable: true,
      get: function get() {
        return _schema.toJSONTableHeader;
      }
    });
    Object.defineProperty(exports, "typeAheadQuery", {
      enumerable: true,
      get: function get() {
        return _schema.typeAheadQuery;
      }
    });
    Object.defineProperty(exports, "underline", {
      enumerable: true,
      get: function get() {
        return _schema.underline;
      }
    });
    Object.defineProperty(exports, "unknownBlock", {
      enumerable: true,
      get: function get() {
        return _schema.unknownBlock;
      }
    });
    Object.defineProperty(exports, "unsupportedBlock", {
      enumerable: true,
      get: function get() {
        return _schema.unsupportedBlock;
      }
    });
    Object.defineProperty(exports, "unsupportedInline", {
      enumerable: true,
      get: function get() {
        return _schema.unsupportedInline;
      }
    });
    Object.defineProperty(exports, "unsupportedMark", {
      enumerable: true,
      get: function get() {
        return _schema.unsupportedMark;
      }
    });
    Object.defineProperty(exports, "unsupportedNodeAttribute", {
      enumerable: true,
      get: function get() {
        return _schema.unsupportedNodeAttribute;
      }
    });
    Object.defineProperty(exports, "unsupportedNodeTypesForMediaCards", {
      enumerable: true,
      get: function get() {
        return _schema.unsupportedNodeTypesForMediaCards;
      }
    });
    Object.defineProperty(exports, "uuid", {
      enumerable: true,
      get: function get() {
        return _utils.uuid;
      }
    });
    var _schema = require_schema();
    var _utils = require_utils3();
  }
});

// node_modules/@atlaskit/editor-json-transformer/dist/cjs/markOverrideRules.js
var require_markOverrideRules = __commonJS({
  "node_modules/@atlaskit/editor-json-transformer/dist/cjs/markOverrideRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.markOverrideRuleFor = void 0;
    var defaultAllowOverrideBehaviour = {
      canOverrideUnsupportedMark: function canOverrideUnsupportedMark() {
        return true;
      }
    };
    var defaultDoNotAllowOverrideBehaviour = {
      canOverrideUnsupportedMark: function canOverrideUnsupportedMark() {
        return false;
      }
    };
    var markOverrideRuleFor = function markOverrideRuleFor2(type) {
      switch (type) {
        case "link":
        case "em":
        case "strong":
        case "strike":
        case "subsup":
        case "underline":
        case "code":
        case "textColor":
        case "confluenceInlineComment":
        case "breakout":
        case "alignment":
        case "indentation":
          return defaultAllowOverrideBehaviour;
        default:
          return defaultDoNotAllowOverrideBehaviour;
      }
    };
    exports.markOverrideRuleFor = markOverrideRuleFor;
  }
});

// node_modules/@atlaskit/adf-utils/dist/cjs/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@atlaskit/adf-utils/dist/cjs/traverse/traverse.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.traverse = traverse;
    exports.validateVisitors = validateVisitors;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function validateVisitors(_visitors) {
      return true;
    }
    function traverse(adf, visitors) {
      if (!validateVisitors(visitors)) {
        throw new Error('Visitors are not valid: "'.concat(Object.keys(visitors).join(", "), '"'));
      }
      return traverseNode(adf, {
        node: void 0
      }, visitors, 0, 0);
    }
    function traverseNode(adfNode, parent, visitors, index, depth) {
      var visitor = visitors[adfNode.type] || visitors["any"];
      var newNode = _objectSpread({}, adfNode);
      if (visitor) {
        var processedNode = visitor(_objectSpread({}, newNode), parent, index, depth);
        if (processedNode === false) {
          return false;
        }
        newNode = processedNode || adfNode;
      }
      if (newNode.content) {
        newNode.content = newNode.content.reduce(function(acc, node, idx) {
          if (!node) {
            return acc;
          }
          var processedNode2 = traverseNode(node, {
            node: newNode,
            parent
          }, visitors, idx, depth + 1);
          if (processedNode2 !== false) {
            acc.push(processedNode2);
          }
          return acc;
        }, []);
      }
      return newNode;
    }
  }
});

// node_modules/@atlaskit/adf-utils/dist/cjs/traverse/map.js
var require_map = __commonJS({
  "node_modules/@atlaskit/adf-utils/dist/cjs/traverse/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.map = map;
    var _traverse = require_traverse();
    function map(adf, callback) {
      var result = [];
      (0, _traverse.traverse)(adf, {
        any: function any(node) {
          result.push(callback(node));
        }
      });
      return result;
    }
  }
});

// node_modules/@atlaskit/adf-utils/dist/cjs/traverse/reduce.js
var require_reduce = __commonJS({
  "node_modules/@atlaskit/adf-utils/dist/cjs/traverse/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reduce = reduce;
    var _traverse = require_traverse();
    function reduce(adf, callback, initial) {
      var result = initial;
      (0, _traverse.traverse)(adf, {
        any: function any(node) {
          result = callback(result, node);
        }
      });
      return result;
    }
  }
});

// node_modules/@atlaskit/adf-utils/dist/cjs/traverse/filter.js
var require_filter = __commonJS({
  "node_modules/@atlaskit/adf-utils/dist/cjs/traverse/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.filter = filter;
    var _traverse = require_traverse();
    function filter(adf, callback) {
      var result = [];
      (0, _traverse.traverse)(adf, {
        any: function any(node) {
          if (callback(node)) {
            result.push(node);
          }
        }
      });
      return result;
    }
  }
});

// node_modules/@atlaskit/adf-utils/dist/cjs/traverse.js
var require_traverse2 = __commonJS({
  "node_modules/@atlaskit/adf-utils/dist/cjs/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "filter", {
      enumerable: true,
      get: function get() {
        return _filter.filter;
      }
    });
    Object.defineProperty(exports, "map", {
      enumerable: true,
      get: function get() {
        return _map.map;
      }
    });
    Object.defineProperty(exports, "reduce", {
      enumerable: true,
      get: function get() {
        return _reduce.reduce;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function get() {
        return _traverse.traverse;
      }
    });
    var _traverse = require_traverse();
    var _map = require_map();
    var _reduce = require_reduce();
    var _filter = require_filter();
  }
});

// node_modules/@atlaskit/editor-json-transformer/dist/cjs/sanitize/remove-marks.js
var require_remove_marks = __commonJS({
  "node_modules/@atlaskit/editor-json-transformer/dist/cjs/sanitize/remove-marks.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removeMarks = removeMarks;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function removeMarks(node) {
      var newNode = _objectSpread({}, node);
      delete newNode.marks;
      return newNode;
    }
  }
});

// node_modules/@atlaskit/editor-json-transformer/dist/cjs/sanitize/sanitize-node.js
var require_sanitize_node = __commonJS({
  "node_modules/@atlaskit/editor-json-transformer/dist/cjs/sanitize/sanitize-node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sanitizeNode = sanitizeNode;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _traverse = require_traverse2();
    var _removeMarks = require_remove_marks();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function sanitizeNode(json) {
      var sanitizedJSON = (0, _traverse.traverse)(json, {
        text: function text(node) {
          if (!node || !Array.isArray(node.marks)) {
            return node;
          }
          return _objectSpread(_objectSpread({}, node), {}, {
            marks: node.marks.filter(function(mark) {
              return mark.type !== "typeAheadQuery";
            })
          });
        },
        status: function status(node) {
          if (node.attrs && !!node.attrs.text) {
            return (0, _removeMarks.removeMarks)(node);
          }
          return false;
        },
        caption: function caption(node) {
          if (node.content) {
            return node;
          }
          return false;
        },
        emoji: _removeMarks.removeMarks,
        mention: _removeMarks.removeMarks,
        date: _removeMarks.removeMarks,
        hardBreak: _removeMarks.removeMarks,
        inlineCard: _removeMarks.removeMarks
      });
      return sanitizedJSON;
    }
  }
});

// node_modules/@atlaskit/editor-json-transformer/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@atlaskit/editor-json-transformer/dist/cjs/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof3 = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SchemaStage = exports.JSONTransformer = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _isEqual = _interopRequireDefault(require_isEqual());
    var _adfSchema = require_cjs6();
    var _schemaDefault = require_default_schema();
    var _markOverrideRules = require_markOverrideRules();
    var _sanitizeNode = require_sanitize_node();
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof3(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input2, hint) {
      if (_typeof3(input2) !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (_typeof3(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var SchemaStage;
    exports.SchemaStage = SchemaStage;
    (function(SchemaStage2) {
      SchemaStage2["FINAL"] = "final";
      SchemaStage2["STAGE_0"] = "stage0";
    })(SchemaStage || (exports.SchemaStage = SchemaStage = {}));
    var isType = function isType2(type) {
      return function(node) {
        return node.type.name === type;
      };
    };
    var isCodeBlock = isType("codeBlock");
    var isMediaNode = isType("media");
    var isMediaInline = isType("mediaInline");
    var isMediaSingleNode = isType("mediaSingle");
    var isMentionNode = isType("mention");
    var isParagraph = isType("paragraph");
    var isHeading = isType("heading");
    var isTable = isType("table");
    var isTableCell = isType("tableCell");
    var isTableHeader = isType("tableHeader");
    var isLinkMark = isType("link");
    var isUnsupportedMark = isType("unsupportedMark");
    var isUnsupportedNodeAttributeMark = isType("unsupportedNodeAttribute");
    var isExpand = isType("expand");
    var isNestedExpand = isType("nestedExpand");
    var isUnsupportedNode = function isUnsupportedNode2(node) {
      return isType("unsupportedBlock")(node) || isType("unsupportedInline")(node);
    };
    var isDataConsumer = isType("dataConsumer");
    var isFragmentMark = isType("fragment");
    var filterNull = function filterNull2(subject) {
      var output = _objectSpread({}, subject);
      for (var key in output) {
        var current = output[key];
        if (current === null) {
          var _output = output, unusedKey = _output[key], filteredObj = (0, _objectWithoutProperties2.default)(_output, [key].map(_toPropertyKey));
          output = filteredObj;
        } else if ((0, _typeof2.default)(current) === "object" && !Array.isArray(current)) {
          output[key] = filterNull2(current);
        }
      }
      return output;
    };
    var createDocFromContent = function createDocFromContent2(content) {
      return {
        version: 1,
        type: "doc",
        content: content || []
      };
    };
    var emptyDoc = createDocFromContent([{
      type: "paragraph",
      content: []
    }]);
    var toJSON = function toJSON2(node) {
      var obj = {
        type: node.type.name
      };
      if (isUnsupportedNode(node)) {
        return node.attrs.originalValue;
      } else if (isMediaNode(node)) {
        obj.attrs = (0, _adfSchema.mediaToJSON)(node).attrs;
      } else if (isMediaSingleNode(node)) {
        obj.attrs = (0, _adfSchema.mediaSingleToJSON)(node).attrs;
      } else if (isMediaInline(node)) {
        obj.attrs = (0, _adfSchema.mediaToJSON)(node).attrs;
      } else if (isMentionNode(node)) {
        obj.attrs = (0, _adfSchema.mentionToJSON)(node).attrs;
      } else if (isCodeBlock(node)) {
        obj.attrs = (0, _adfSchema.codeBlockToJSON)(node).attrs;
      } else if (isTable(node)) {
        obj.attrs = (0, _adfSchema.tableToJSON)(node).attrs;
      } else if (isTableCell(node)) {
        obj.attrs = (0, _adfSchema.toJSONTableCell)(node).attrs;
      } else if (isTableHeader(node)) {
        obj.attrs = (0, _adfSchema.toJSONTableHeader)(node).attrs;
      } else if (isExpand(node) || isNestedExpand(node)) {
        obj.attrs = (0, _adfSchema.expandToJSON)(node).attrs;
      } else if (node.attrs && Object.keys(node.attrs).length) {
        obj.attrs = node.attrs;
      }
      if (obj.attrs) {
        obj.attrs = filterNull(obj.attrs);
      }
      if (node.isText) {
        obj.text = node.textContent;
      } else {
        node.content.forEach(function(child) {
          obj.content = obj.content || [];
          obj.content.push(toJSON2(child));
        });
      }
      if (isParagraph(node) || isHeading(node)) {
        obj.content = obj.content || [];
      }
      if (node.marks.length) {
        var parsedMarks = node.marks.map(function(mark) {
          if (isUnsupportedMark(mark)) {
            return canOverrideMark(mark, node.marks) ? null : mark.attrs.originalValue;
          } else if (isUnsupportedNodeAttributeMark(mark)) {
            return null;
          } else if (isLinkMark(mark)) {
            return (0, _adfSchema.linkToJSON)(mark);
          } else if (isDataConsumer(mark)) {
            var _serialised$attrs$sou;
            var serialised = (0, _adfSchema.dataConsumerToJSON)(mark);
            return !serialised.attrs.sources || ((_serialised$attrs$sou = serialised.attrs.sources) === null || _serialised$attrs$sou === void 0 ? void 0 : _serialised$attrs$sou.length) === 0 ? null : serialised;
          } else if (isFragmentMark(mark)) {
            var fragmentMark = (0, _adfSchema.fragmentToJSON)(mark);
            if (!fragmentMark.attrs.localId) {
              return null;
            }
            return fragmentMark;
          } else {
            return mark.toJSON();
          }
        }).filter(function(maybeMark) {
          return maybeMark !== null;
        });
        obj.marks = (parsedMarks === null || parsedMarks === void 0 ? void 0 : parsedMarks.length) > 0 ? parsedMarks : void 0;
        var nodeAttributeMark = node.marks.find(isUnsupportedNodeAttributeMark);
        if (nodeAttributeMark && nodeAttributeMark.attrs.type.nodeType === obj.type) {
          obj.attrs = _objectSpread({}, getUnwrappedNodeAttributes(node, nodeAttributeMark, obj));
        }
      }
      return obj;
    };
    var canOverrideMark = function canOverrideMark2(mark, existingMarks) {
      if (existingMarks.some(function(e) {
        return mark.attrs.originalValue.type === e.type.name;
      })) {
        return (0, _markOverrideRules.markOverrideRuleFor)(mark.attrs.originalValue.type).canOverrideUnsupportedMark();
      }
      return false;
    };
    var getUnwrappedNodeAttributes = function getUnwrappedNodeAttributes2(node, mark, obj) {
      var nodeAttributes = node.type.spec.attrs;
      var attributes = _objectSpread(_objectSpread({}, mark.attrs.unsupported), obj.attrs);
      for (var key in obj.attrs) {
        if (obj.attrs.hasOwnProperty(key)) {
          var attribute = nodeAttributes ? nodeAttributes[key] : null;
          if (attribute) {
            if (attribute.default === node.attrs[key] && mark.attrs.unsupported[key]) {
              return _objectSpread(_objectSpread({}, attributes), {}, (0, _defineProperty2.default)({}, key, mark.attrs.unsupported[key]));
            }
          }
        }
      }
      return attributes;
    };
    var JSONTransformer2 = /* @__PURE__ */ function() {
      function JSONTransformer3() {
        (0, _classCallCheck2.default)(this, JSONTransformer3);
      }
      (0, _createClass2.default)(JSONTransformer3, [{
        key: "encode",
        value: function encode(node) {
          var content = [];
          node.content.forEach(function(child) {
            content.push((0, _sanitizeNode.sanitizeNode)(toJSON(child)));
          });
          if (!content || (0, _isEqual.default)(content, emptyDoc.content)) {
            return createDocFromContent([]);
          }
          return createDocFromContent(content);
        }
      }, {
        key: "internalParse",
        value: function internalParse(content) {
          var stage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SchemaStage.FINAL;
          var schema = (0, _schemaDefault.getSchemaBasedOnStage)(stage);
          var doc = schema.nodeFromJSON(content);
          doc.check();
          return doc;
        }
      }, {
        key: "parse",
        value: function parse(content, stage) {
          if (content.type !== "doc") {
            throw new Error("Expected content format to be ADF");
          }
          if (!content.content || content.content.length === 0) {
            return this.internalParse(emptyDoc, stage);
          }
          return this.internalParse(content, stage);
        }
        /**
         * This method is used to encode a single node
         */
      }, {
        key: "encodeNode",
        value: function encodeNode(node) {
          return (0, _sanitizeNode.sanitizeNode)(toJSON(node));
        }
      }]);
      return JSONTransformer3;
    }();
    exports.JSONTransformer = JSONTransformer2;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/blockquote.js
var require_blockquote4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/blockquote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.blockquote = void 0;
    var _ = require_encoder();
    var blockquote = function blockquote2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = [];
      node.forEach(function(n) {
        result.push((0, _.encode)(n, context));
      });
      return "{quote}".concat(result.join("\n\n"), "{quote}");
    };
    exports.blockquote = blockquote;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/emoji-unicode-mapping.js
var require_emoji_unicode_mapping = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/emoji-unicode-mapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mapping = void 0;
    var mapping = {
      "1f600": "\u{1F600}",
      "1f603": "\u{1F603}",
      "1f604": "\u{1F604}",
      "1f601": "\u{1F601}",
      "1f606": "\u{1F606}",
      "1f605": "\u{1F605}",
      "1f602": "\u{1F602}",
      "1f923": "\u{1F923}",
      "263a": "\u263A\uFE0F",
      "1f60a": "\u{1F60A}",
      "1f607": "\u{1F607}",
      "1f642": "\u{1F642}",
      "1f643": "\u{1F643}",
      "1f609": "\u{1F609}",
      "1f60c": "\u{1F60C}",
      "1f60d": "\u{1F60D}",
      "1f618": "\u{1F618}",
      "1f617": "\u{1F617}",
      "1f619": "\u{1F619}",
      "1f61a": "\u{1F61A}",
      "1f60b": "\u{1F60B}",
      "1f61c": "\u{1F61C}",
      "1f61d": "\u{1F61D}",
      "1f61b": "\u{1F61B}",
      "1f911": "\u{1F911}",
      "1f917": "\u{1F917}",
      "1f913": "\u{1F913}",
      "1f60e": "\u{1F60E}",
      "1f921": "\u{1F921}",
      "1f920": "\u{1F920}",
      "1f60f": "\u{1F60F}",
      "1f612": "\u{1F612}",
      "1f61e": "\u{1F61E}",
      "1f614": "\u{1F614}",
      "1f61f": "\u{1F61F}",
      "1f615": "\u{1F615}",
      "1f641": "\u{1F641}",
      "2639": "\u2639\uFE0F",
      "1f623": "\u{1F623}",
      "1f616": "\u{1F616}",
      "1f62b": "\u{1F62B}",
      "1f629": "\u{1F629}",
      "1f624": "\u{1F624}",
      "1f620": "\u{1F620}",
      "1f621": "\u{1F621}",
      "1f636": "\u{1F636}",
      "1f610": "\u{1F610}",
      "1f611": "\u{1F611}",
      "1f62f": "\u{1F62F}",
      "1f626": "\u{1F626}",
      "1f627": "\u{1F627}",
      "1f62e": "\u{1F62E}",
      "1f632": "\u{1F632}",
      "1f635": "\u{1F635}",
      "1f633": "\u{1F633}",
      "1f631": "\u{1F631}",
      "1f628": "\u{1F628}",
      "1f630": "\u{1F630}",
      "1f622": "\u{1F622}",
      "1f625": "\u{1F625}",
      "1f924": "\u{1F924}",
      "1f62d": "\u{1F62D}",
      "1f613": "\u{1F613}",
      "1f62a": "\u{1F62A}",
      "1f634": "\u{1F634}",
      "1f644": "\u{1F644}",
      "1f914": "\u{1F914}",
      "1f925": "\u{1F925}",
      "1f62c": "\u{1F62C}",
      "1f910": "\u{1F910}",
      "1f922": "\u{1F922}",
      "1f927": "\u{1F927}",
      "1f637": "\u{1F637}",
      "1f912": "\u{1F912}",
      "1f915": "\u{1F915}",
      "1f608": "\u{1F608}",
      "1f47f": "\u{1F47F}",
      "1f479": "\u{1F479}",
      "1f47a": "\u{1F47A}",
      "1f4a9": "\u{1F4A9}",
      "1f47b": "\u{1F47B}",
      "1f480": "\u{1F480}",
      "2620": "\u2620\uFE0F",
      "1f47d": "\u{1F47D}",
      "1f47e": "\u{1F47E}",
      "1f916": "\u{1F916}",
      "1f383": "\u{1F383}",
      "1f63a": "\u{1F63A}",
      "1f638": "\u{1F638}",
      "1f639": "\u{1F639}",
      "1f63b": "\u{1F63B}",
      "1f63c": "\u{1F63C}",
      "1f63d": "\u{1F63D}",
      "1f640": "\u{1F640}",
      "1f63f": "\u{1F63F}",
      "1f63e": "\u{1F63E}",
      "1f450": "\u{1F450}",
      "1f64c": "\u{1F64C}",
      "1f44f": "\u{1F44F}",
      "1f64f": "\u{1F64F}",
      "1f91d": "\u{1F91D}",
      "1f44d": "\u{1F44D}",
      "1f44e": "\u{1F44E}",
      "1f44a": "\u{1F44A}",
      "270a": "\u270A",
      "1f91b": "\u{1F91B}",
      "1f91c": "\u{1F91C}",
      "1f91e": "\u{1F91E}",
      "270c": "\u270C\uFE0F",
      "1f918": "\u{1F918}",
      "1f44c": "\u{1F44C}",
      "1f448": "\u{1F448}",
      "1f449": "\u{1F449}",
      "1f446": "\u{1F446}",
      "1f447": "\u{1F447}",
      "261d": "\u261D\uFE0F",
      "270b": "\u270B",
      "1f91a": "\u{1F91A}",
      "1f590": "\u{1F590}\uFE0F",
      "1f596": "\u{1F596}",
      "1f44b": "\u{1F44B}",
      "1f919": "\u{1F919}",
      "1f4aa": "\u{1F4AA}",
      "1f595": "\u{1F595}",
      "270d": "\u270D\uFE0F",
      "1f933": "\u{1F933}",
      "1f485": "\u{1F485}",
      "1f48d": "\u{1F48D}",
      "1f484": "\u{1F484}",
      "1f48b": "\u{1F48B}",
      "1f444": "\u{1F444}",
      "1f445": "\u{1F445}",
      "1f442": "\u{1F442}",
      "1f443": "\u{1F443}",
      "1f463": "\u{1F463}",
      "1f441": "\u{1F441}\uFE0F",
      "1f440": "\u{1F440}",
      "1f5e3": "\u{1F5E3}\uFE0F",
      "1f464": "\u{1F464}",
      "1f465": "\u{1F465}",
      "1f476": "\u{1F476}",
      "1f466": "\u{1F466}",
      "1f467": "\u{1F467}",
      "1f468": "\u{1F468}",
      "1f469": "\u{1F469}",
      "1f471-200d-2640-fe0f": "\u{1F471}\u200D\u2640\uFE0F",
      "1f471": "\u{1F471}",
      "1f471-200d-2642-fe0f": "\u{1F471}\u200D\u2642\uFE0F",
      "1f474": "\u{1F474}",
      "1f475": "\u{1F475}",
      "1f472": "\u{1F472}",
      "1f473-200d-2640-fe0f": "\u{1F473}\u200D\u2640\uFE0F",
      "1f473": "\u{1F473}",
      "1f473-200d-2642-fe0f": "\u{1F473}\u200D\u2642\uFE0F",
      "1f46e-200d-2640-fe0f": "\u{1F46E}\u200D\u2640\uFE0F",
      "1f46e": "\u{1F46E}",
      "1f46e-200d-2642-fe0f": "\u{1F46E}\u200D\u2642\uFE0F",
      "1f477-200d-2640-fe0f": "\u{1F477}\u200D\u2640\uFE0F",
      "1f477": "\u{1F477}",
      "1f477-200d-2642-fe0f": "\u{1F477}\u200D\u2642\uFE0F",
      "1f482-200d-2640-fe0f": "\u{1F482}\u200D\u2640\uFE0F",
      "1f482": "\u{1F482}",
      "1f482-200d-2642-fe0f": "\u{1F482}\u200D\u2642\uFE0F",
      "1f575-fe0f-200d-2640-fe0f": "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
      "1f575": "\u{1F575}\uFE0F",
      "1f575-fe0f-200d-2642-fe0f": "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
      "1f469-200d-2695-fe0f": "\u{1F469}\u200D\u2695\uFE0F",
      "1f468-200d-2695-fe0f": "\u{1F468}\u200D\u2695\uFE0F",
      "1f469-200d-1f33e": "\u{1F469}\u200D\u{1F33E}",
      "1f468-200d-1f33e": "\u{1F468}\u200D\u{1F33E}",
      "1f469-200d-1f373": "\u{1F469}\u200D\u{1F373}",
      "1f468-200d-1f373": "\u{1F468}\u200D\u{1F373}",
      "1f469-200d-1f393": "\u{1F469}\u200D\u{1F393}",
      "1f468-200d-1f393": "\u{1F468}\u200D\u{1F393}",
      "1f469-200d-1f3a4": "\u{1F469}\u200D\u{1F3A4}",
      "1f468-200d-1f3a4": "\u{1F468}\u200D\u{1F3A4}",
      "1f469-200d-1f3eb": "\u{1F469}\u200D\u{1F3EB}",
      "1f468-200d-1f3eb": "\u{1F468}\u200D\u{1F3EB}",
      "1f469-200d-1f3ed": "\u{1F469}\u200D\u{1F3ED}",
      "1f468-200d-1f3ed": "\u{1F468}\u200D\u{1F3ED}",
      "1f469-200d-1f4bb": "\u{1F469}\u200D\u{1F4BB}",
      "1f468-200d-1f4bb": "\u{1F468}\u200D\u{1F4BB}",
      "1f469-200d-1f4bc": "\u{1F469}\u200D\u{1F4BC}",
      "1f468-200d-1f4bc": "\u{1F468}\u200D\u{1F4BC}",
      "1f469-200d-1f527": "\u{1F469}\u200D\u{1F527}",
      "1f468-200d-1f527": "\u{1F468}\u200D\u{1F527}",
      "1f469-200d-1f52c": "\u{1F469}\u200D\u{1F52C}",
      "1f468-200d-1f52c": "\u{1F468}\u200D\u{1F52C}",
      "1f469-200d-1f3a8": "\u{1F469}\u200D\u{1F3A8}",
      "1f468-200d-1f3a8": "\u{1F468}\u200D\u{1F3A8}",
      "1f469-200d-1f692": "\u{1F469}\u200D\u{1F692}",
      "1f468-200d-1f692": "\u{1F468}\u200D\u{1F692}",
      "1f469-200d-2708-fe0f": "\u{1F469}\u200D\u2708\uFE0F",
      "1f468-200d-2708-fe0f": "\u{1F468}\u200D\u2708\uFE0F",
      "1f469-200d-1f680": "\u{1F469}\u200D\u{1F680}",
      "1f468-200d-1f680": "\u{1F468}\u200D\u{1F680}",
      "1f469-200d-2696-fe0f": "\u{1F469}\u200D\u2696\uFE0F",
      "1f468-200d-2696-fe0f": "\u{1F468}\u200D\u2696\uFE0F",
      "1f936": "\u{1F936}",
      "1f385": "\u{1F385}",
      "1f478": "\u{1F478}",
      "1f934": "\u{1F934}",
      "1f470": "\u{1F470}",
      "1f935": "\u{1F935}",
      "1f47c": "\u{1F47C}",
      "1f930": "\u{1F930}",
      "1f647-200d-2640-fe0f": "\u{1F647}\u200D\u2640\uFE0F",
      "1f647": "\u{1F647}",
      "1f647-200d-2642-fe0f": "\u{1F647}\u200D\u2642\uFE0F",
      "1f481": "\u{1F481}",
      "1f481-200d-2642-fe0f": "\u{1F481}\u200D\u2642\uFE0F",
      "1f481-200d-2640-fe0f": "\u{1F481}\u200D\u2640\uFE0F",
      "1f645": "\u{1F645}",
      "1f645-200d-2642-fe0f": "\u{1F645}\u200D\u2642\uFE0F",
      "1f645-200d-2640-fe0f": "\u{1F645}\u200D\u2640\uFE0F",
      "1f646": "\u{1F646}",
      "1f646-200d-2642-fe0f": "\u{1F646}\u200D\u2642\uFE0F",
      "1f646-200d-2640-fe0f": "\u{1F646}\u200D\u2640\uFE0F",
      "1f64b": "\u{1F64B}",
      "1f64b-200d-2642-fe0f": "\u{1F64B}\u200D\u2642\uFE0F",
      "1f64b-200d-2640-fe0f": "\u{1F64B}\u200D\u2640\uFE0F",
      "1f926-200d-2640-fe0f": "\u{1F926}\u200D\u2640\uFE0F",
      "1f926-200d-2642-fe0f": "\u{1F926}\u200D\u2642\uFE0F",
      "1f926": "\u{1F926}",
      "1f937-200d-2640-fe0f": "\u{1F937}\u200D\u2640\uFE0F",
      "1f937-200d-2642-fe0f": "\u{1F937}\u200D\u2642\uFE0F",
      "1f937": "\u{1F937}",
      "1f64e": "\u{1F64E}",
      "1f64e-200d-2642-fe0f": "\u{1F64E}\u200D\u2642\uFE0F",
      "1f64e-200d-2640-fe0f": "\u{1F64E}\u200D\u2640\uFE0F",
      "1f64d": "\u{1F64D}",
      "1f64d-200d-2642-fe0f": "\u{1F64D}\u200D\u2642\uFE0F",
      "1f64d-200d-2640-fe0f": "\u{1F64D}\u200D\u2640\uFE0F",
      "1f487": "\u{1F487}",
      "1f487-200d-2642-fe0f": "\u{1F487}\u200D\u2642\uFE0F",
      "1f487-200d-2640-fe0f": "\u{1F487}\u200D\u2640\uFE0F",
      "1f486": "\u{1F486}",
      "1f486-200d-2642-fe0f": "\u{1F486}\u200D\u2642\uFE0F",
      "1f486-200d-2640-fe0f": "\u{1F486}\u200D\u2640\uFE0F",
      "1f574": "\u{1F574}\uFE0F",
      "1f483": "\u{1F483}",
      "1f57a": "\u{1F57A}",
      "1f46f": "\u{1F46F}",
      "1f46f-200d-2642-fe0f": "\u{1F46F}\u200D\u2642\uFE0F",
      "1f46f-200d-2640-fe0f": "\u{1F46F}\u200D\u2640\uFE0F",
      "1f6b6-200d-2640-fe0f": "\u{1F6B6}\u200D\u2640\uFE0F",
      "1f6b6": "\u{1F6B6}",
      "1f6b6-200d-2642-fe0f": "\u{1F6B6}\u200D\u2642\uFE0F",
      "1f3c3-200d-2640-fe0f": "\u{1F3C3}\u200D\u2640\uFE0F",
      "1f3c3": "\u{1F3C3}",
      "1f3c3-200d-2642-fe0f": "\u{1F3C3}\u200D\u2642\uFE0F",
      "1f46b": "\u{1F46B}",
      "1f46d": "\u{1F46D}",
      "1f46c": "\u{1F46C}",
      "1f491": "\u{1F491}",
      "1f469-200d-2764-fe0f-200d-1f469": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
      "1f468-200d-2764-fe0f-200d-1f468": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "1f48f": "\u{1F48F}",
      "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
      "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "1f46a": "\u{1F46A}",
      "1f468-200d-1f469-200d-1f467": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
      "1f468-200d-1f469-200d-1f467-200d-1f466": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "1f468-200d-1f469-200d-1f466-200d-1f466": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "1f468-200d-1f469-200d-1f467-200d-1f467": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "1f469-200d-1f469-200d-1f466": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
      "1f469-200d-1f469-200d-1f467": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
      "1f469-200d-1f469-200d-1f467-200d-1f466": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "1f469-200d-1f469-200d-1f466-200d-1f466": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "1f469-200d-1f469-200d-1f467-200d-1f467": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "1f468-200d-1f468-200d-1f466": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
      "1f468-200d-1f468-200d-1f467": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
      "1f468-200d-1f468-200d-1f467-200d-1f466": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "1f468-200d-1f468-200d-1f466-200d-1f466": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "1f468-200d-1f468-200d-1f467-200d-1f467": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "1f469-200d-1f466": "\u{1F469}\u200D\u{1F466}",
      "1f469-200d-1f467": "\u{1F469}\u200D\u{1F467}",
      "1f469-200d-1f467-200d-1f466": "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "1f469-200d-1f466-200d-1f466": "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "1f469-200d-1f467-200d-1f467": "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "1f468-200d-1f466": "\u{1F468}\u200D\u{1F466}",
      "1f468-200d-1f467": "\u{1F468}\u200D\u{1F467}",
      "1f468-200d-1f467-200d-1f466": "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "1f468-200d-1f466-200d-1f466": "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "1f468-200d-1f467-200d-1f467": "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "1f45a": "\u{1F45A}",
      "1f455": "\u{1F455}",
      "1f456": "\u{1F456}",
      "1f454": "\u{1F454}",
      "1f457": "\u{1F457}",
      "1f459": "\u{1F459}",
      "1f458": "\u{1F458}",
      "1f460": "\u{1F460}",
      "1f461": "\u{1F461}",
      "1f462": "\u{1F462}",
      "1f45e": "\u{1F45E}",
      "1f45f": "\u{1F45F}",
      "1f452": "\u{1F452}",
      "1f3a9": "\u{1F3A9}",
      "1f393": "\u{1F393}",
      "1f451": "\u{1F451}",
      "26d1": "\u26D1\uFE0F",
      "1f392": "\u{1F392}",
      "1f45d": "\u{1F45D}",
      "1f45b": "\u{1F45B}",
      "1f45c": "\u{1F45C}",
      "1f4bc": "\u{1F4BC}",
      "1f453": "\u{1F453}",
      "1f576": "\u{1F576}\uFE0F",
      "1f302": "\u{1F302}",
      "2602": "\u2602\uFE0F",
      "1f436": "\u{1F436}",
      "1f431": "\u{1F431}",
      "1f42d": "\u{1F42D}",
      "1f439": "\u{1F439}",
      "1f430": "\u{1F430}",
      "1f98a": "\u{1F98A}",
      "1f43b": "\u{1F43B}",
      "1f43c": "\u{1F43C}",
      "1f428": "\u{1F428}",
      "1f42f": "\u{1F42F}",
      "1f981": "\u{1F981}",
      "1f42e": "\u{1F42E}",
      "1f437": "\u{1F437}",
      "1f43d": "\u{1F43D}",
      "1f438": "\u{1F438}",
      "1f435": "\u{1F435}",
      "1f648": "\u{1F648}",
      "1f649": "\u{1F649}",
      "1f64a": "\u{1F64A}",
      "1f412": "\u{1F412}",
      "1f414": "\u{1F414}",
      "1f427": "\u{1F427}",
      "1f426": "\u{1F426}",
      "1f424": "\u{1F424}",
      "1f423": "\u{1F423}",
      "1f425": "\u{1F425}",
      "1f986": "\u{1F986}",
      "1f985": "\u{1F985}",
      "1f989": "\u{1F989}",
      "1f987": "\u{1F987}",
      "1f43a": "\u{1F43A}",
      "1f417": "\u{1F417}",
      "1f434": "\u{1F434}",
      "1f984": "\u{1F984}",
      "1f41d": "\u{1F41D}",
      "1f41b": "\u{1F41B}",
      "1f98b": "\u{1F98B}",
      "1f40c": "\u{1F40C}",
      "1f41a": "\u{1F41A}",
      "1f41e": "\u{1F41E}",
      "1f41c": "\u{1F41C}",
      "1f577": "\u{1F577}\uFE0F",
      "1f578": "\u{1F578}\uFE0F",
      "1f422": "\u{1F422}",
      "1f40d": "\u{1F40D}",
      "1f98e": "\u{1F98E}",
      "1f982": "\u{1F982}",
      "1f980": "\u{1F980}",
      "1f991": "\u{1F991}",
      "1f419": "\u{1F419}",
      "1f990": "\u{1F990}",
      "1f420": "\u{1F420}",
      "1f41f": "\u{1F41F}",
      "1f421": "\u{1F421}",
      "1f42c": "\u{1F42C}",
      "1f988": "\u{1F988}",
      "1f433": "\u{1F433}",
      "1f40b": "\u{1F40B}",
      "1f40a": "\u{1F40A}",
      "1f406": "\u{1F406}",
      "1f405": "\u{1F405}",
      "1f403": "\u{1F403}",
      "1f402": "\u{1F402}",
      "1f404": "\u{1F404}",
      "1f98c": "\u{1F98C}",
      "1f42a": "\u{1F42A}",
      "1f42b": "\u{1F42B}",
      "1f418": "\u{1F418}",
      "1f98f": "\u{1F98F}",
      "1f98d": "\u{1F98D}",
      "1f40e": "\u{1F40E}",
      "1f416": "\u{1F416}",
      "1f410": "\u{1F410}",
      "1f40f": "\u{1F40F}",
      "1f411": "\u{1F411}",
      "1f415": "\u{1F415}",
      "1f429": "\u{1F429}",
      "1f408": "\u{1F408}",
      "1f413": "\u{1F413}",
      "1f983": "\u{1F983}",
      "1f54a": "\u{1F54A}\uFE0F",
      "1f407": "\u{1F407}",
      "1f401": "\u{1F401}",
      "1f400": "\u{1F400}",
      "1f43f": "\u{1F43F}\uFE0F",
      "1f43e": "\u{1F43E}",
      "1f409": "\u{1F409}",
      "1f432": "\u{1F432}",
      "1f335": "\u{1F335}",
      "1f384": "\u{1F384}",
      "1f332": "\u{1F332}",
      "1f333": "\u{1F333}",
      "1f334": "\u{1F334}",
      "1f331": "\u{1F331}",
      "1f33f": "\u{1F33F}",
      "2618": "\u2618\uFE0F",
      "1f340": "\u{1F340}",
      "1f38d": "\u{1F38D}",
      "1f38b": "\u{1F38B}",
      "1f343": "\u{1F343}",
      "1f342": "\u{1F342}",
      "1f341": "\u{1F341}",
      "1f344": "\u{1F344}",
      "1f33e": "\u{1F33E}",
      "1f490": "\u{1F490}",
      "1f337": "\u{1F337}",
      "1f339": "\u{1F339}",
      "1f940": "\u{1F940}",
      "1f33b": "\u{1F33B}",
      "1f33c": "\u{1F33C}",
      "1f338": "\u{1F338}",
      "1f33a": "\u{1F33A}",
      "1f30e": "\u{1F30E}",
      "1f30d": "\u{1F30D}",
      "1f30f": "\u{1F30F}",
      "1f315": "\u{1F315}",
      "1f316": "\u{1F316}",
      "1f317": "\u{1F317}",
      "1f318": "\u{1F318}",
      "1f311": "\u{1F311}",
      "1f312": "\u{1F312}",
      "1f313": "\u{1F313}",
      "1f314": "\u{1F314}",
      "1f31a": "\u{1F31A}",
      "1f31d": "\u{1F31D}",
      "1f31e": "\u{1F31E}",
      "1f31b": "\u{1F31B}",
      "1f31c": "\u{1F31C}",
      "1f319": "\u{1F319}",
      "1f4ab": "\u{1F4AB}",
      "2b50": "\u2B50",
      "1f31f": "\u{1F31F}",
      "2728": "\u2728",
      "26a1": "\u26A1",
      "1f525": "\u{1F525}",
      "1f4a5": "\u{1F4A5}",
      "2604": "\u2604\uFE0F",
      "2600": "\u2600\uFE0F",
      "1f324": "\u{1F324}\uFE0F",
      "26c5": "\u26C5",
      "1f325": "\u{1F325}\uFE0F",
      "1f326": "\u{1F326}\uFE0F",
      "1f308": "\u{1F308}",
      "2601": "\u2601\uFE0F",
      "1f327": "\u{1F327}\uFE0F",
      "26c8": "\u26C8\uFE0F",
      "1f329": "\u{1F329}\uFE0F",
      "1f328": "\u{1F328}\uFE0F",
      "2603": "\u2603\uFE0F",
      "26c4": "\u26C4",
      "2744": "\u2744\uFE0F",
      "1f32c": "\u{1F32C}\uFE0F",
      "1f4a8": "\u{1F4A8}",
      "1f32a": "\u{1F32A}\uFE0F",
      "1f32b": "\u{1F32B}\uFE0F",
      "1f30a": "\u{1F30A}",
      "1f4a7": "\u{1F4A7}",
      "1f4a6": "\u{1F4A6}",
      "2614": "\u2614",
      "1f992": "\u{1F992}",
      "1f993": "\u{1F993}",
      "1f994": "\u{1F994}",
      "1f995": "\u{1F995}",
      "1f996": "\u{1F996}",
      "1f997": "\u{1F997}",
      "1f34f": "\u{1F34F}",
      "1f34e": "\u{1F34E}",
      "1f350": "\u{1F350}",
      "1f34a": "\u{1F34A}",
      "1f34b": "\u{1F34B}",
      "1f34c": "\u{1F34C}",
      "1f349": "\u{1F349}",
      "1f347": "\u{1F347}",
      "1f353": "\u{1F353}",
      "1f348": "\u{1F348}",
      "1f352": "\u{1F352}",
      "1f351": "\u{1F351}",
      "1f34d": "\u{1F34D}",
      "1f95d": "\u{1F95D}",
      "1f951": "\u{1F951}",
      "1f345": "\u{1F345}",
      "1f346": "\u{1F346}",
      "1f952": "\u{1F952}",
      "1f955": "\u{1F955}",
      "1f33d": "\u{1F33D}",
      "1f336": "\u{1F336}\uFE0F",
      "1f954": "\u{1F954}",
      "1f360": "\u{1F360}",
      "1f330": "\u{1F330}",
      "1f95c": "\u{1F95C}",
      "1f36f": "\u{1F36F}",
      "1f950": "\u{1F950}",
      "1f35e": "\u{1F35E}",
      "1f956": "\u{1F956}",
      "1f9c0": "\u{1F9C0}",
      "1f95a": "\u{1F95A}",
      "1f373": "\u{1F373}",
      "1f953": "\u{1F953}",
      "1f95e": "\u{1F95E}",
      "1f364": "\u{1F364}",
      "1f357": "\u{1F357}",
      "1f356": "\u{1F356}",
      "1f355": "\u{1F355}",
      "1f32d": "\u{1F32D}",
      "1f354": "\u{1F354}",
      "1f35f": "\u{1F35F}",
      "1f959": "\u{1F959}",
      "1f32e": "\u{1F32E}",
      "1f32f": "\u{1F32F}",
      "1f957": "\u{1F957}",
      "1f958": "\u{1F958}",
      "1f35d": "\u{1F35D}",
      "1f35c": "\u{1F35C}",
      "1f372": "\u{1F372}",
      "1f365": "\u{1F365}",
      "1f363": "\u{1F363}",
      "1f371": "\u{1F371}",
      "1f35b": "\u{1F35B}",
      "1f359": "\u{1F359}",
      "1f35a": "\u{1F35A}",
      "1f358": "\u{1F358}",
      "1f362": "\u{1F362}",
      "1f361": "\u{1F361}",
      "1f367": "\u{1F367}",
      "1f368": "\u{1F368}",
      "1f366": "\u{1F366}",
      "1f370": "\u{1F370}",
      "1f382": "\u{1F382}",
      "1f36e": "\u{1F36E}",
      "1f36d": "\u{1F36D}",
      "1f36c": "\u{1F36C}",
      "1f36b": "\u{1F36B}",
      "1f37f": "\u{1F37F}",
      "1f369": "\u{1F369}",
      "1f36a": "\u{1F36A}",
      "1f95b": "\u{1F95B}",
      "1f37c": "\u{1F37C}",
      "2615": "\u2615",
      "1f375": "\u{1F375}",
      "1f376": "\u{1F376}",
      "1f37a": "\u{1F37A}",
      "1f37b": "\u{1F37B}",
      "1f942": "\u{1F942}",
      "1f377": "\u{1F377}",
      "1f943": "\u{1F943}",
      "1f378": "\u{1F378}",
      "1f379": "\u{1F379}",
      "1f37e": "\u{1F37E}",
      "1f944": "\u{1F944}",
      "1f374": "\u{1F374}",
      "1f37d": "\u{1F37D}\uFE0F",
      "1f95f": "\u{1F95F}",
      "1f960": "\u{1F960}",
      "1f961": "\u{1F961}",
      "1f962": "\u{1F962}",
      "1f963": "\u{1F963}",
      "1f964": "\u{1F964}",
      "1f965": "\u{1F965}",
      "1f966": "\u{1F966}",
      "1f967": "\u{1F967}",
      "1f968": "\u{1F968}",
      "1f969": "\u{1F969}",
      "1f96a": "\u{1F96A}",
      "1f96b": "\u{1F96B}",
      "26bd": "\u26BD",
      "1f3c0": "\u{1F3C0}",
      "1f3c8": "\u{1F3C8}",
      "26be": "\u26BE",
      "1f3be": "\u{1F3BE}",
      "1f3d0": "\u{1F3D0}",
      "1f3c9": "\u{1F3C9}",
      "1f3b1": "\u{1F3B1}",
      "1f3d3": "\u{1F3D3}",
      "1f3f8": "\u{1F3F8}",
      "1f945": "\u{1F945}",
      "1f3d2": "\u{1F3D2}",
      "1f3d1": "\u{1F3D1}",
      "1f3cf": "\u{1F3CF}",
      "26f3": "\u26F3",
      "1f3f9": "\u{1F3F9}",
      "1f3a3": "\u{1F3A3}",
      "1f94a": "\u{1F94A}",
      "1f94b": "\u{1F94B}",
      "26f8": "\u26F8\uFE0F",
      "1f3bf": "\u{1F3BF}",
      "26f7": "\u26F7\uFE0F",
      "1f3c2": "\u{1F3C2}",
      "1f3cb-fe0f-200d-2640-fe0f": "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
      "1f3cb": "\u{1F3CB}\uFE0F",
      "1f3cb-fe0f-200d-2642-fe0f": "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
      "1f93a": "\u{1F93A}",
      "1f93c-200d-2640-fe0f": "\u{1F93C}\u200D\u2640\uFE0F",
      "1f93c-200d-2642-fe0f": "\u{1F93C}\u200D\u2642\uFE0F",
      "1f93c": "\u{1F93C}",
      "1f938-200d-2640-fe0f": "\u{1F938}\u200D\u2640\uFE0F",
      "1f938-200d-2642-fe0f": "\u{1F938}\u200D\u2642\uFE0F",
      "1f938": "\u{1F938}",
      "26f9-fe0f-200d-2640-fe0f": "\u26F9\uFE0F\u200D\u2640\uFE0F",
      "26f9": "\u26F9\uFE0F",
      "26f9-fe0f-200d-2642-fe0f": "\u26F9\uFE0F\u200D\u2642\uFE0F",
      "1f93e-200d-2640-fe0f": "\u{1F93E}\u200D\u2640\uFE0F",
      "1f93e-200d-2642-fe0f": "\u{1F93E}\u200D\u2642\uFE0F",
      "1f93e": "\u{1F93E}",
      "1f3cc-fe0f-200d-2640-fe0f": "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
      "1f3cc": "\u{1F3CC}\uFE0F",
      "1f3cc-fe0f-200d-2642-fe0f": "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
      "1f3c4-200d-2640-fe0f": "\u{1F3C4}\u200D\u2640\uFE0F",
      "1f3c4": "\u{1F3C4}",
      "1f3c4-200d-2642-fe0f": "\u{1F3C4}\u200D\u2642\uFE0F",
      "1f3ca-200d-2640-fe0f": "\u{1F3CA}\u200D\u2640\uFE0F",
      "1f3ca": "\u{1F3CA}",
      "1f3ca-200d-2642-fe0f": "\u{1F3CA}\u200D\u2642\uFE0F",
      "1f93d-200d-2640-fe0f": "\u{1F93D}\u200D\u2640\uFE0F",
      "1f93d-200d-2642-fe0f": "\u{1F93D}\u200D\u2642\uFE0F",
      "1f93d": "\u{1F93D}",
      "1f6a3-200d-2640-fe0f": "\u{1F6A3}\u200D\u2640\uFE0F",
      "1f6a3": "\u{1F6A3}",
      "1f6a3-200d-2642-fe0f": "\u{1F6A3}\u200D\u2642\uFE0F",
      "1f3c7": "\u{1F3C7}",
      "1f6b4-200d-2640-fe0f": "\u{1F6B4}\u200D\u2640\uFE0F",
      "1f6b4": "\u{1F6B4}",
      "1f6b4-200d-2642-fe0f": "\u{1F6B4}\u200D\u2642\uFE0F",
      "1f6b5-200d-2640-fe0f": "\u{1F6B5}\u200D\u2640\uFE0F",
      "1f6b5": "\u{1F6B5}",
      "1f6b5-200d-2642-fe0f": "\u{1F6B5}\u200D\u2642\uFE0F",
      "1f3bd": "\u{1F3BD}",
      "1f3c5": "\u{1F3C5}",
      "1f396": "\u{1F396}\uFE0F",
      "1f947": "\u{1F947}",
      "1f948": "\u{1F948}",
      "1f949": "\u{1F949}",
      "1f3c6": "\u{1F3C6}",
      "1f3f5": "\u{1F3F5}\uFE0F",
      "1f397": "\u{1F397}\uFE0F",
      "1f3ab": "\u{1F3AB}",
      "1f39f": "\u{1F39F}\uFE0F",
      "1f3aa": "\u{1F3AA}",
      "1f939-200d-2640-fe0f": "\u{1F939}\u200D\u2640\uFE0F",
      "1f939-200d-2642-fe0f": "\u{1F939}\u200D\u2642\uFE0F",
      "1f939": "\u{1F939}",
      "1f3ad": "\u{1F3AD}",
      "1f3a8": "\u{1F3A8}",
      "1f3ac": "\u{1F3AC}",
      "1f3a4": "\u{1F3A4}",
      "1f3a7": "\u{1F3A7}",
      "1f3bc": "\u{1F3BC}",
      "1f3b9": "\u{1F3B9}",
      "1f941": "\u{1F941}",
      "1f3b7": "\u{1F3B7}",
      "1f3ba": "\u{1F3BA}",
      "1f3b8": "\u{1F3B8}",
      "1f3bb": "\u{1F3BB}",
      "1f3b2": "\u{1F3B2}",
      "1f3af": "\u{1F3AF}",
      "1f3b3": "\u{1F3B3}",
      "1f3ae": "\u{1F3AE}",
      "1f3b0": "\u{1F3B0}",
      "1f6f7": "\u{1F6F7}",
      "1f931": "\u{1F931}",
      "1f94c": "\u{1F94C}",
      "1f9d6": "\u{1F9D6}",
      "1f9d7": "\u{1F9D7}",
      "1f9d8": "\u{1F9D8}",
      "1f9d6-200d-2640-fe0f": "\u{1F9D6}\u200D\u2640\uFE0F",
      "1f9d6-200d-2642-fe0f": "\u{1F9D6}\u200D\u2642\uFE0F",
      "1f9d7-200d-2640-fe0f": "\u{1F9D7}\u200D\u2640\uFE0F",
      "1f9d7-200d-2642-fe0f": "\u{1F9D7}\u200D\u2642\uFE0F",
      "1f9d8-200d-2640-fe0f": "\u{1F9D8}\u200D\u2640\uFE0F",
      "1f9d8-200d-2642-fe0f": "\u{1F9D8}\u200D\u2642\uFE0F",
      "1f697": "\u{1F697}",
      "1f695": "\u{1F695}",
      "1f699": "\u{1F699}",
      "1f68c": "\u{1F68C}",
      "1f68e": "\u{1F68E}",
      "1f3ce": "\u{1F3CE}\uFE0F",
      "1f693": "\u{1F693}",
      "1f691": "\u{1F691}",
      "1f692": "\u{1F692}",
      "1f690": "\u{1F690}",
      "1f69a": "\u{1F69A}",
      "1f69b": "\u{1F69B}",
      "1f69c": "\u{1F69C}",
      "1f6f4": "\u{1F6F4}",
      "1f6b2": "\u{1F6B2}",
      "1f6f5": "\u{1F6F5}",
      "1f3cd": "\u{1F3CD}\uFE0F",
      "1f6a8": "\u{1F6A8}",
      "1f694": "\u{1F694}",
      "1f68d": "\u{1F68D}",
      "1f698": "\u{1F698}",
      "1f696": "\u{1F696}",
      "1f6a1": "\u{1F6A1}",
      "1f6a0": "\u{1F6A0}",
      "1f69f": "\u{1F69F}",
      "1f683": "\u{1F683}",
      "1f68b": "\u{1F68B}",
      "1f69e": "\u{1F69E}",
      "1f69d": "\u{1F69D}",
      "1f684": "\u{1F684}",
      "1f685": "\u{1F685}",
      "1f688": "\u{1F688}",
      "1f682": "\u{1F682}",
      "1f686": "\u{1F686}",
      "1f687": "\u{1F687}",
      "1f68a": "\u{1F68A}",
      "1f689": "\u{1F689}",
      "1f681": "\u{1F681}",
      "1f6e9": "\u{1F6E9}\uFE0F",
      "2708": "\u2708\uFE0F",
      "1f6eb": "\u{1F6EB}",
      "1f6ec": "\u{1F6EC}",
      "1f680": "\u{1F680}",
      "1f6f0": "\u{1F6F0}\uFE0F",
      "1f4ba": "\u{1F4BA}",
      "1f6f6": "\u{1F6F6}",
      "26f5": "\u26F5",
      "1f6e5": "\u{1F6E5}\uFE0F",
      "1f6a4": "\u{1F6A4}",
      "1f6f3": "\u{1F6F3}\uFE0F",
      "26f4": "\u26F4\uFE0F",
      "1f6a2": "\u{1F6A2}",
      "2693": "\u2693",
      "1f6a7": "\u{1F6A7}",
      "26fd": "\u26FD",
      "1f68f": "\u{1F68F}",
      "1f6a6": "\u{1F6A6}",
      "1f6a5": "\u{1F6A5}",
      "1f5fa": "\u{1F5FA}\uFE0F",
      "1f5ff": "\u{1F5FF}",
      "1f5fd": "\u{1F5FD}",
      "26f2": "\u26F2",
      "1f5fc": "\u{1F5FC}",
      "1f3f0": "\u{1F3F0}",
      "1f3ef": "\u{1F3EF}",
      "1f3df": "\u{1F3DF}\uFE0F",
      "1f3a1": "\u{1F3A1}",
      "1f3a2": "\u{1F3A2}",
      "1f3a0": "\u{1F3A0}",
      "26f1": "\u26F1\uFE0F",
      "1f3d6": "\u{1F3D6}\uFE0F",
      "1f3dd": "\u{1F3DD}\uFE0F",
      "26f0": "\u26F0\uFE0F",
      "1f3d4": "\u{1F3D4}\uFE0F",
      "1f5fb": "\u{1F5FB}",
      "1f30b": "\u{1F30B}",
      "1f3dc": "\u{1F3DC}\uFE0F",
      "1f3d5": "\u{1F3D5}\uFE0F",
      "26fa": "\u26FA",
      "1f6e4": "\u{1F6E4}\uFE0F",
      "1f6e3": "\u{1F6E3}\uFE0F",
      "1f3d7": "\u{1F3D7}\uFE0F",
      "1f3ed": "\u{1F3ED}",
      "1f3e0": "\u{1F3E0}",
      "1f3e1": "\u{1F3E1}",
      "1f3d8": "\u{1F3D8}\uFE0F",
      "1f3da": "\u{1F3DA}\uFE0F",
      "1f3e2": "\u{1F3E2}",
      "1f3ec": "\u{1F3EC}",
      "1f3e3": "\u{1F3E3}",
      "1f3e4": "\u{1F3E4}",
      "1f3e5": "\u{1F3E5}",
      "1f3e6": "\u{1F3E6}",
      "1f3e8": "\u{1F3E8}",
      "1f3ea": "\u{1F3EA}",
      "1f3eb": "\u{1F3EB}",
      "1f3e9": "\u{1F3E9}",
      "1f492": "\u{1F492}",
      "1f3db": "\u{1F3DB}\uFE0F",
      "26ea": "\u26EA",
      "1f54c": "\u{1F54C}",
      "1f54d": "\u{1F54D}",
      "1f54b": "\u{1F54B}",
      "26e9": "\u26E9\uFE0F",
      "1f5fe": "\u{1F5FE}",
      "1f391": "\u{1F391}",
      "1f3de": "\u{1F3DE}\uFE0F",
      "1f305": "\u{1F305}",
      "1f304": "\u{1F304}",
      "1f320": "\u{1F320}",
      "1f387": "\u{1F387}",
      "1f386": "\u{1F386}",
      "1f307": "\u{1F307}",
      "1f306": "\u{1F306}",
      "1f3d9": "\u{1F3D9}\uFE0F",
      "1f303": "\u{1F303}",
      "1f30c": "\u{1F30C}",
      "1f309": "\u{1F309}",
      "1f301": "\u{1F301}",
      "1f6f8": "\u{1F6F8}",
      "231a": "\u231A",
      "1f4f1": "\u{1F4F1}",
      "1f4f2": "\u{1F4F2}",
      "1f4bb": "\u{1F4BB}",
      "2328": "\u2328\uFE0F",
      "1f5a5": "\u{1F5A5}\uFE0F",
      "1f5a8": "\u{1F5A8}\uFE0F",
      "1f5b1": "\u{1F5B1}\uFE0F",
      "1f5b2": "\u{1F5B2}\uFE0F",
      "1f579": "\u{1F579}\uFE0F",
      "1f5dc": "\u{1F5DC}\uFE0F",
      "1f4bd": "\u{1F4BD}",
      "1f4be": "\u{1F4BE}",
      "1f4bf": "\u{1F4BF}",
      "1f4c0": "\u{1F4C0}",
      "1f4fc": "\u{1F4FC}",
      "1f4f7": "\u{1F4F7}",
      "1f4f8": "\u{1F4F8}",
      "1f4f9": "\u{1F4F9}",
      "1f3a5": "\u{1F3A5}",
      "1f4fd": "\u{1F4FD}\uFE0F",
      "1f39e": "\u{1F39E}\uFE0F",
      "1f4de": "\u{1F4DE}",
      "260e": "\u260E\uFE0F",
      "1f4df": "\u{1F4DF}",
      "1f4e0": "\u{1F4E0}",
      "1f4fa": "\u{1F4FA}",
      "1f4fb": "\u{1F4FB}",
      "1f399": "\u{1F399}\uFE0F",
      "1f39a": "\u{1F39A}\uFE0F",
      "1f39b": "\u{1F39B}\uFE0F",
      "23f1": "\u23F1\uFE0F",
      "23f2": "\u23F2\uFE0F",
      "23f0": "\u23F0",
      "1f570": "\u{1F570}\uFE0F",
      "231b": "\u231B",
      "23f3": "\u23F3",
      "1f4e1": "\u{1F4E1}",
      "1f50b": "\u{1F50B}",
      "1f50c": "\u{1F50C}",
      "1f4a1": "\u{1F4A1}",
      "1f526": "\u{1F526}",
      "1f56f": "\u{1F56F}\uFE0F",
      "1f5d1": "\u{1F5D1}\uFE0F",
      "1f6e2": "\u{1F6E2}\uFE0F",
      "1f4b8": "\u{1F4B8}",
      "1f4b5": "\u{1F4B5}",
      "1f4b4": "\u{1F4B4}",
      "1f4b6": "\u{1F4B6}",
      "1f4b7": "\u{1F4B7}",
      "1f4b0": "\u{1F4B0}",
      "1f4b3": "\u{1F4B3}",
      "1f48e": "\u{1F48E}",
      "2696": "\u2696\uFE0F",
      "1f527": "\u{1F527}",
      "1f528": "\u{1F528}",
      "2692": "\u2692\uFE0F",
      "1f6e0": "\u{1F6E0}\uFE0F",
      "26cf": "\u26CF\uFE0F",
      "1f529": "\u{1F529}",
      "2699": "\u2699\uFE0F",
      "26d3": "\u26D3\uFE0F",
      "1f52b": "\u{1F52B}",
      "1f4a3": "\u{1F4A3}",
      "1f52a": "\u{1F52A}",
      "1f5e1": "\u{1F5E1}\uFE0F",
      "2694": "\u2694\uFE0F",
      "1f6e1": "\u{1F6E1}\uFE0F",
      "1f6ac": "\u{1F6AC}",
      "26b0": "\u26B0\uFE0F",
      "26b1": "\u26B1\uFE0F",
      "1f3fa": "\u{1F3FA}",
      "1f52e": "\u{1F52E}",
      "1f4ff": "\u{1F4FF}",
      "1f488": "\u{1F488}",
      "2697": "\u2697\uFE0F",
      "1f52d": "\u{1F52D}",
      "1f52c": "\u{1F52C}",
      "1f573": "\u{1F573}\uFE0F",
      "1f48a": "\u{1F48A}",
      "1f489": "\u{1F489}",
      "1f321": "\u{1F321}\uFE0F",
      "1f6bd": "\u{1F6BD}",
      "1f6b0": "\u{1F6B0}",
      "1f6bf": "\u{1F6BF}",
      "1f6c1": "\u{1F6C1}",
      "1f6c0": "\u{1F6C0}",
      "1f6ce": "\u{1F6CE}\uFE0F",
      "1f511": "\u{1F511}",
      "1f5dd": "\u{1F5DD}\uFE0F",
      "1f6aa": "\u{1F6AA}",
      "1f6cb": "\u{1F6CB}\uFE0F",
      "1f6cf": "\u{1F6CF}\uFE0F",
      "1f6cc": "\u{1F6CC}",
      "1f5bc": "\u{1F5BC}\uFE0F",
      "1f6cd": "\u{1F6CD}\uFE0F",
      "1f6d2": "\u{1F6D2}",
      "1f381": "\u{1F381}",
      "1f388": "\u{1F388}",
      "1f38f": "\u{1F38F}",
      "1f380": "\u{1F380}",
      "1f38a": "\u{1F38A}",
      "1f389": "\u{1F389}",
      "1f38e": "\u{1F38E}",
      "1f3ee": "\u{1F3EE}",
      "1f390": "\u{1F390}",
      "2709": "\u2709\uFE0F",
      "1f4e9": "\u{1F4E9}",
      "1f4e8": "\u{1F4E8}",
      "1f4e7": "\u{1F4E7}",
      "1f48c": "\u{1F48C}",
      "1f4e5": "\u{1F4E5}",
      "1f4e4": "\u{1F4E4}",
      "1f4e6": "\u{1F4E6}",
      "1f3f7": "\u{1F3F7}\uFE0F",
      "1f4ea": "\u{1F4EA}",
      "1f4eb": "\u{1F4EB}",
      "1f4ec": "\u{1F4EC}",
      "1f4ed": "\u{1F4ED}",
      "1f4ee": "\u{1F4EE}",
      "1f4ef": "\u{1F4EF}",
      "1f4dc": "\u{1F4DC}",
      "1f4c3": "\u{1F4C3}",
      "1f4c4": "\u{1F4C4}",
      "1f4d1": "\u{1F4D1}",
      "1f4ca": "\u{1F4CA}",
      "1f4c8": "\u{1F4C8}",
      "1f4c9": "\u{1F4C9}",
      "1f5d2": "\u{1F5D2}\uFE0F",
      "1f5d3": "\u{1F5D3}\uFE0F",
      "1f4c6": "\u{1F4C6}",
      "1f4c5": "\u{1F4C5}",
      "1f4c7": "\u{1F4C7}",
      "1f5c3": "\u{1F5C3}\uFE0F",
      "1f5f3": "\u{1F5F3}\uFE0F",
      "1f5c4": "\u{1F5C4}\uFE0F",
      "1f4cb": "\u{1F4CB}",
      "1f4c1": "\u{1F4C1}",
      "1f4c2": "\u{1F4C2}",
      "1f5c2": "\u{1F5C2}\uFE0F",
      "1f5de": "\u{1F5DE}\uFE0F",
      "1f4f0": "\u{1F4F0}",
      "1f4d3": "\u{1F4D3}",
      "1f4d4": "\u{1F4D4}",
      "1f4d2": "\u{1F4D2}",
      "1f4d5": "\u{1F4D5}",
      "1f4d7": "\u{1F4D7}",
      "1f4d8": "\u{1F4D8}",
      "1f4d9": "\u{1F4D9}",
      "1f4da": "\u{1F4DA}",
      "1f4d6": "\u{1F4D6}",
      "1f516": "\u{1F516}",
      "1f517": "\u{1F517}",
      "1f4ce": "\u{1F4CE}",
      "1f587": "\u{1F587}\uFE0F",
      "1f4d0": "\u{1F4D0}",
      "1f4cf": "\u{1F4CF}",
      "1f4cc": "\u{1F4CC}",
      "1f4cd": "\u{1F4CD}",
      "2702": "\u2702\uFE0F",
      "1f58a": "\u{1F58A}\uFE0F",
      "1f58b": "\u{1F58B}\uFE0F",
      "2712": "\u2712\uFE0F",
      "1f58c": "\u{1F58C}\uFE0F",
      "1f58d": "\u{1F58D}\uFE0F",
      "1f4dd": "\u{1F4DD}",
      "270f": "\u270F\uFE0F",
      "1f50d": "\u{1F50D}",
      "1f50e": "\u{1F50E}",
      "1f50f": "\u{1F50F}",
      "1f510": "\u{1F510}",
      "1f512": "\u{1F512}",
      "1f513": "\u{1F513}",
      "1f9e1": "\u{1F9E1}",
      "2764": "\u2764\uFE0F",
      "1f49b": "\u{1F49B}",
      "1f49a": "\u{1F49A}",
      "1f499": "\u{1F499}",
      "1f49c": "\u{1F49C}",
      "1f5a4": "\u{1F5A4}",
      "1f494": "\u{1F494}",
      "2763": "\u2763\uFE0F",
      "1f495": "\u{1F495}",
      "1f49e": "\u{1F49E}",
      "1f493": "\u{1F493}",
      "1f497": "\u{1F497}",
      "1f496": "\u{1F496}",
      "1f498": "\u{1F498}",
      "1f49d": "\u{1F49D}",
      "1f49f": "\u{1F49F}",
      "262e": "\u262E\uFE0F",
      "271d": "\u271D\uFE0F",
      "262a": "\u262A\uFE0F",
      "1f549": "\u{1F549}\uFE0F",
      "2638": "\u2638\uFE0F",
      "2721": "\u2721\uFE0F",
      "1f52f": "\u{1F52F}",
      "1f54e": "\u{1F54E}",
      "262f": "\u262F\uFE0F",
      "2626": "\u2626\uFE0F",
      "1f6d0": "\u{1F6D0}",
      "26ce": "\u26CE",
      "2648": "\u2648",
      "2649": "\u2649",
      "264a": "\u264A",
      "264b": "\u264B",
      "264c": "\u264C",
      "264d": "\u264D",
      "264e": "\u264E",
      "264f": "\u264F",
      "2650": "\u2650",
      "2651": "\u2651",
      "2652": "\u2652",
      "2653": "\u2653",
      "1f194": "\u{1F194}",
      "269b": "\u269B\uFE0F",
      "1f251": "\u{1F251}",
      "2622": "\u2622\uFE0F",
      "2623": "\u2623\uFE0F",
      "1f4f4": "\u{1F4F4}",
      "1f4f3": "\u{1F4F3}",
      "1f236": "\u{1F236}",
      "1f21a": "\u{1F21A}",
      "1f238": "\u{1F238}",
      "1f23a": "\u{1F23A}",
      "1f237": "\u{1F237}\uFE0F",
      "2734": "\u2734\uFE0F",
      "1f19a": "\u{1F19A}",
      "1f4ae": "\u{1F4AE}",
      "1f250": "\u{1F250}",
      "3299": "\u3299\uFE0F",
      "3297": "\u3297\uFE0F",
      "1f234": "\u{1F234}",
      "1f235": "\u{1F235}",
      "1f239": "\u{1F239}",
      "1f232": "\u{1F232}",
      "1f170": "\u{1F170}\uFE0F",
      "1f171": "\u{1F171}\uFE0F",
      "1f18e": "\u{1F18E}",
      "1f191": "\u{1F191}",
      "1f17e": "\u{1F17E}\uFE0F",
      "1f198": "\u{1F198}",
      "274c": "\u274C",
      "2b55": "\u2B55",
      "1f6d1": "\u{1F6D1}",
      "26d4": "\u26D4",
      "1f4db": "\u{1F4DB}",
      "1f6ab": "\u{1F6AB}",
      "1f4af": "\u{1F4AF}",
      "1f4a2": "\u{1F4A2}",
      "2668": "\u2668\uFE0F",
      "1f6b7": "\u{1F6B7}",
      "1f6af": "\u{1F6AF}",
      "1f6b3": "\u{1F6B3}",
      "1f6b1": "\u{1F6B1}",
      "1f51e": "\u{1F51E}",
      "1f4f5": "\u{1F4F5}",
      "1f6ad": "\u{1F6AD}",
      "2757": "\u2757",
      "2755": "\u2755",
      "2753": "\u2753",
      "2754": "\u2754",
      "203c": "\u203C\uFE0F",
      "2049": "\u2049\uFE0F",
      "1f505": "\u{1F505}",
      "1f506": "\u{1F506}",
      "303d": "\u303D\uFE0F",
      "26a0": "\u26A0\uFE0F",
      "1f6b8": "\u{1F6B8}",
      "1f531": "\u{1F531}",
      "269c": "\u269C\uFE0F",
      "1f530": "\u{1F530}",
      "267b": "\u267B\uFE0F",
      "2705": "\u2705",
      "1f22f": "\u{1F22F}",
      "1f4b9": "\u{1F4B9}",
      "2747": "\u2747\uFE0F",
      "2733": "\u2733\uFE0F",
      "274e": "\u274E",
      "1f310": "\u{1F310}",
      "1f4a0": "\u{1F4A0}",
      "24c2": "\u24C2\uFE0F",
      "1f300": "\u{1F300}",
      "1f4a4": "\u{1F4A4}",
      "1f3e7": "\u{1F3E7}",
      "1f6be": "\u{1F6BE}",
      "267f": "\u267F",
      "1f17f": "\u{1F17F}\uFE0F",
      "1f233": "\u{1F233}",
      "1f202": "\u{1F202}\uFE0F",
      "1f6c2": "\u{1F6C2}",
      "1f6c3": "\u{1F6C3}",
      "1f6c4": "\u{1F6C4}",
      "1f6c5": "\u{1F6C5}",
      "1f6b9": "\u{1F6B9}",
      "1f6ba": "\u{1F6BA}",
      "1f6bc": "\u{1F6BC}",
      "1f6bb": "\u{1F6BB}",
      "1f6ae": "\u{1F6AE}",
      "1f3a6": "\u{1F3A6}",
      "1f4f6": "\u{1F4F6}",
      "1f201": "\u{1F201}",
      "1f523": "\u{1F523}",
      "2139": "\u2139\uFE0F",
      "1f524": "\u{1F524}",
      "1f521": "\u{1F521}",
      "1f520": "\u{1F520}",
      "1f196": "\u{1F196}",
      "1f197": "\u{1F197}",
      "1f199": "\u{1F199}",
      "1f192": "\u{1F192}",
      "1f195": "\u{1F195}",
      "1f193": "\u{1F193}",
      "30-20e3": "0\uFE0F\u20E3",
      "31-20e3": "1\uFE0F\u20E3",
      "32-20e3": "2\uFE0F\u20E3",
      "33-20e3": "3\uFE0F\u20E3",
      "34-20e3": "4\uFE0F\u20E3",
      "35-20e3": "5\uFE0F\u20E3",
      "36-20e3": "6\uFE0F\u20E3",
      "37-20e3": "7\uFE0F\u20E3",
      "38-20e3": "8\uFE0F\u20E3",
      "39-20e3": "9\uFE0F\u20E3",
      "1f51f": "\u{1F51F}",
      "1f522": "\u{1F522}",
      "23-20e3": "#\uFE0F\u20E3",
      "2a-20e3": "*\uFE0F\u20E3",
      "25b6": "\u25B6\uFE0F",
      "23f8": "\u23F8\uFE0F",
      "23ef": "\u23EF\uFE0F",
      "23f9": "\u23F9\uFE0F",
      "23fa": "\u23FA\uFE0F",
      "23cf": "\u23CF\uFE0F",
      "23ed": "\u23ED\uFE0F",
      "23ee": "\u23EE\uFE0F",
      "23e9": "\u23E9",
      "23ea": "\u23EA",
      "23eb": "\u23EB",
      "23ec": "\u23EC",
      "25c0": "\u25C0\uFE0F",
      "1f53c": "\u{1F53C}",
      "1f53d": "\u{1F53D}",
      "27a1": "\u27A1\uFE0F",
      "2b05": "\u2B05\uFE0F",
      "2b06": "\u2B06\uFE0F",
      "2b07": "\u2B07\uFE0F",
      "2197": "\u2197\uFE0F",
      "2198": "\u2198\uFE0F",
      "2199": "\u2199\uFE0F",
      "2196": "\u2196\uFE0F",
      "2195": "\u2195\uFE0F",
      "2194": "\u2194\uFE0F",
      "21aa": "\u21AA\uFE0F",
      "21a9": "\u21A9\uFE0F",
      "2934": "\u2934\uFE0F",
      "2935": "\u2935\uFE0F",
      "1f500": "\u{1F500}",
      "1f501": "\u{1F501}",
      "1f502": "\u{1F502}",
      "1f504": "\u{1F504}",
      "1f503": "\u{1F503}",
      "1f3b5": "\u{1F3B5}",
      "1f3b6": "\u{1F3B6}",
      "2795": "\u2795",
      "2796": "\u2796",
      "2797": "\u2797",
      "2716": "\u2716\uFE0F",
      "1f4b2": "\u{1F4B2}",
      "1f4b1": "\u{1F4B1}",
      "2122": "\u2122\uFE0F",
      a9: "\xA9\uFE0F",
      ae: "\xAE\uFE0F",
      "3030": "\u3030\uFE0F",
      "27b0": "\u27B0",
      "27bf": "\u27BF",
      "1f51a": "\u{1F51A}",
      "1f519": "\u{1F519}",
      "1f51b": "\u{1F51B}",
      "1f51d": "\u{1F51D}",
      "1f51c": "\u{1F51C}",
      "2714": "\u2714\uFE0F",
      "2611": "\u2611\uFE0F",
      "1f518": "\u{1F518}",
      "26aa": "\u26AA",
      "26ab": "\u26AB",
      "1f534": "\u{1F534}",
      "1f535": "\u{1F535}",
      "1f53a": "\u{1F53A}",
      "1f53b": "\u{1F53B}",
      "1f538": "\u{1F538}",
      "1f539": "\u{1F539}",
      "1f536": "\u{1F536}",
      "1f537": "\u{1F537}",
      "1f533": "\u{1F533}",
      "1f532": "\u{1F532}",
      "25aa": "\u25AA\uFE0F",
      "25ab": "\u25AB\uFE0F",
      "25fe": "\u25FE",
      "25fd": "\u25FD",
      "25fc": "\u25FC\uFE0F",
      "25fb": "\u25FB\uFE0F",
      "2b1b": "\u2B1B",
      "2b1c": "\u2B1C",
      "1f508": "\u{1F508}",
      "1f507": "\u{1F507}",
      "1f509": "\u{1F509}",
      "1f50a": "\u{1F50A}",
      "1f514": "\u{1F514}",
      "1f515": "\u{1F515}",
      "1f4e3": "\u{1F4E3}",
      "1f4e2": "\u{1F4E2}",
      "1f5e8": "\u{1F5E8}\uFE0F",
      "1f441-fe0f-200d-1f5e8-fe0f": "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F",
      "1f4ac": "\u{1F4AC}",
      "1f4ad": "\u{1F4AD}",
      "1f5ef": "\u{1F5EF}\uFE0F",
      "2660": "\u2660\uFE0F",
      "2663": "\u2663\uFE0F",
      "2665": "\u2665\uFE0F",
      "2666": "\u2666\uFE0F",
      "1f0cf": "\u{1F0CF}",
      "1f3b4": "\u{1F3B4}",
      "1f004": "\u{1F004}",
      "1f550": "\u{1F550}",
      "1f551": "\u{1F551}",
      "1f552": "\u{1F552}",
      "1f553": "\u{1F553}",
      "1f554": "\u{1F554}",
      "1f555": "\u{1F555}",
      "1f556": "\u{1F556}",
      "1f557": "\u{1F557}",
      "1f558": "\u{1F558}",
      "1f559": "\u{1F559}",
      "1f55a": "\u{1F55A}",
      "1f55b": "\u{1F55B}",
      "1f55c": "\u{1F55C}",
      "1f55d": "\u{1F55D}",
      "1f55e": "\u{1F55E}",
      "1f55f": "\u{1F55F}",
      "1f560": "\u{1F560}",
      "1f561": "\u{1F561}",
      "1f562": "\u{1F562}",
      "1f563": "\u{1F563}",
      "1f564": "\u{1F564}",
      "1f565": "\u{1F565}",
      "1f566": "\u{1F566}",
      "1f567": "\u{1F567}",
      "1f3f3": "\u{1F3F3}\uFE0F",
      "1f3f4": "\u{1F3F4}",
      "1f3c1": "\u{1F3C1}",
      "1f6a9": "\u{1F6A9}",
      "1f3f3-fe0f-200d-1f308": "\u{1F3F3}\uFE0F\u200D\u{1F308}",
      "1f1e6-1f1eb": "\u{1F1E6}\u{1F1EB}",
      "1f1e6-1f1fd": "\u{1F1E6}\u{1F1FD}",
      "1f1e6-1f1f1": "\u{1F1E6}\u{1F1F1}",
      "1f1e9-1f1ff": "\u{1F1E9}\u{1F1FF}",
      "1f1e6-1f1f8": "\u{1F1E6}\u{1F1F8}",
      "1f1e6-1f1e9": "\u{1F1E6}\u{1F1E9}",
      "1f1e6-1f1f4": "\u{1F1E6}\u{1F1F4}",
      "1f1e6-1f1ee": "\u{1F1E6}\u{1F1EE}",
      "1f1e6-1f1f6": "\u{1F1E6}\u{1F1F6}",
      "1f1e6-1f1ec": "\u{1F1E6}\u{1F1EC}",
      "1f1e6-1f1f7": "\u{1F1E6}\u{1F1F7}",
      "1f1e6-1f1f2": "\u{1F1E6}\u{1F1F2}",
      "1f1e6-1f1fc": "\u{1F1E6}\u{1F1FC}",
      "1f1e6-1f1fa": "\u{1F1E6}\u{1F1FA}",
      "1f1e6-1f1f9": "\u{1F1E6}\u{1F1F9}",
      "1f1e6-1f1ff": "\u{1F1E6}\u{1F1FF}",
      "1f1e7-1f1f8": "\u{1F1E7}\u{1F1F8}",
      "1f1e7-1f1ed": "\u{1F1E7}\u{1F1ED}",
      "1f1e7-1f1e9": "\u{1F1E7}\u{1F1E9}",
      "1f1e7-1f1e7": "\u{1F1E7}\u{1F1E7}",
      "1f1e7-1f1fe": "\u{1F1E7}\u{1F1FE}",
      "1f1e7-1f1ea": "\u{1F1E7}\u{1F1EA}",
      "1f1e7-1f1ff": "\u{1F1E7}\u{1F1FF}",
      "1f1e7-1f1ef": "\u{1F1E7}\u{1F1EF}",
      "1f1e7-1f1f2": "\u{1F1E7}\u{1F1F2}",
      "1f1e7-1f1f9": "\u{1F1E7}\u{1F1F9}",
      "1f1e7-1f1f4": "\u{1F1E7}\u{1F1F4}",
      "1f1e7-1f1e6": "\u{1F1E7}\u{1F1E6}",
      "1f1e7-1f1fc": "\u{1F1E7}\u{1F1FC}",
      "1f1e7-1f1f7": "\u{1F1E7}\u{1F1F7}",
      "1f1ee-1f1f4": "\u{1F1EE}\u{1F1F4}",
      "1f1fb-1f1ec": "\u{1F1FB}\u{1F1EC}",
      "1f1e7-1f1f3": "\u{1F1E7}\u{1F1F3}",
      "1f1e7-1f1ec": "\u{1F1E7}\u{1F1EC}",
      "1f1e7-1f1eb": "\u{1F1E7}\u{1F1EB}",
      "1f1e7-1f1ee": "\u{1F1E7}\u{1F1EE}",
      "1f1f0-1f1ed": "\u{1F1F0}\u{1F1ED}",
      "1f1e8-1f1f2": "\u{1F1E8}\u{1F1F2}",
      "1f1e8-1f1e6": "\u{1F1E8}\u{1F1E6}",
      "1f1ee-1f1e8": "\u{1F1EE}\u{1F1E8}",
      "1f1e8-1f1fb": "\u{1F1E8}\u{1F1FB}",
      "1f1e7-1f1f6": "\u{1F1E7}\u{1F1F6}",
      "1f1f0-1f1fe": "\u{1F1F0}\u{1F1FE}",
      "1f1e8-1f1eb": "\u{1F1E8}\u{1F1EB}",
      "1f1f9-1f1e9": "\u{1F1F9}\u{1F1E9}",
      "1f1e8-1f1f1": "\u{1F1E8}\u{1F1F1}",
      "1f1e8-1f1f3": "\u{1F1E8}\u{1F1F3}",
      "1f1e8-1f1fd": "\u{1F1E8}\u{1F1FD}",
      "1f1e8-1f1e8": "\u{1F1E8}\u{1F1E8}",
      "1f1e8-1f1f4": "\u{1F1E8}\u{1F1F4}",
      "1f1f0-1f1f2": "\u{1F1F0}\u{1F1F2}",
      "1f1e8-1f1ec": "\u{1F1E8}\u{1F1EC}",
      "1f1e8-1f1e9": "\u{1F1E8}\u{1F1E9}",
      "1f1e8-1f1f0": "\u{1F1E8}\u{1F1F0}",
      "1f1e8-1f1f7": "\u{1F1E8}\u{1F1F7}",
      "1f1e8-1f1ee": "\u{1F1E8}\u{1F1EE}",
      "1f1ed-1f1f7": "\u{1F1ED}\u{1F1F7}",
      "1f1e8-1f1fa": "\u{1F1E8}\u{1F1FA}",
      "1f1e8-1f1fc": "\u{1F1E8}\u{1F1FC}",
      "1f1e8-1f1fe": "\u{1F1E8}\u{1F1FE}",
      "1f1e8-1f1ff": "\u{1F1E8}\u{1F1FF}",
      "1f1e9-1f1f0": "\u{1F1E9}\u{1F1F0}",
      "1f1e9-1f1ef": "\u{1F1E9}\u{1F1EF}",
      "1f1e9-1f1f2": "\u{1F1E9}\u{1F1F2}",
      "1f1e9-1f1f4": "\u{1F1E9}\u{1F1F4}",
      "1f1ea-1f1e8": "\u{1F1EA}\u{1F1E8}",
      "1f1ea-1f1ec": "\u{1F1EA}\u{1F1EC}",
      "1f1f8-1f1fb": "\u{1F1F8}\u{1F1FB}",
      "1f1ec-1f1f6": "\u{1F1EC}\u{1F1F6}",
      "1f1ea-1f1f7": "\u{1F1EA}\u{1F1F7}",
      "1f1ea-1f1ea": "\u{1F1EA}\u{1F1EA}",
      "1f1ea-1f1f9": "\u{1F1EA}\u{1F1F9}",
      "1f1ea-1f1fa": "\u{1F1EA}\u{1F1FA}",
      "1f1eb-1f1f0": "\u{1F1EB}\u{1F1F0}",
      "1f1eb-1f1f4": "\u{1F1EB}\u{1F1F4}",
      "1f1eb-1f1ef": "\u{1F1EB}\u{1F1EF}",
      "1f1eb-1f1ee": "\u{1F1EB}\u{1F1EE}",
      "1f1eb-1f1f7": "\u{1F1EB}\u{1F1F7}",
      "1f1ec-1f1eb": "\u{1F1EC}\u{1F1EB}",
      "1f1f5-1f1eb": "\u{1F1F5}\u{1F1EB}",
      "1f1f9-1f1eb": "\u{1F1F9}\u{1F1EB}",
      "1f1ec-1f1e6": "\u{1F1EC}\u{1F1E6}",
      "1f1ec-1f1f2": "\u{1F1EC}\u{1F1F2}",
      "1f1ec-1f1ea": "\u{1F1EC}\u{1F1EA}",
      "1f1e9-1f1ea": "\u{1F1E9}\u{1F1EA}",
      "1f1ec-1f1ed": "\u{1F1EC}\u{1F1ED}",
      "1f1ec-1f1ee": "\u{1F1EC}\u{1F1EE}",
      "1f1ec-1f1f7": "\u{1F1EC}\u{1F1F7}",
      "1f1ec-1f1f1": "\u{1F1EC}\u{1F1F1}",
      "1f1ec-1f1e9": "\u{1F1EC}\u{1F1E9}",
      "1f1ec-1f1f5": "\u{1F1EC}\u{1F1F5}",
      "1f1ec-1f1fa": "\u{1F1EC}\u{1F1FA}",
      "1f1ec-1f1f9": "\u{1F1EC}\u{1F1F9}",
      "1f1ec-1f1ec": "\u{1F1EC}\u{1F1EC}",
      "1f1ec-1f1f3": "\u{1F1EC}\u{1F1F3}",
      "1f1ec-1f1fc": "\u{1F1EC}\u{1F1FC}",
      "1f1ec-1f1fe": "\u{1F1EC}\u{1F1FE}",
      "1f1ed-1f1f9": "\u{1F1ED}\u{1F1F9}",
      "1f1ed-1f1f3": "\u{1F1ED}\u{1F1F3}",
      "1f1ed-1f1f0": "\u{1F1ED}\u{1F1F0}",
      "1f1ed-1f1fa": "\u{1F1ED}\u{1F1FA}",
      "1f1ee-1f1f8": "\u{1F1EE}\u{1F1F8}",
      "1f1ee-1f1f3": "\u{1F1EE}\u{1F1F3}",
      "1f1ee-1f1e9": "\u{1F1EE}\u{1F1E9}",
      "1f1ee-1f1f7": "\u{1F1EE}\u{1F1F7}",
      "1f1ee-1f1f6": "\u{1F1EE}\u{1F1F6}",
      "1f1ee-1f1ea": "\u{1F1EE}\u{1F1EA}",
      "1f1ee-1f1f2": "\u{1F1EE}\u{1F1F2}",
      "1f1ee-1f1f1": "\u{1F1EE}\u{1F1F1}",
      "1f1ee-1f1f9": "\u{1F1EE}\u{1F1F9}",
      "1f1ef-1f1f2": "\u{1F1EF}\u{1F1F2}",
      "1f1ef-1f1f5": "\u{1F1EF}\u{1F1F5}",
      "1f38c": "\u{1F38C}",
      "1f1ef-1f1ea": "\u{1F1EF}\u{1F1EA}",
      "1f1ef-1f1f4": "\u{1F1EF}\u{1F1F4}",
      "1f1f0-1f1ff": "\u{1F1F0}\u{1F1FF}",
      "1f1f0-1f1ea": "\u{1F1F0}\u{1F1EA}",
      "1f1f0-1f1ee": "\u{1F1F0}\u{1F1EE}",
      "1f1fd-1f1f0": "\u{1F1FD}\u{1F1F0}",
      "1f1f0-1f1fc": "\u{1F1F0}\u{1F1FC}",
      "1f1f0-1f1ec": "\u{1F1F0}\u{1F1EC}",
      "1f1f1-1f1e6": "\u{1F1F1}\u{1F1E6}",
      "1f1f1-1f1fb": "\u{1F1F1}\u{1F1FB}",
      "1f1f1-1f1e7": "\u{1F1F1}\u{1F1E7}",
      "1f1f1-1f1f8": "\u{1F1F1}\u{1F1F8}",
      "1f1f1-1f1f7": "\u{1F1F1}\u{1F1F7}",
      "1f1f1-1f1fe": "\u{1F1F1}\u{1F1FE}",
      "1f1f1-1f1ee": "\u{1F1F1}\u{1F1EE}",
      "1f1f1-1f1f9": "\u{1F1F1}\u{1F1F9}",
      "1f1f1-1f1fa": "\u{1F1F1}\u{1F1FA}",
      "1f1f2-1f1f4": "\u{1F1F2}\u{1F1F4}",
      "1f1f2-1f1f0": "\u{1F1F2}\u{1F1F0}",
      "1f1f2-1f1ec": "\u{1F1F2}\u{1F1EC}",
      "1f1f2-1f1fc": "\u{1F1F2}\u{1F1FC}",
      "1f1f2-1f1fe": "\u{1F1F2}\u{1F1FE}",
      "1f1f2-1f1fb": "\u{1F1F2}\u{1F1FB}",
      "1f1f2-1f1f1": "\u{1F1F2}\u{1F1F1}",
      "1f1f2-1f1f9": "\u{1F1F2}\u{1F1F9}",
      "1f1f2-1f1ed": "\u{1F1F2}\u{1F1ED}",
      "1f1f2-1f1f6": "\u{1F1F2}\u{1F1F6}",
      "1f1f2-1f1f7": "\u{1F1F2}\u{1F1F7}",
      "1f1f2-1f1fa": "\u{1F1F2}\u{1F1FA}",
      "1f1fe-1f1f9": "\u{1F1FE}\u{1F1F9}",
      "1f1f2-1f1fd": "\u{1F1F2}\u{1F1FD}",
      "1f1eb-1f1f2": "\u{1F1EB}\u{1F1F2}",
      "1f1f2-1f1e9": "\u{1F1F2}\u{1F1E9}",
      "1f1f2-1f1e8": "\u{1F1F2}\u{1F1E8}",
      "1f1f2-1f1f3": "\u{1F1F2}\u{1F1F3}",
      "1f1f2-1f1ea": "\u{1F1F2}\u{1F1EA}",
      "1f1f2-1f1f8": "\u{1F1F2}\u{1F1F8}",
      "1f1f2-1f1e6": "\u{1F1F2}\u{1F1E6}",
      "1f1f2-1f1ff": "\u{1F1F2}\u{1F1FF}",
      "1f1f2-1f1f2": "\u{1F1F2}\u{1F1F2}",
      "1f1f3-1f1e6": "\u{1F1F3}\u{1F1E6}",
      "1f1f3-1f1f7": "\u{1F1F3}\u{1F1F7}",
      "1f1f3-1f1f5": "\u{1F1F3}\u{1F1F5}",
      "1f1f3-1f1f1": "\u{1F1F3}\u{1F1F1}",
      "1f1f3-1f1e8": "\u{1F1F3}\u{1F1E8}",
      "1f1f3-1f1ff": "\u{1F1F3}\u{1F1FF}",
      "1f1f3-1f1ee": "\u{1F1F3}\u{1F1EE}",
      "1f1f3-1f1ea": "\u{1F1F3}\u{1F1EA}",
      "1f1f3-1f1ec": "\u{1F1F3}\u{1F1EC}",
      "1f1f3-1f1fa": "\u{1F1F3}\u{1F1FA}",
      "1f1f3-1f1eb": "\u{1F1F3}\u{1F1EB}",
      "1f1f0-1f1f5": "\u{1F1F0}\u{1F1F5}",
      "1f1f2-1f1f5": "\u{1F1F2}\u{1F1F5}",
      "1f1f3-1f1f4": "\u{1F1F3}\u{1F1F4}",
      "1f1f4-1f1f2": "\u{1F1F4}\u{1F1F2}",
      "1f1f5-1f1f0": "\u{1F1F5}\u{1F1F0}",
      "1f1f5-1f1fc": "\u{1F1F5}\u{1F1FC}",
      "1f1f5-1f1f8": "\u{1F1F5}\u{1F1F8}",
      "1f1f5-1f1e6": "\u{1F1F5}\u{1F1E6}",
      "1f1f5-1f1ec": "\u{1F1F5}\u{1F1EC}",
      "1f1f5-1f1fe": "\u{1F1F5}\u{1F1FE}",
      "1f1f5-1f1ea": "\u{1F1F5}\u{1F1EA}",
      "1f1f5-1f1ed": "\u{1F1F5}\u{1F1ED}",
      "1f1f5-1f1f3": "\u{1F1F5}\u{1F1F3}",
      "1f1f5-1f1f1": "\u{1F1F5}\u{1F1F1}",
      "1f1f5-1f1f9": "\u{1F1F5}\u{1F1F9}",
      "1f1f5-1f1f7": "\u{1F1F5}\u{1F1F7}",
      "1f1f6-1f1e6": "\u{1F1F6}\u{1F1E6}",
      "1f1f7-1f1ea": "\u{1F1F7}\u{1F1EA}",
      "1f1f7-1f1f4": "\u{1F1F7}\u{1F1F4}",
      "1f1f7-1f1fa": "\u{1F1F7}\u{1F1FA}",
      "1f1f7-1f1fc": "\u{1F1F7}\u{1F1FC}",
      "1f1fc-1f1f8": "\u{1F1FC}\u{1F1F8}",
      "1f1f8-1f1f2": "\u{1F1F8}\u{1F1F2}",
      "1f1f8-1f1f9": "\u{1F1F8}\u{1F1F9}",
      "1f1f8-1f1e6": "\u{1F1F8}\u{1F1E6}",
      "1f1f8-1f1f3": "\u{1F1F8}\u{1F1F3}",
      "1f1f7-1f1f8": "\u{1F1F7}\u{1F1F8}",
      "1f1f8-1f1e8": "\u{1F1F8}\u{1F1E8}",
      "1f1f8-1f1f1": "\u{1F1F8}\u{1F1F1}",
      "1f1f8-1f1ec": "\u{1F1F8}\u{1F1EC}",
      "1f1f8-1f1fd": "\u{1F1F8}\u{1F1FD}",
      "1f1f8-1f1f0": "\u{1F1F8}\u{1F1F0}",
      "1f1f8-1f1ee": "\u{1F1F8}\u{1F1EE}",
      "1f1ec-1f1f8": "\u{1F1EC}\u{1F1F8}",
      "1f1f8-1f1e7": "\u{1F1F8}\u{1F1E7}",
      "1f1f8-1f1f4": "\u{1F1F8}\u{1F1F4}",
      "1f1ff-1f1e6": "\u{1F1FF}\u{1F1E6}",
      "1f1f0-1f1f7": "\u{1F1F0}\u{1F1F7}",
      "1f1f8-1f1f8": "\u{1F1F8}\u{1F1F8}",
      "1f1ea-1f1f8": "\u{1F1EA}\u{1F1F8}",
      "1f1f1-1f1f0": "\u{1F1F1}\u{1F1F0}",
      "1f1e7-1f1f1": "\u{1F1E7}\u{1F1F1}",
      "1f1f8-1f1ed": "\u{1F1F8}\u{1F1ED}",
      "1f1f0-1f1f3": "\u{1F1F0}\u{1F1F3}",
      "1f1f1-1f1e8": "\u{1F1F1}\u{1F1E8}",
      "1f1f5-1f1f2": "\u{1F1F5}\u{1F1F2}",
      "1f1fb-1f1e8": "\u{1F1FB}\u{1F1E8}",
      "1f1f8-1f1e9": "\u{1F1F8}\u{1F1E9}",
      "1f1f8-1f1f7": "\u{1F1F8}\u{1F1F7}",
      "1f1f8-1f1ff": "\u{1F1F8}\u{1F1FF}",
      "1f1f8-1f1ea": "\u{1F1F8}\u{1F1EA}",
      "1f1e8-1f1ed": "\u{1F1E8}\u{1F1ED}",
      "1f1f8-1f1fe": "\u{1F1F8}\u{1F1FE}",
      "1f1f9-1f1fc": "\u{1F1F9}\u{1F1FC}",
      "1f1f9-1f1ef": "\u{1F1F9}\u{1F1EF}",
      "1f1f9-1f1ff": "\u{1F1F9}\u{1F1FF}",
      "1f1f9-1f1ed": "\u{1F1F9}\u{1F1ED}",
      "1f1f9-1f1f1": "\u{1F1F9}\u{1F1F1}",
      "1f1f9-1f1ec": "\u{1F1F9}\u{1F1EC}",
      "1f1f9-1f1f0": "\u{1F1F9}\u{1F1F0}",
      "1f1f9-1f1f4": "\u{1F1F9}\u{1F1F4}",
      "1f1f9-1f1f9": "\u{1F1F9}\u{1F1F9}",
      "1f1f9-1f1f3": "\u{1F1F9}\u{1F1F3}",
      "1f1f9-1f1f7": "\u{1F1F9}\u{1F1F7}",
      "1f1f9-1f1f2": "\u{1F1F9}\u{1F1F2}",
      "1f1f9-1f1e8": "\u{1F1F9}\u{1F1E8}",
      "1f1f9-1f1fb": "\u{1F1F9}\u{1F1FB}",
      "1f1fb-1f1ee": "\u{1F1FB}\u{1F1EE}",
      "1f1fa-1f1ec": "\u{1F1FA}\u{1F1EC}",
      "1f1fa-1f1e6": "\u{1F1FA}\u{1F1E6}",
      "1f1e6-1f1ea": "\u{1F1E6}\u{1F1EA}",
      "1f1ec-1f1e7": "\u{1F1EC}\u{1F1E7}",
      "1f1fa-1f1f8": "\u{1F1FA}\u{1F1F8}",
      "1f1fa-1f1fe": "\u{1F1FA}\u{1F1FE}",
      "1f1fa-1f1ff": "\u{1F1FA}\u{1F1FF}",
      "1f1fb-1f1fa": "\u{1F1FB}\u{1F1FA}",
      "1f1fb-1f1e6": "\u{1F1FB}\u{1F1E6}",
      "1f1fb-1f1ea": "\u{1F1FB}\u{1F1EA}",
      "1f1fb-1f1f3": "\u{1F1FB}\u{1F1F3}",
      "1f1fc-1f1eb": "\u{1F1FC}\u{1F1EB}",
      "1f1ea-1f1ed": "\u{1F1EA}\u{1F1ED}",
      "1f1fe-1f1ea": "\u{1F1FE}\u{1F1EA}",
      "1f1ff-1f1f2": "\u{1F1FF}\u{1F1F2}",
      "1f1ff-1f1fc": "\u{1F1FF}\u{1F1FC}",
      "1f1e6-1f1e8": "\u{1F1E6}\u{1F1E8}",
      "1f1f9-1f1e6": "\u{1F1F9}\u{1F1E6}",
      "1f1e7-1f1fb": "\u{1F1E7}\u{1F1FB}",
      "1f1ed-1f1f2": "\u{1F1ED}\u{1F1F2}",
      "1f1f8-1f1ef": "\u{1F1F8}\u{1F1EF}",
      "1f1fa-1f1f2": "\u{1F1FA}\u{1F1F2}",
      "1f1ea-1f1e6": "\u{1F1EA}\u{1F1E6}",
      "1f1e8-1f1f5": "\u{1F1E8}\u{1F1F5}",
      "1f1e9-1f1ec": "\u{1F1E9}\u{1F1EC}",
      "1f1f2-1f1eb": "\u{1F1F2}\u{1F1EB}",
      "1f1fa-1f1f3": "\u{1F1FA}\u{1F1F3}",
      "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
      "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
      "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}",
      "1f1ff": "\u{1F1FF}",
      "1f1fe": "\u{1F1FE}",
      "1f1fd": "\u{1F1FD}",
      "1f3fb": "\u{1F3FB}",
      "1f3fc": "\u{1F3FC}",
      "1f3fd": "\u{1F3FD}",
      "1f3fe": "\u{1F3FE}",
      "1f3ff": "\u{1F3FF}",
      "1f1fc": "\u{1F1FC}",
      "1f1fb": "\u{1F1FB}",
      "1f1fa": "\u{1F1FA}",
      "1f1f9": "\u{1F1F9}",
      "1f1f8": "\u{1F1F8}",
      "1f1f7": "\u{1F1F7}",
      "1f1f6": "\u{1F1F6}",
      "1f1f5": "\u{1F1F5}",
      "1f1f4": "\u{1F1F4}",
      "1f1f3": "\u{1F1F3}",
      "1f1f2": "\u{1F1F2}",
      "1f1f1": "\u{1F1F1}",
      "1f1f0": "\u{1F1F0}",
      "1f1ef": "\u{1F1EF}",
      "1f1ee": "\u{1F1EE}",
      "1f1ed": "\u{1F1ED}",
      "1f1ec": "\u{1F1EC}",
      "1f1eb": "\u{1F1EB}",
      "1f1ea": "\u{1F1EA}",
      "1f1e9": "\u{1F1E9}",
      "1f1e8": "\u{1F1E8}",
      "1f1e7": "\u{1F1E7}",
      "1f1e6": "\u{1F1E6}",
      "2640": "\u2640\uFE0F",
      "2642": "\u2642\uFE0F",
      "2695": "\u2695\uFE0F",
      "1f468-200d-1f469-200d-1f466": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
      "1f469-200d-2764-fe0f-200d-1f468": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "1f928": "\u{1F928}",
      "1f929": "\u{1F929}",
      "1f92a": "\u{1F92A}",
      "1f92b": "\u{1F92B}",
      "1f92c": "\u{1F92C}",
      "1f92d": "\u{1F92D}",
      "1f92e": "\u{1F92E}",
      "1f92f": "\u{1F92F}",
      "1f9d0": "\u{1F9D0}",
      "1f9d1": "\u{1F9D1}",
      "1f9d2": "\u{1F9D2}",
      "1f9d3": "\u{1F9D3}",
      "1f9d4": "\u{1F9D4}",
      "1f9d5": "\u{1F9D5}",
      "1f9e0": "\u{1F9E0}",
      "1f9e2": "\u{1F9E2}",
      "1f9d9": "\u{1F9D9}",
      "1f9da": "\u{1F9DA}",
      "1f9db": "\u{1F9DB}",
      "1f9dc": "\u{1F9DC}",
      "1f9dd": "\u{1F9DD}",
      "1f9de": "\u{1F9DE}",
      "1f9df": "\u{1F9DF}",
      "1f9e3": "\u{1F9E3}",
      "1f9e4": "\u{1F9E4}",
      "1f9e5": "\u{1F9E5}",
      "1f9e6": "\u{1F9E6}",
      "1f91f": "\u{1F91F}",
      "1f932": "\u{1F932}",
      "1f9d9-200d-2640-fe0f": "\u{1F9D9}\u200D\u2640\uFE0F",
      "1f9d9-200d-2642-fe0f": "\u{1F9D9}\u200D\u2642\uFE0F",
      "1f9da-200d-2640-fe0f": "\u{1F9DA}\u200D\u2640\uFE0F",
      "1f9da-200d-2642-fe0f": "\u{1F9DA}\u200D\u2642\uFE0F",
      "1f9db-200d-2640-fe0f": "\u{1F9DB}\u200D\u2640\uFE0F",
      "1f9db-200d-2642-fe0f": "\u{1F9DB}\u200D\u2642\uFE0F",
      "1f9dc-200d-2640-fe0f": "\u{1F9DC}\u200D\u2640\uFE0F",
      "1f9dc-200d-2642-fe0f": "\u{1F9DC}\u200D\u2642\uFE0F",
      "1f9dd-200d-2640-fe0f": "\u{1F9DD}\u200D\u2640\uFE0F",
      "1f9dd-200d-2642-fe0f": "\u{1F9DD}\u200D\u2642\uFE0F",
      "1f9de-200d-2640-fe0f": "\u{1F9DE}\u200D\u2640\uFE0F",
      "1f9de-200d-2642-fe0f": "\u{1F9DE}\u200D\u2642\uFE0F",
      "1f9df-200d-2640-fe0f": "\u{1F9DF}\u200D\u2640\uFE0F",
      "1f9df-200d-2642-fe0f": "\u{1F9DF}\u200D\u2642\uFE0F",
      "atlassian-check_mark": "(/)",
      "atlassian-cross_mark": "(x)",
      "atlassian-plus": "(+)",
      "atlassian-minus": "(-)",
      "atlassian-light_bulb_on": "(on)",
      "atlassian-light_bulb_off": "(off)",
      "atlassian-flag_on": "(flag)",
      "atlassian-flag_off": "(flagoff)",
      "atlassian-warning": "(!)",
      "atlassian-question_mark": "(?)",
      "atlassian-info": "(i)",
      "atlassian-yellow_star": "(*y)",
      "atlassian-blue_star": "(*b)",
      "atlassian-green_star": "(*g)",
      "atlassian-red_star": "(*r)"
    };
    exports.mapping = mapping;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/unknown.js
var require_unknown = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/unknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unknown = void 0;
    var _editorJsonTransformer = require_cjs7();
    var jsonTransformer = new _editorJsonTransformer.JSONTransformer();
    var unknown = function unknown2(node) {
      var content = JSON.stringify(jsonTransformer.encodeNode(node));
      return node.isBlock ? "{adf:display=block}\n".concat(content, "\n{adf}") : "{adf:display=inline}".concat(content, "{adf}");
    };
    exports.unknown = unknown;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/emoji.js
var require_emoji3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.emoji = void 0;
    var _emojiUnicodeMapping = require_emoji_unicode_mapping();
    var _unknown = require_unknown();
    var emoji = function emoji2(node) {
      var value = _emojiUnicodeMapping.mapping[node.attrs.id];
      if (value) {
        return value;
      }
      if (node.attrs.shortName) {
        return node.attrs.shortName;
      }
      return (0, _unknown.unknown)(node);
    };
    exports.emoji = emoji;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/hard-break.js
var require_hard_break2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/hard-break.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hardBreak = void 0;
    var hardBreak = function hardBreak2(_node) {
      return "\n";
    };
    exports.hardBreak = hardBreak;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media-inline.js
var require_media_inline2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media-inline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mediaInline = void 0;
    var mediaInline = function mediaInline2(node) {
      var _context$conversion$m, _context$conversion, _context$conversion$m2, _context$conversion$m3;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var fileName;
      fileName = (_context$conversion$m = context === null || context === void 0 ? void 0 : (_context$conversion = context.conversion) === null || _context$conversion === void 0 ? void 0 : (_context$conversion$m2 = _context$conversion.mediaConversion) === null || _context$conversion$m2 === void 0 ? void 0 : (_context$conversion$m3 = _context$conversion$m2[node.attrs.id]) === null || _context$conversion$m3 === void 0 ? void 0 : _context$conversion$m3.transform) !== null && _context$conversion$m !== void 0 ? _context$conversion$m : node.attrs.id;
      return "[^".concat(fileName, "]");
    };
    exports.mediaInline = mediaInline;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/mention.js
var require_mention2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/mention.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mention = void 0;
    var PREFIX = "accountid:";
    var UNKNOWN_USER = "UNKNOWN_USER";
    var addPrefix = function addPrefix2(content) {
      return content.toLowerCase().startsWith(PREFIX) ? content : "".concat(PREFIX).concat(content);
    };
    var mention = function mention2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      if (node.attrs.id === UNKNOWN_USER) {
        return "[~".concat(node.attrs.id, "]");
      }
      var mentionKey = node.attrs.id.toLowerCase();
      var content = context && context.conversion && context.conversion.mentionConversion && context.conversion.mentionConversion[mentionKey] ? context.conversion.mentionConversion[mentionKey] : addPrefix(node.attrs.id);
      return "[~".concat(content, "]");
    };
    exports.mention = mention;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/url.js
var require_url2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decode = decode;
    function decode(raw) {
      if (typeof URL === "function") {
        var decoded = new URL(raw);
        if (decoded.href) {
          return decoded.href;
        }
      }
      var anchor = document.createElement("a");
      anchor.href = raw;
      return anchor.href;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/link-text.js
var require_link_text = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/link-text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.linkText = exports.LINK_TEXT_REGEXP = void 0;
    var _adfSchema = require_cjs6();
    var _url = require_url2();
    var LINK_TEXT_REGEXP = /^((?:(?:https?|ftps?):\/\/)|irc:\/\/|mailto:)([\w?!~^\/\\#$%&'()*+,\-.\/:;<=@]*[\w~^\/\\#$%&'()*+,\-\/:;<=@])/i;
    exports.LINK_TEXT_REGEXP = LINK_TEXT_REGEXP;
    var linkText = function linkText2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema;
      var match = input2.substring(position).match(LINK_TEXT_REGEXP);
      if (!match) {
        return fallback(input2, position);
      }
      match = trimBadEndChar(match);
      var textRepresentation = match[1] === "mailto:" ? match[2] : match[0];
      var url = (0, _url.decode)(unescape(match[0]));
      if (!(0, _adfSchema.isSafeUrl)(url)) {
        return fallback(input2, position);
      }
      var mark = schema.marks.link.create({
        href: url
      });
      var textNode = schema.text(textRepresentation, [mark]);
      return {
        type: "pmnode",
        nodes: [textNode],
        length: match[0].length
      };
    };
    exports.linkText = linkText;
    function unescape(url) {
      var result = "";
      for (var i = 0; i < url.length; i++) {
        var char = url[i];
        if (char !== "\\") {
          result += char;
          continue;
        }
        var nextChar = url[i + 1];
        if (nextChar) {
          result += nextChar;
          i++;
        }
      }
      return result;
    }
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    }
    function trimBadEndChar(input2) {
      return [input2[0].replace(/[.,>)\];}"\'!]*$/, ""), input2[1], input2[2].replace(/[.,>)\];}"\'!]*$/, "")];
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/mediaSingle.js
var require_mediaSingle = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/mediaSingle.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getMediaSingleNodeView;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _linkText = require_link_text();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var defaultWidth = 200;
    var defaultHeight = 183;
    var clamp = function clamp2(input2, lower, upper) {
      if (upper !== void 0) {
        input2 = input2 <= upper ? input2 : upper;
      }
      if (lower !== void 0) {
        input2 = input2 >= lower ? input2 : lower;
      }
      return input2;
    };
    function getMediaSingleNodeView(schema, filename, attrs) {
      var _context$defaults, _context$defaults$med, _context$defaults3, _context$defaults3$me;
      var context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var _schema$nodes = schema.nodes, media = _schema$nodes.media, mediaSingle = _schema$nodes.mediaSingle;
      var link = schema.marks.link;
      var mediaMarks = [];
      var mediaNodeAttrs = {};
      if ((context === null || context === void 0 ? void 0 : (_context$defaults = context.defaults) === null || _context$defaults === void 0 ? void 0 : (_context$defaults$med = _context$defaults.media) === null || _context$defaults$med === void 0 ? void 0 : _context$defaults$med.width) !== null) {
        var _context$defaults$med2, _context$defaults2, _context$defaults2$me;
        mediaNodeAttrs.width = (_context$defaults$med2 = context === null || context === void 0 ? void 0 : (_context$defaults2 = context.defaults) === null || _context$defaults2 === void 0 ? void 0 : (_context$defaults2$me = _context$defaults2.media) === null || _context$defaults2$me === void 0 ? void 0 : _context$defaults2$me.width) !== null && _context$defaults$med2 !== void 0 ? _context$defaults$med2 : defaultWidth;
      }
      if ((context === null || context === void 0 ? void 0 : (_context$defaults3 = context.defaults) === null || _context$defaults3 === void 0 ? void 0 : (_context$defaults3$me = _context$defaults3.media) === null || _context$defaults3$me === void 0 ? void 0 : _context$defaults3$me.height) !== null) {
        var _context$defaults$med3, _context$defaults4, _context$defaults4$me;
        mediaNodeAttrs.height = (_context$defaults$med3 = context === null || context === void 0 ? void 0 : (_context$defaults4 = context.defaults) === null || _context$defaults4 === void 0 ? void 0 : (_context$defaults4$me = _context$defaults4.media) === null || _context$defaults4$me === void 0 ? void 0 : _context$defaults4$me.height) !== null && _context$defaults$med3 !== void 0 ? _context$defaults$med3 : defaultHeight;
      }
      var mediaSingleAttrs = {
        layout: "center"
      };
      if (attrs.width && attrs.width.endsWith("%")) {
        var parsed = parseInt(attrs.width, 10);
        if (!isNaN(parsed)) {
          mediaSingleAttrs.width = clamp(parsed, 0, 100);
        }
        mediaNodeAttrs = {};
      } else {
        if (attrs.width) {
          var _parsed = parseInt(attrs.width, 10);
          if (!isNaN(_parsed)) {
            mediaNodeAttrs.width = _parsed;
          }
        }
        if (attrs.height) {
          var _parsed2 = parseInt(attrs.height, 10);
          if (!isNaN(_parsed2)) {
            mediaNodeAttrs.height = _parsed2;
          }
        }
      }
      if (attrs.href) {
        var href = attrs.href.replace(/^"(.+)"$/, "$1");
        mediaMarks.push(link.create({
          href
        }));
      }
      if (attrs.alt) {
        var altText = attrs.alt.replace(/^"(.+)"$/, "$1");
        mediaNodeAttrs.alt = altText;
      }
      if (filename.match(_linkText.LINK_TEXT_REGEXP)) {
        var externalMediaNode = media.createChecked(_objectSpread({
          type: "external",
          url: filename
        }, mediaNodeAttrs), void 0, mediaMarks);
        return mediaSingle.createChecked(mediaSingleAttrs, externalMediaNode);
      } else {
        var _context$conversion$m, _context$conversion, _context$conversion$m2, _context$conversion$m3;
        var id = (_context$conversion$m = context === null || context === void 0 ? void 0 : (_context$conversion = context.conversion) === null || _context$conversion === void 0 ? void 0 : (_context$conversion$m2 = _context$conversion.mediaConversion) === null || _context$conversion$m2 === void 0 ? void 0 : (_context$conversion$m3 = _context$conversion$m2[filename]) === null || _context$conversion$m3 === void 0 ? void 0 : _context$conversion$m3.transform) !== null && _context$conversion$m !== void 0 ? _context$conversion$m : filename;
        var collection = context.hydration && context.hydration.media && context.hydration.media.targetCollectionId;
        var mediaNode = media.createChecked(_objectSpread({
          id,
          type: "file",
          collection: collection || ""
        }, mediaNodeAttrs), void 0, mediaMarks);
        return mediaSingle.createChecked(mediaSingleAttrs, mediaNode);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/toArray.js
var require_toArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toArray.js"(exports, module2) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
    }
    module2.exports = _toArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/attrs.js
var require_attrs = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/attrs.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseAttrs = parseAttrs;
    var _toArray2 = _interopRequireDefault(require_toArray());
    function parseAttrs(str) {
      var sep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "|";
      var output = {};
      if (!str) {
        return output;
      }
      var attributesStr = str.split(sep);
      attributesStr.forEach(function(attributeStr) {
        var _attributeStr$split = attributeStr.split("="), _attributeStr$split2 = (0, _toArray2.default)(_attributeStr$split), key = _attributeStr$split2[0], value = _attributeStr$split2.slice(1);
        if (!output[key]) {
          output[key] = value.join("=");
        }
      });
      return output;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/text.js
var require_text5 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createTextNode = createTextNode;
    function createTextNode(input2, schema, marks) {
      if (input2 === "") {
        return [];
      }
      var node = schema.text(input2, marks || []);
      return [node];
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseNewlineOnly = parseNewlineOnly;
    exports.parseWhitespaceAndNewLine = parseWhitespaceAndNewLine;
    exports.parseWhitespaceOnly = parseWhitespaceOnly;
    function parseWhitespaceAndNewLine(input2) {
      var newlineLength = parseNewlineOnly(input2);
      if (newlineLength) {
        return newlineLength;
      }
      var whitespaceLength = parseWhitespaceOnly(input2);
      if (whitespaceLength) {
        return whitespaceLength;
      }
      return 0;
    }
    function parseWhitespaceOnly(input2) {
      var index = 0;
      var char = input2.charAt(index);
      if (char === "	" || char === " ") {
        index++;
      }
      return index;
    }
    function parseNewlineOnly(input2) {
      var index = 0;
      var char = input2.charAt(index);
      if (char === "\r") {
        index++;
        if (input2.charAt(index) === "\n") {
          index++;
        }
      } else if (char === "\n") {
        index++;
      }
      return index;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/escape.js
var require_escape3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.escapeHandler = escapeHandler;
    var escapedChar = ["-", "#", "*", "_", "+", "?", "^", "~", "|", "%", "{", "}", "[", "]", "(", ")", "!", "@"];
    function escapeHandler(input2, position) {
      var buffer = [];
      var char = input2.charAt(position);
      var prevChar = input2.charAt(position - 1);
      var nextChar = input2.charAt(position + 1);
      if (escapedChar.indexOf(nextChar) === -1 || prevChar === "\\") {
        buffer.push(char);
      }
      buffer.push(nextChar);
      return {
        type: "text",
        text: buffer.join(""),
        length: 2
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/paragraph.js
var require_paragraph4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/paragraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createEmptyParagraphNode = createEmptyParagraphNode;
    exports.createParagraphNodeFromInlineNodes = createParagraphNodeFromInlineNodes;
    function createEmptyParagraphNode(schema) {
      var paragraph = schema.nodes.paragraph;
      return paragraph.createChecked({}, []);
    }
    function createParagraphNodeFromInlineNodes(inlineNodes, schema) {
      var paragraph = schema.nodes.paragraph;
      var result = [];
      var textNodes = inlineNodes.filter(function(node) {
        return node.type.name !== "hardBreak";
      });
      if (textNodes.length > 0) {
        result.push(paragraph.createChecked({}, inlineNodes));
      }
      return result;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/builder/table-builder.js
var require_table_builder = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/builder/table-builder.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TableBuilder = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function getType(style) {
      return /\|\|/.test(style) ? "tableHeader" : "tableCell";
    }
    var TableBuilder = /* @__PURE__ */ function() {
      function TableBuilder2(schema) {
        var _this = this;
        (0, _classCallCheck2.default)(this, TableBuilder2);
        (0, _defineProperty2.default)(this, "emptyTableCell", function() {
          var _this$schema$nodes = _this.schema.nodes, tableCell = _this$schema$nodes.tableCell, paragraph = _this$schema$nodes.paragraph;
          return tableCell.createChecked({}, paragraph.createChecked());
        });
        (0, _defineProperty2.default)(this, "emptyTableRow", function() {
          var tableRow = _this.schema.nodes.tableRow;
          return tableRow.createChecked({}, _this.emptyTableCell());
        });
        (0, _defineProperty2.default)(this, "buildTableNode", function() {
          var root = _this.root;
          var table = _this.schema.nodes.table;
          var content = root.rows.map(_this.buildTableRowNode);
          if (content.length === 0) {
            content.push(_this.emptyTableRow());
          }
          return table.createChecked({}, content);
        });
        (0, _defineProperty2.default)(this, "buildTableRowNode", function(row) {
          var tableRow = _this.schema.nodes.tableRow;
          return tableRow.createChecked({}, row.cells.map(_this.buildTableCellNode));
        });
        (0, _defineProperty2.default)(this, "buildTableCellNode", function(cell) {
          var type = cell.type, content = cell.content;
          if (content.length === 0) {
            content.push(_this.schema.nodes.paragraph.createChecked());
          }
          var cellNode = _this.schema.nodes[type];
          return cellNode.createChecked({}, content);
        });
        this.schema = schema;
        this.root = {
          rows: []
        };
      }
      (0, _createClass2.default)(TableBuilder2, [{
        key: "type",
        get: function get() {
          return "table";
        }
        /**
         * Add new cells to the table
         * @param {AddCellArgs[]} cells
         */
      }, {
        key: "add",
        value: function add(cells) {
          if (!cells.length) {
            return;
          }
          var index = 0;
          var _iterator = _createForOfIteratorHelper(cells), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var cell = _step.value;
              var content = cell.content, style = cell.style;
              var cellType = getType(style);
              if (index === 0) {
                this.addRow();
              }
              var newCell = {
                type: cellType,
                content
              };
              this.lastRow.cells.push(newCell);
              index += 1;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        /**
         * Build a prosemirror table from the data
         * @returns {PMNode}
         */
      }, {
        key: "buildPMNode",
        value: function buildPMNode() {
          return this.buildTableNode();
        }
        /**
         * Build prosemirror table node
         * @returns {PMNode}
         */
        /**
         * Build prosemirror tr node
         * @returns {PMNode}
         */
        /**
         * Build prosemirror td/th node
         * @param {TableCell} cell
         * @returns {PMNode}
         */
      }, {
        key: "addRow",
        value: (
          /**
           * Add a new row to the table
           */
          function addRow() {
            var rows = this.root.rows;
            var row = {
              cells: []
            };
            rows.push(row);
            this.lastRow = row;
          }
        )
      }]);
      return TableBuilder2;
    }();
    exports.TableBuilder = TableBuilder;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/normalize.js
var require_normalize3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/normalize.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isNextLineEmpty = isNextLineEmpty;
    exports.normalizeInlineNodes = normalizeInlineNodes;
    exports.normalizePMNodes = normalizePMNodes;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _paragraph = require_paragraph4();
    var _tableBuilder = require_table_builder();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function normalizePMNodes(nodes, schema, parentNode) {
      return [normalizeMediaGroups, normalizeInlineNodes].reduce(function(currentNodes, normFunc) {
        return normFunc(currentNodes, schema, parentNode);
      }, nodes);
    }
    function normalizeInlineNodes(nodes, schema, parentNode) {
      var output = [];
      var inlineNodeBuffer = [];
      var _iterator = _createForOfIteratorHelper(nodes), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _node$type;
          var node = _step.value;
          if (!node.isBlock) {
            inlineNodeBuffer.push(node);
            continue;
          }
          if (inlineNodeBuffer.length > 0) {
            output.push.apply(output, (0, _toConsumableArray2.default)((0, _paragraph.createParagraphNodeFromInlineNodes)(inlineNodeBuffer, schema)));
          }
          inlineNodeBuffer = [];
          if ((node === null || node === void 0 ? void 0 : (_node$type = node.type) === null || _node$type === void 0 ? void 0 : _node$type.name) === "nestedExpand" && parentNode === "doc") {
            output.push(wrapNestedExpandInTable(node, schema));
          } else {
            output.push(node);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (inlineNodeBuffer.length > 0) {
        output.push.apply(output, (0, _toConsumableArray2.default)((0, _paragraph.createParagraphNodeFromInlineNodes)(inlineNodeBuffer, schema)));
      }
      if (output.length === 0) {
        return [(0, _paragraph.createEmptyParagraphNode)(schema)];
      }
      return output;
    }
    function normalizeMediaGroups(nodes, schema, parentNode) {
      var output = [];
      var mediaGroupBuffer = [];
      var separatorBuffer = [];
      var _iterator2 = _createForOfIteratorHelper(nodes), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var n = _step2.value;
          if (n.type.name === "mediaGroup" && n.childCount === 1) {
            mediaGroupBuffer.push(n);
            separatorBuffer = [];
            continue;
          }
          if (mediaGroupBuffer.length > 0) {
            if (isSignificantSeparatorNode(n, separatorBuffer)) {
              output.push(createMergedMediaGroup(mediaGroupBuffer, schema));
              output.push.apply(output, (0, _toConsumableArray2.default)(separatorBuffer));
              output.push(n);
              mediaGroupBuffer = [];
              separatorBuffer = [];
            } else {
              separatorBuffer.push(n);
            }
            continue;
          }
          output.push(n);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (mediaGroupBuffer.length > 0) {
        output.push(createMergedMediaGroup(mediaGroupBuffer, schema));
      }
      output.push.apply(output, (0, _toConsumableArray2.default)(separatorBuffer));
      return output;
    }
    function createMergedMediaGroup(mediaGroupNodes, schema) {
      var mediaGroup = schema.nodes.mediaGroup;
      var mediaNodes = mediaGroupNodes.map(function(v) {
        return v.child(0);
      });
      return mediaGroup.createChecked({}, mediaNodes);
    }
    function isSignificantSeparatorNode(n, separatorBuffer) {
      return isHardBreak(n, separatorBuffer) || !isEmptyTextNode(n) || isMediaGroupWithMultipleChildren(n);
    }
    function isMediaGroupWithMultipleChildren(n) {
      return n.type.name === "mediaGroup" && n.childCount > 1;
    }
    function isHardBreak(n, separatorBuffer) {
      return n.type.name === "hardBreak" && separatorBuffer.map(function(v) {
        return v.type.name;
      }).indexOf("hardBreak") !== -1;
    }
    function isEmptyTextNode(n) {
      return n.textContent !== void 0 && n.textContent.trim().length === 0;
    }
    function isNextLineEmpty(input2) {
      return input2.trim().length === 0;
    }
    function wrapNestedExpandInTable(node, schema) {
      var builder = new _tableBuilder.TableBuilder(schema);
      var cell = {
        style: "|",
        content: [node]
      };
      builder.add([cell]);
      var tableNode = builder.buildPMNode();
      return tableNode;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/text.js
var require_text6 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/text.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseString = parseString;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _text = require_text5();
    var _keyword = require_keyword();
    var _tokenize = require_tokenize();
    var _whitespace = require_whitespace();
    var _escape = require_escape3();
    var _normalize = require_normalize3();
    var processState = {
      NEWLINE: 0,
      BUFFER: 1,
      TOKEN: 2,
      ESCAPE: 3
    };
    function parseString(_ref) {
      var input2 = _ref.input, schema = _ref.schema, _ref$ignoreTokenTypes = _ref.ignoreTokenTypes, ignoreTokenTypes = _ref$ignoreTokenTypes === void 0 ? [] : _ref$ignoreTokenTypes, context = _ref.context, _ref$includeLeadingSp = _ref.includeLeadingSpace, includeLeadingSpace = _ref$includeLeadingSp === void 0 ? false : _ref$includeLeadingSp;
      var index = 0;
      var state = processState.NEWLINE;
      var buffer = [];
      var tokenType = _tokenize.TokenType.STRING;
      var newLines = [];
      var output = [];
      var inlineNodes = [];
      while (index < input2.length) {
        var char = input2.charAt(index);
        switch (state) {
          case processState.NEWLINE: {
            var substring = input2.substring(index);
            var length = (0, _whitespace.parseWhitespaceOnly)(substring);
            if (length) {
              index += length;
              if (includeLeadingSpace) {
                buffer.push(char);
              }
              continue;
            }
            var match = (0, _keyword.parseLeadingKeyword)(substring) || (0, _keyword.parseMacroKeyword)(substring) || (0, _keyword.parseOtherKeyword)(substring) || (0, _keyword.parseIssueKeyword)(substring, context.issueKeyRegex);
            if (match && ignoreTokenTypes.indexOf(match.type) === -1) {
              tokenType = match.type;
              state = processState.TOKEN;
              continue;
            } else {
              state = processState.BUFFER;
              continue;
            }
          }
          case processState.BUFFER: {
            var _substring = input2.substring(index);
            var _match = null;
            if (buffer.length > 0 && buffer[buffer.length - 1].endsWith("{")) {
              _match = (0, _keyword.parseOtherKeyword)(_substring);
            } else {
              _match = (0, _keyword.parseMacroKeyword)(_substring) || (0, _keyword.parseOtherKeyword)(_substring) || (0, _keyword.parseIssueKeyword)(_substring, context.issueKeyRegex);
            }
            if (_match && ignoreTokenTypes.indexOf(_match.type) === -1) {
              tokenType = _match.type;
              state = processState.TOKEN;
              continue;
            }
            if (char === "\\") {
              state = processState.ESCAPE;
              continue;
            }
            buffer.push(char);
            break;
          }
          case processState.TOKEN: {
            var token = (0, _tokenize.parseToken)(input2, tokenType, index, schema, context);
            if (token.type === "text") {
              buffer.push(token.text);
            } else if (token.type === "pmnode") {
              var _inlineNodes2;
              if (newLines.length >= 2 && (tokenType !== _tokenize.TokenType.HARD_BREAK || buffer.length > 0)) {
                output.push.apply(output, (0, _toConsumableArray2.default)((0, _normalize.normalizePMNodes)(inlineNodes, schema)));
                inlineNodes = isConsecutiveMediaGroups(inlineNodes, token.nodes) ? (0, _toConsumableArray2.default)(newLines) : [];
                newLines = [];
              }
              if (inlineNodes.length === 0) {
                newLines = [];
              }
              if (newLines.length > 0 && isNewLineRequiredBetweenNodes(inlineNodes, buffer, token.nodes)) {
                var _inlineNodes;
                (_inlineNodes = inlineNodes).push.apply(_inlineNodes, (0, _toConsumableArray2.default)(newLines));
                newLines = [];
              }
              (_inlineNodes2 = inlineNodes).push.apply(_inlineNodes2, (0, _toConsumableArray2.default)((0, _text.createTextNode)(buffer.join(""), schema)));
              if (tokenType === _tokenize.TokenType.HARD_BREAK) {
                var _newLines;
                (_newLines = newLines).push.apply(_newLines, (0, _toConsumableArray2.default)(token.nodes));
              } else {
                var _inlineNodes3;
                (_inlineNodes3 = inlineNodes).push.apply(_inlineNodes3, (0, _toConsumableArray2.default)(token.nodes));
                if (token.nodes.length > 0) {
                  newLines = [];
                }
              }
              buffer = [];
            }
            index += token.length;
            if (tokenType === _tokenize.TokenType.HARD_BREAK) {
              state = processState.NEWLINE;
            } else {
              state = processState.BUFFER;
            }
            continue;
          }
          case processState.ESCAPE: {
            var _token = (0, _escape.escapeHandler)(input2, index);
            buffer.push(_token.text);
            index += _token.length;
            state = processState.BUFFER;
            continue;
          }
          default:
        }
        index++;
      }
      var bufferedStr = buffer.join("");
      if (bufferedStr.length > 0) {
        var _inlineNodes5;
        if (newLines.length >= 2) {
          output.push.apply(output, (0, _toConsumableArray2.default)((0, _normalize.normalizePMNodes)(inlineNodes, schema)));
          inlineNodes = [];
          newLines = [];
        }
        if (newLines.length > 0 && inlineNodes.length > 0 && !inlineNodes[inlineNodes.length - 1].isBlock) {
          var _inlineNodes4;
          (_inlineNodes4 = inlineNodes).push.apply(_inlineNodes4, (0, _toConsumableArray2.default)(newLines));
        }
        (_inlineNodes5 = inlineNodes).push.apply(_inlineNodes5, (0, _toConsumableArray2.default)((0, _text.createTextNode)(bufferedStr, schema)));
      }
      return [].concat(output, (0, _toConsumableArray2.default)(inlineNodes));
    }
    function isNewLineRequiredBetweenNodes(currentNodes, buffer, nextNodes) {
      var _currentNodes;
      if (currentNodes.length === 0) {
        return false;
      }
      if (buffer.length > 0 && (_currentNodes = currentNodes[currentNodes.length - 1]) !== null && _currentNodes !== void 0 && _currentNodes.isBlock) {
        return false;
      }
      if (buffer.length === 0) {
        var _nextNodes$, _nextNodes$2, _currentNodes2;
        if (nextNodes.length === 0) {
          return false;
        }
        if (((_nextNodes$ = nextNodes[0]) === null || _nextNodes$ === void 0 ? void 0 : _nextNodes$.type.name) === "hardBreak") {
          return false;
        }
        if ((_nextNodes$2 = nextNodes[0]) !== null && _nextNodes$2 !== void 0 && _nextNodes$2.isBlock || (_currentNodes2 = currentNodes[currentNodes.length - 1]) !== null && _currentNodes2 !== void 0 && _currentNodes2.isBlock) {
          return false;
        }
      }
      return true;
    }
    function isConsecutiveMediaGroups(currentNodes, nextNodes) {
      var _currentNodes3, _nextNodes$3;
      return currentNodes.length > 0 && ((_currentNodes3 = currentNodes[currentNodes.length - 1]) === null || _currentNodes3 === void 0 ? void 0 : _currentNodes3.type.name) === "mediaGroup" && ((_nextNodes$3 = nextNodes[0]) === null || _nextNodes$3 === void 0 ? void 0 : _nextNodes$3.type.name) === "mediaGroup";
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/mention-link.js
var require_mention_link = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/mention-link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mentionLinkResolver = mentionLinkResolver;
    function mentionLinkResolver(link, schema, context) {
      if (link.notLinkBody.toLowerCase() === "~accountid:" || link.notLinkBody === "~") {
        return [schema.nodes.paragraph.createChecked({}, [schema.nodes.text.create({})])];
      }
      if (link.notLinkBody.startsWith("~")) {
        var mentionText = link.notLinkBody.substring(1);
        var mentionKey = mentionText.toLowerCase();
        var id = context.conversion && context.conversion.mentionConversion && context.conversion.mentionConversion[mentionKey] ? context.conversion.mentionConversion[mentionKey] : mentionText;
        return [schema.nodes.mention.createChecked({
          id
        })];
      }
      return;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/mediaGroup.js
var require_mediaGroup = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/mediaGroup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getMediaGroupNodeView;
    function getMediaGroupNodeView(schema, filename) {
      var _context$conversion$m, _context$conversion, _context$conversion$m2, _context$conversion$m3;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _schema$nodes = schema.nodes, media = _schema$nodes.media, mediaGroup = _schema$nodes.mediaGroup;
      var id = (_context$conversion$m = context === null || context === void 0 ? void 0 : (_context$conversion = context.conversion) === null || _context$conversion === void 0 ? void 0 : (_context$conversion$m2 = _context$conversion.mediaConversion) === null || _context$conversion$m2 === void 0 ? void 0 : (_context$conversion$m3 = _context$conversion$m2[filename]) === null || _context$conversion$m3 === void 0 ? void 0 : _context$conversion$m3.transform) !== null && _context$conversion$m !== void 0 ? _context$conversion$m : filename;
      var collection = context.hydration && context.hydration.media && context.hydration.media.targetCollectionId;
      var mediaNode = media.createChecked({
        id,
        type: "file",
        collection: collection || ""
      });
      return mediaGroup.createChecked({}, mediaNode);
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/attachment-link.js
var require_attachment_link = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/attachment-link.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.attachmentLinkResolver = attachmentLinkResolver;
    var _mediaGroup = _interopRequireDefault(require_mediaGroup());
    function attachmentLinkResolver(link, schema, context) {
      if (link.attachmentName) {
        return [(0, _mediaGroup.default)(schema, link.attachmentName, context)];
      }
      return;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/text.js
var require_text7 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/text.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSurroundingSymbols = exports.StringBuffer = void 0;
    exports.hasAnyOfMarks = hasAnyOfMarks;
    exports.isBlank = isBlank;
    exports.isDigit = isDigit;
    exports.isNotBlank = isNotBlank;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    function hasAnyOfMarks(node, types) {
      return node.marks.findIndex(function(m) {
        return types.findIndex(function(t) {
          return m.type.name === t;
        }) !== -1;
      }) !== -1;
    }
    function isDigit(value) {
      return !!value.match(/^\d$/);
    }
    function isBlank(value) {
      return value === null || value.trim() === "";
    }
    function isNotBlank(value) {
      return !isBlank(value);
    }
    var getSurroundingSymbols = function getSurroundingSymbols2(trimmedInput, openingText, closingText) {
      var openingSymbol = trimmedInput.startsWith("{".concat(openingText, "}")) ? "{".concat(openingText, "}") : openingText;
      var endIndex = trimmedInput.indexOf(closingText, openingSymbol === "{".concat(openingText, "}") ? openingText.length + 2 : openingText.length);
      var closingSymbol = endIndex > -1 && trimmedInput.charAt(endIndex - 1) === "{" && trimmedInput.charAt(endIndex + closingText.length) === "}" ? "{".concat(closingText, "}") : closingText;
      return {
        openingSymbol,
        closingSymbol
      };
    };
    exports.getSurroundingSymbols = getSurroundingSymbols;
    var StringBuffer = /* @__PURE__ */ function() {
      function StringBuffer2() {
        var buffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        (0, _classCallCheck2.default)(this, StringBuffer2);
        this.buffer = buffer;
      }
      (0, _createClass2.default)(StringBuffer2, [{
        key: "indexOf",
        value: function indexOf(value) {
          return this.buffer.indexOf(value);
        }
      }, {
        key: "lastIndexOf",
        value: function lastIndexOf(value) {
          return this.buffer.lastIndexOf(value);
        }
      }, {
        key: "charAt",
        value: function charAt(index) {
          return this.buffer.charAt(index);
        }
      }, {
        key: "length",
        value: function length() {
          return this.buffer.length;
        }
      }, {
        key: "delete",
        value: function _delete(start, end) {
          this.buffer = this.buffer.substring(0, start) + this.buffer.substring(end);
        }
      }, {
        key: "append",
        value: function append(value) {
          this.buffer += value;
        }
      }, {
        key: "substring",
        value: function substring(start, end) {
          return this.buffer.substring(start, end);
        }
      }, {
        key: "deleteCharAt",
        value: function deleteCharAt(index) {
          this.delete(index, index + 1);
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.buffer;
        }
      }]);
      return StringBuffer2;
    }();
    exports.StringBuffer = StringBuffer;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/url-link.js
var require_url_link = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/url-link.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.urlLinkResolver = urlLinkResolver;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _index = require_tokenize();
    var _adfSchema = require_cjs6();
    var _text = require_text6();
    var _text2 = require_text7();
    function urlLinkResolver(link, schema, context) {
      var output = [];
      var url = link.notLinkBody;
      var textRepresentation = link.linkBody || link.notLinkBody;
      if (!(0, _adfSchema.isSafeUrl)(url)) {
        return;
      }
      var ignoreTokenTypes = [_index.TokenType.DOUBLE_DASH_SYMBOL, _index.TokenType.TRIPLE_DASH_SYMBOL, _index.TokenType.QUADRUPLE_DASH_SYMBOL, _index.TokenType.LINK_TEXT, _index.TokenType.ISSUE_KEY];
      var rawContent = (0, _text.parseString)({
        ignoreTokenTypes,
        schema,
        context,
        input: textRepresentation.replace(/^mailto:/, "")
      });
      var decoratedContent = rawContent.map(function(n) {
        var mark2 = schema.marks.link.create({
          href: url
        });
        if (n.type.name === "text" && !(0, _text2.hasAnyOfMarks)(n, ["link", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark2]));
        }
        return n;
      });
      output.push.apply(output, (0, _toConsumableArray2.default)(decoratedContent));
      if (!hasTextNode(rawContent)) {
        var mark = schema.marks.link.create({
          href: url
        });
        var linkTextNode = schema.text(textRepresentation, [mark]);
        output.push(linkTextNode);
      }
      return output;
    }
    function hasTextNode(nodes) {
      return nodes.find(function(n) {
        return n.type.name === "text";
      });
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/issue-key.js
var require_issue_key = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/issue-key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.issueKey = exports.getIssue = exports.buildIssueKeyRegex = exports.buildInlineCard = exports.INLINE_CARD_FROM_TEXT_STAMP = void 0;
    var _text = require_text7();
    var INLINE_CARD_FROM_TEXT_STAMP = /(#icft=)([A-Z][A-Z]+-[0-9]+)/;
    exports.INLINE_CARD_FROM_TEXT_STAMP = INLINE_CARD_FROM_TEXT_STAMP;
    var issueKey = function issueKey2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      if (!context.issueKeyRegex) {
        return fallback(input2, position);
      }
      var match = input2.substring(position).match(context.issueKeyRegex);
      if (!match) {
        return fallback(input2, position);
      }
      var issue = getIssue(context, match[0]);
      if (!issue) {
        return fallback(input2, position);
      }
      var charBefore = input2.charAt(position - 1);
      var charAfter = input2.charAt(position + issue.key.length);
      if ((0, _text.isNotBlank)(charBefore) && isNotAllowedChars(charBefore) || (0, _text.isNotBlank)(charAfter) && isNotAllowedChars(charAfter)) {
        return fallback(input2, position);
      }
      return {
        type: "pmnode",
        nodes: buildInlineCard(schema, issue),
        length: match[0].length
      };
    };
    exports.issueKey = issueKey;
    var fallback = function fallback2(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    };
    var getIssue = function getIssue2(context, key) {
      return context.conversion && context.conversion.inlineCardConversion && context.conversion.inlineCardConversion[key] ? {
        key,
        url: context.conversion.inlineCardConversion[key]
      } : null;
    };
    exports.getIssue = getIssue;
    var buildInlineCard = function buildInlineCard2(schema, issue) {
      return [schema.nodes.inlineCard.createChecked({
        url: withInlineCardFromTextStamp(issue)
      })];
    };
    exports.buildInlineCard = buildInlineCard;
    var withInlineCardFromTextStamp = function withInlineCardFromTextStamp2(issue) {
      return INLINE_CARD_FROM_TEXT_STAMP.test(issue.url) ? issue.url : "".concat(issue.url, "#icft=").concat(issue.key);
    };
    var isNotAllowedChars = function isNotAllowedChars2(char) {
      return !/\s|\(|\)|!|\.|\,|\/|\:/.test(char);
    };
    var buildIssueKeyRegex = function buildIssueKeyRegex2(inlineCardConversion) {
      if (!inlineCardConversion) {
        return void 0;
      }
      var pattern = Object.keys(inlineCardConversion).join("|");
      if (!pattern) {
        return void 0;
      }
      return new RegExp("^(".concat(pattern, ")"));
    };
    exports.buildIssueKeyRegex = buildIssueKeyRegex;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/issue-link.js
var require_issue_link = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/issue-link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.issueLinkResolver = issueLinkResolver;
    var _issueKey = require_issue_key();
    function issueLinkResolver(link, schema, context) {
      var originalLinkText = link.originalLinkText, linkTitle = link.linkTitle, notLinkBody = link.notLinkBody;
      if (linkTitle === "smart-card" || linkTitle === "block-link") {
        return [schema.nodes.blockCard.createChecked({
          url: notLinkBody
        })];
      }
      if (linkTitle === "smart-link") {
        return [schema.nodes.inlineCard.createChecked({
          url: notLinkBody
        })];
      }
      if (linkTitle === "smart-embed") {
        return [schema.nodes.embedCard.createChecked({
          url: notLinkBody
        })];
      }
      var issue = (0, _issueKey.getIssue)(context, originalLinkText);
      if (issue) {
        return (0, _issueKey.buildInlineCard)(schema, issue);
      }
      return void 0;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-resolver.js
var require_link_resolver = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveLink = resolveLink;
    var _mentionLink = require_mention_link();
    var _attachmentLink = require_attachment_link();
    var _urlLink = require_url_link();
    var _issueLink = require_issue_link();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var linkResolverStrategies = [_attachmentLink.attachmentLinkResolver, _mentionLink.mentionLinkResolver, _issueLink.issueLinkResolver, _urlLink.urlLinkResolver];
    function resolveLink(link, schema, context) {
      var length = link.originalLinkText.length + 2;
      var _iterator = _createForOfIteratorHelper(linkResolverStrategies), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var resolver = _step.value;
          var resolvedLink = resolver(link, schema, context);
          if (resolvedLink) {
            return {
              length,
              nodes: resolvedLink,
              type: "pmnode"
            };
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return void 0;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-parser.js
var require_link_parser = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-parser.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseContentLink = parseContentLink;
    exports.parseLink = parseLink;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _text = require_text7();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function trimIfPossible(s) {
      if (s === null) {
        return null;
      }
      return s.trim();
    }
    function extractLinkBody(buffer) {
      var indexOfBang = buffer.indexOf("!");
      var indexOfPipe = buffer.indexOf("|");
      var lastIndexOfBang = buffer.lastIndexOf("!");
      var notEscaped = indexOfBang === -1 || indexOfBang > indexOfPipe || indexOfBang === lastIndexOfBang;
      if (notEscaped) {
        return divideOn(buffer, "|");
      }
      var body = new _text.StringBuffer();
      var inEscape = false;
      for (var i = 0; i < buffer.length(); i++) {
        var c = buffer.charAt(i);
        if (c === "!") {
          inEscape = !inEscape;
        }
        if (c === "|" && !inEscape) {
          buffer.delete(0, i + 1);
          return body.toString();
        }
        body.append(c);
      }
      return null;
    }
    function divideAfterLast(buffer, divider) {
      if (buffer.length() === 0) {
        return null;
      }
      return divideAfter(buffer, buffer.lastIndexOf(divider));
    }
    function divideAfter(buffer, index) {
      if (typeof index === "string") {
        index = buffer.indexOf(index);
      }
      if (index < 0) {
        return null;
      } else if (index === buffer.length() - 1) {
        buffer.deleteCharAt(buffer.length() - 1);
        return null;
      } else {
        var body = buffer.substring(index + 1);
        buffer.delete(index, buffer.length());
        return body;
      }
    }
    function divideOn(buffer, divider) {
      if (buffer.length() === 0) {
        return null;
      }
      var i = buffer.indexOf(divider);
      if (i < 0) {
        return null;
      } else if (i === 0) {
        buffer.deleteCharAt(0);
        return null;
      } else {
        var body = buffer.substring(0, i);
        buffer.delete(0, i + 1);
        return body;
      }
    }
    function extractNumber(buf) {
      var digits = new _text.StringBuffer();
      var i = 0;
      for (; i < buf.length() && (0, _text.isDigit)(buf.charAt(i)); i++) {
        digits.append(buf.charAt(i));
      }
      if (i > 0) {
        buf.delete(0, i);
      }
      try {
        return parseInt(digits.toString(), 10);
      } catch (e) {
        return 0;
      }
    }
    function parseLink(linkText) {
      var originalLinkText = linkText;
      if (linkText.indexOf("&#039;") !== -1) {
        linkText = linkText.replace("&#039;", "'");
      }
      var buf = new _text.StringBuffer(linkText);
      var linkBody = extractLinkBody(buf);
      var linkTitle = trimIfPossible(divideAfter(buf, "|"));
      var notLinkBody = buf.toString().trim();
      return {
        originalLinkText,
        linkBody,
        linkTitle,
        notLinkBody
      };
    }
    function parseContentLink(link) {
      if (typeof link === "string") {
        link = parseLink(link);
      }
      var _link = link, notLinkBody = _link.notLinkBody;
      var shortcutName = null;
      var shortcutValue = null;
      var spaceKey = null;
      var attachmentName = null;
      var anchor = null;
      var destinationTitle = "";
      var contentId = 0;
      if (!notLinkBody.startsWith("~")) {
        var shortcutBuf = new _text.StringBuffer(notLinkBody);
        shortcutName = trimIfPossible(divideAfterLast(shortcutBuf, "@"));
        if ((0, _text.isNotBlank)(shortcutName)) {
          shortcutValue = shortcutBuf.toString();
        }
      }
      var buf = new _text.StringBuffer(notLinkBody);
      if ((0, _text.isBlank)(shortcutName)) {
        spaceKey = trimIfPossible(divideOn(buf, ":"));
        if (buf.indexOf("$") === 0) {
          buf.deleteCharAt(0);
          contentId = extractNumber(buf);
          if (contentId === 0) {
            return _objectSpread(_objectSpread({}, link), {}, {
              shortcutName,
              shortcutValue,
              spaceKey,
              contentId,
              attachmentName,
              anchor,
              destinationTitle
            });
          }
        }
        attachmentName = trimIfPossible(divideAfter(buf, "^"));
        anchor = trimIfPossible(divideAfter(buf, "#"));
      }
      if (contentId === 0) {
        destinationTitle = buf.toString().trim();
      }
      return _objectSpread(_objectSpread({}, link), {}, {
        shortcutName,
        shortcutValue,
        spaceKey,
        contentId,
        attachmentName,
        anchor,
        destinationTitle
      });
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-format.js
var require_link_format = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/links/link-format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.linkFormat = void 0;
    var _ = require_tokenize();
    var _text = require_text6();
    var _linkResolver = require_link_resolver();
    var _linkParser = require_link_parser();
    var LINK_FORMAT_REGEXP = /^\[([^\[\]\n]+)]/;
    var linkFormat = function linkFormat2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var match = input2.substring(position).match(LINK_FORMAT_REGEXP);
      var ignoreTokenTypes = [
        _.TokenType.DOUBLE_DASH_SYMBOL,
        _.TokenType.TRIPLE_DASH_SYMBOL,
        _.TokenType.QUADRUPLE_DASH_SYMBOL,
        _.TokenType.TABLE,
        _.TokenType.RULER,
        // We want to avoid recursion
        _.TokenType.LINK_TEXT,
        _.TokenType.LINK_FORMAT
      ];
      if (!match) {
        return fallback();
      }
      var content = (0, _linkParser.parseContentLink)(match[1]);
      var resolvedLink = (0, _linkResolver.resolveLink)(content, schema, context);
      if (resolvedLink) {
        return resolvedLink;
      }
      var nodes = (0, _text.parseString)({
        schema,
        context,
        ignoreTokenTypes,
        input: match[0]
      });
      return {
        type: "pmnode",
        nodes,
        length: match[0].length
      };
    };
    exports.linkFormat = linkFormat;
    function fallback() {
      return {
        type: "text",
        text: "[",
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/common-formatter.js
var require_common_formatter = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/common-formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commonFormatter = commonFormatter;
    var _ = require_tokenize();
    var _linkFormat = require_link_format();
    var _whitespace = require_whitespace();
    var _keyword = require_keyword();
    var _2 = require_tokenize();
    var _escape = require_escape3();
    var processState = {
      START: 0,
      BUFFER: 1,
      END: 2,
      INLINE_MACRO: 3,
      LINK_FORMAT: 4,
      ESCAPE: 5
    };
    function commonFormatter(input2, position, schema, opt) {
      var index = position;
      var state = processState.START;
      var buffer = [];
      var openingSymbolLength = opt.opening.length;
      var closingSymbolLength = opt.closing.length;
      while (index < input2.length) {
        var char = input2.charAt(index);
        var twoChar = input2.substr(index, 2);
        var charsMatchClosingSymbol = input2.substr(index, closingSymbolLength);
        switch (state) {
          case processState.START: {
            if (position > 0) {
              var charBeforeOpening = input2.charAt(position - 1);
              if (/[a-zA-Z0-9]|[^\u0000-\u007F]/.test(charBeforeOpening) && charBeforeOpening !== "\xA0") {
                return fallback(input2, index, openingSymbolLength);
              }
            }
            var charAfterOpening = input2.charAt(index + openingSymbolLength);
            if (!input2.substring(position).startsWith(opt.opening) || charAfterOpening === " ") {
              return fallback(input2, position, openingSymbolLength);
            }
            state = processState.BUFFER;
            index += openingSymbolLength;
            continue;
          }
          case processState.BUFFER: {
            var _length = (0, _whitespace.parseNewlineOnly)(input2.substring(index));
            if (_length) {
              return fallback(input2, position, openingSymbolLength);
            }
            if (charsMatchClosingSymbol === opt.closing) {
              state = processState.END;
              continue;
            } else if (twoChar === "{{") {
              buffer.push(twoChar);
              index += 2;
              continue;
            } else if (char === "{") {
              state = processState.INLINE_MACRO;
              continue;
            } else if (char === "[") {
              state = processState.LINK_FORMAT;
              continue;
            } else if (char === "\\") {
              state = processState.ESCAPE;
              continue;
            } else {
              buffer.push(char);
            }
            break;
          }
          case processState.END: {
            index += closingSymbolLength;
            if (buffer.length === 0) {
              return fallback(input2, position, openingSymbolLength);
            }
            if (index < input2.length) {
              var charAfterEnd = input2.charAt(index);
              if (/[a-zA-Z0-9]|[^\u0000-\u007F]/.test(charAfterEnd) && charAfterEnd !== "\xA0") {
                buffer.push(charsMatchClosingSymbol);
                state = processState.BUFFER;
                continue;
              }
            }
            if (buffer.length > 0 && buffer[buffer.length - 1].endsWith(" ")) {
              return fallback(input2, position, openingSymbolLength);
            }
            return opt.rawContentProcessor(buffer.join(""), index - position);
          }
          case processState.INLINE_MACRO: {
            var match = (0, _keyword.parseMacroKeyword)(input2.substring(index));
            if (!match) {
              buffer.push(char);
              state = processState.BUFFER;
              break;
            }
            var token = (0, _2.parseToken)(input2, match.type, index, schema, {});
            if (token.type === "text") {
              buffer.push(token.text);
              index += token.length;
              state = processState.BUFFER;
              continue;
            } else if (match.type === _.TokenType.COLOR_MACRO) {
              buffer.push(input2.substr(index, token.length));
              index += token.length;
              state = processState.BUFFER;
              continue;
            } else {
              return fallback(input2, position, openingSymbolLength);
            }
          }
          case processState.LINK_FORMAT: {
            var _token = (0, _linkFormat.linkFormat)({
              input: input2,
              schema,
              position: index,
              context: {}
            });
            if (_token.type === "text") {
              buffer.push(_token.text);
              index += _token.length;
              state = processState.BUFFER;
              continue;
            } else if (_token.type === "pmnode") {
              buffer.push(input2.substr(index, _token.length));
              index += _token.length;
              state = processState.BUFFER;
              continue;
            }
            return fallback(input2, position, openingSymbolLength);
          }
          case processState.ESCAPE: {
            var _token2 = (0, _escape.escapeHandler)(input2, index);
            buffer.push(_token2.text);
            index += _token2.length;
            state = processState.BUFFER;
            continue;
          }
          default:
        }
        index++;
      }
      return fallback(input2, position, openingSymbolLength);
    }
    function fallback(input2, position, length) {
      return {
        type: "text",
        text: input2.substr(position, length),
        length
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/media.js
var require_media3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/media.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.media = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _mediaSingle = _interopRequireDefault(require_mediaSingle());
    var _attrs = require_attrs();
    var _commonFormatter = require_common_formatter();
    var media = function media2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var _raw$split = raw.split("|"), _raw$split2 = (0, _slicedToArray2.default)(_raw$split, 2), rawContent = _raw$split2[0], _raw$split2$ = _raw$split2[1], rawAttrs = _raw$split2$ === void 0 ? "" : _raw$split2$;
        var node = (0, _mediaSingle.default)(schema, rawContent, (0, _attrs.parseAttrs)(rawAttrs, ","), context);
        return {
          type: "pmnode",
          nodes: [node],
          length
        };
      };
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: "!",
        closing: "!",
        context,
        rawContentProcessor
      });
    };
    exports.media = media;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/common-macro.js
var require_common_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/common-macro.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commonMacro = commonMacro;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    function commonMacro(input2, schema, opt) {
      var opening = new RegExp("^{(".concat(opt.keyword, ")(?::([^{\n}]*))?}"), "i");
      var matchOpening = input2.match(opening);
      if (!matchOpening) {
        return fallback(input2);
      }
      var _matchOpening = (0, _slicedToArray2.default)(matchOpening, 3), name = _matchOpening[1], rawAttrs = _matchOpening[2];
      var openingLength = matchOpening[0].length;
      if (!opt.paired) {
        return opt.rawContentProcessor(rawAttrs, "", openingLength, schema, opt.context);
      }
      var closing = new RegExp("{".concat(name, "}"));
      var matchClosing = closing.exec(input2.substring(openingLength));
      var rawContent = "";
      if (matchClosing) {
        rawContent = input2.substring(openingLength, openingLength + matchClosing.index);
      }
      var length = matchClosing ? openingLength + matchClosing.index + matchClosing[0].length : openingLength;
      return opt.rawContentProcessor(rawAttrs, rawContent, length, schema, opt.context);
    }
    function fallback(input2) {
      return {
        type: "text",
        text: input2.substr(0, 1),
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/quote-macro.js
var require_quote_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/quote-macro.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rawContentProcessor = exports.quoteMacro = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _commonMacro = require_common_macro();
    var _text = require_text7();
    var _normalize = require_normalize3();
    var _text2 = require_text6();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var quoteMacro = function quoteMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "quote",
        paired: true,
        rawContentProcessor,
        context
      });
    };
    exports.quoteMacro = quoteMacro;
    var rawContentProcessor = function rawContentProcessor2(_rawAttrs, rawContent, length, schema, context) {
      if (!rawContent.length) {
        var emptyQuote = emptyBlockquote(schema);
        return {
          type: "pmnode",
          nodes: [emptyQuote],
          length
        };
      }
      var parsedContent = (0, _text2.parseString)({
        schema,
        context,
        ignoreTokenTypes: [],
        input: rawContent
      });
      var normalizedContent = (0, _normalize.normalizePMNodes)(parsedContent, schema);
      return {
        type: "pmnode",
        nodes: sanitize(normalizedContent, schema),
        length
      };
    };
    exports.rawContentProcessor = rawContentProcessor;
    function emptyBlockquote(schema) {
      var p = schema.nodes.paragraph.createChecked({}, []);
      return schema.nodes.blockquote.createChecked({}, p);
    }
    function sanitize(nodes, schema) {
      var output = [];
      var contentBuffer = [];
      var _iterator = _createForOfIteratorHelper(nodes), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var n = _step.value;
          switch (n.type.name) {
            case "paragraph": {
              contentBuffer.push(n);
              break;
            }
            case "heading": {
              contentBuffer.push(transformHeading(n, schema));
              break;
            }
            default:
              if (contentBuffer.length) {
                var _blockquote = schema.nodes.blockquote.createChecked({}, contentBuffer);
                output.push(_blockquote);
                contentBuffer = [];
              }
              output.push(n);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (contentBuffer.length) {
        var blockquote = schema.nodes.blockquote.createChecked({}, contentBuffer);
        output.push(blockquote);
      }
      return output;
    }
    function transformHeading(heading, schema) {
      var contentBuffer = [];
      heading.content.forEach(function(n) {
        var strong = schema.marks.strong.create();
        var italic = schema.marks.em.create();
        var gray = schema.marks.textColor.create({
          color: "#97a0af"
        });
        if (n.type.name === "text") {
          if (n.text && heading.attrs.level === 1) {
            n.text = n.text.toUpperCase();
          }
          if (heading.attrs.level <= 4 && !(0, _text.hasAnyOfMarks)(n, ["strong", "code"])) {
            n = n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [strong]));
          }
          if ((heading.attrs.level === 5 || heading.attrs.level === 2) && !(0, _text.hasAnyOfMarks)(n, ["em", "code"])) {
            n = n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [italic]));
          }
          if (heading.attrs.level > 3 && !(0, _text.hasAnyOfMarks)(n, ["textColor", "code"])) {
            n = n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [gray]));
          }
        }
        contentBuffer.push(n);
      });
      return schema.nodes.paragraph.createChecked({}, contentBuffer);
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/blockquote.js
var require_blockquote5 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/blockquote.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.blockquote = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _quoteMacro = require_quote_macro();
    var BLOCKQUOTE_REGEXP = /^bq\.(.*)/;
    var blockquote = function blockquote2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var match = input2.substring(position).match(BLOCKQUOTE_REGEXP);
      if (!match) {
        return fallback(input2, position);
      }
      var _match = (0, _slicedToArray2.default)(match, 2), rawContent = _match[1];
      return (0, _quoteMacro.rawContentProcessor)("", rawContent, match[0].length, schema, context);
    };
    exports.blockquote = blockquote;
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/char.js
var require_char = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/char.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EM_DASH = void 0;
    var EM_DASH = "\u2014";
    exports.EM_DASH = EM_DASH;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/citation.js
var require_citation = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/citation.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.citation = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var _char = require_char();
    var citation = function citation2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY];
      var contentDecorator = function contentDecorator2(n, index) {
        var mark = schema.marks.em.create();
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["em", "code"])) {
          if (index === 0) {
            n.text = "".concat(_char.EM_DASH, " ").concat(n.text);
          }
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "??", "??"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.citation = citation;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/deleted.js
var require_deleted = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/deleted.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.deleted = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var deleted = function deleted2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.strike.create();
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["strike", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "-", "-"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.deleted = deleted;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/dash-token-creator.js
var require_dash_token_creator = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/dash-token-creator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createDashTokenParser = void 0;
    var createDashTokenParser = function createDashTokenParser2(token, fallback) {
      return function(_ref) {
        var input2 = _ref.input, position = _ref.position;
        if (position > 0) {
          var charBeforeToken = input2.charAt(position - 1);
          if (!isSpace(charBeforeToken)) {
            return fallback;
          }
        }
        if (position + token.length < input2.length) {
          var charAfterToken = input2.charAt(position + token.length);
          if (!isSpace(charAfterToken)) {
            return fallback;
          }
        }
        return token;
      };
    };
    exports.createDashTokenParser = createDashTokenParser;
    var isSpace = function isSpace2(char) {
      return /\s/.test(char);
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/double-dash-symbol.js
var require_double_dash_symbol = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/double-dash-symbol.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doubleDashSymbol = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _dashTokenCreator = require_dash_token_creator();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var token = {
      type: "text",
      text: "\u2013",
      // EN DASH
      length: 2
    };
    var fallback = _objectSpread(_objectSpread({}, token), {}, {
      text: "--"
    });
    var doubleDashSymbol = (0, _dashTokenCreator.createDashTokenParser)(token, fallback);
    exports.doubleDashSymbol = doubleDashSymbol;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/emoji.js
var require_emoji4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wikiToAdfEmojiMapping = exports.emoji = exports.adfEmojiItems = void 0;
    var emptyOrSpecialCharRegex = new RegExp(/^$|[^A-Za-z0-9]/);
    var emoji = function emoji2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema;
      var substring = input2.substring(position);
      for (var i = 2; i <= 9 && i <= substring.length; ++i) {
        var candidateText = substring.substring(0, i);
        var emojiId = wikiToAdfEmojiMapping[candidateText];
        if (emojiId && emptyOrSpecialCharRegex.test(substring.charAt(i))) {
          return {
            type: "pmnode",
            nodes: [schema.nodes.emoji.createChecked(adfEmojiItems[emojiId])],
            length: i
          };
        }
      }
      return {
        type: "text",
        text: substring.substr(0, 1),
        length: 1
      };
    };
    exports.emoji = emoji;
    var adfEmojiItems = {
      "1f642": {
        id: "1f642",
        shortName: ":slight_smile:",
        text: "\u{1F642}"
      },
      "1f61e": {
        id: "1f61e",
        shortName: ":disappointed:",
        text: "\u{1F61E}"
      },
      "1f61b": {
        id: "1f61b",
        shortName: ":stuck_out_tongue:",
        text: "\u{1F61B}"
      },
      "1f603": {
        id: "1f603",
        shortName: ":smiley:",
        text: "\u{1F603}"
      },
      "1f609": {
        id: "1f609",
        shortName: ":wink:",
        text: "\u{1F609}"
      },
      "1f44d": {
        id: "1f44d",
        shortName: ":thumbsup:",
        text: "\u{1F44D}"
      },
      "1f44e": {
        id: "1f44e",
        shortName: ":thumbsdown:",
        text: "\u{1F44E}"
      },
      "atlassian-info": {
        id: "atlassian-info",
        shortName: ":info:",
        text: ":info"
      },
      "atlassian-check_mark": {
        id: "atlassian-check_mark",
        shortName: ":check_mark:",
        text: ":check_mark:"
      },
      "atlassian-cross_mark": {
        id: "atlassian-cross_mark",
        shortName: ":cross_mark:",
        text: ":cross_mark:"
      },
      "atlassian-warning": {
        id: "atlassian-warning",
        shortName: ":warning:",
        text: ":warning:"
      },
      "atlassian-plus": {
        id: "atlassian-plus",
        shortName: ":plus:",
        text: ":plus:"
      },
      "atlassian-minus": {
        id: "atlassian-minus",
        shortName: ":minus:",
        text: ":minus:"
      },
      "atlassian-question_mark": {
        id: "atlassian-question_mark",
        shortName: ":question:",
        text: ":question:"
      },
      "atlassian-light_bulb_on": {
        id: "atlassian-light_bulb_on",
        shortName: ":light_bulb_on:",
        text: ":light_bulb_on:"
      },
      "atlassian-light_bulb_off": {
        id: "atlassian-light_bulb_off",
        shortName: ":light_bulb_off:",
        text: ":light_bulb_off:"
      },
      "atlassian-yellow_star": {
        id: "atlassian-yellow_star",
        shortName: ":yellow_star:",
        text: ":yellow_star:"
      },
      "atlassian-red_star": {
        id: "atlassian-red_star",
        shortName: ":red_star:",
        text: ":red_star:"
      },
      "atlassian-green_star": {
        id: "atlassian-green_star",
        shortName: ":green_star:",
        text: ":green_star:"
      },
      "atlassian-blue_star": {
        id: "atlassian-blue_star",
        shortName: ":blue_star:",
        text: ":blue_star:"
      },
      "atlassian-flag_on": {
        id: "atlassian-flag_on",
        shortName: ":flag_on:",
        text: ":flag_on:"
      },
      "atlassian-flag_off": {
        id: "atlassian-flag_off",
        shortName: ":flag_off:",
        text: ":flag_off:"
      }
    };
    exports.adfEmojiItems = adfEmojiItems;
    var wikiToAdfEmojiMapping = {
      ":)": "1f642",
      ":-)": "1f642",
      ":(": "1f61e",
      ":-(": "1f61e",
      ":P": "1f61b",
      ":-P": "1f61b",
      ":p": "1f61b",
      ":-p": "1f61b",
      ":D": "1f603",
      ":-D": "1f603",
      ";)": "1f609",
      ";-)": "1f609",
      "(y)": "1f44d",
      "(n)": "1f44e",
      "(i)": "atlassian-info",
      "(/)": "atlassian-check_mark",
      "(x)": "atlassian-cross_mark",
      "(!)": "atlassian-warning",
      "(+)": "atlassian-plus",
      "(-)": "atlassian-minus",
      "(?)": "atlassian-question_mark",
      "(on)": "atlassian-light_bulb_on",
      "(off)": "atlassian-light_bulb_off",
      "(*)": "atlassian-yellow_star",
      "(*y)": "atlassian-yellow_star",
      "(*r)": "atlassian-red_star",
      "(*g)": "atlassian-green_star",
      "(*b)": "atlassian-blue_star",
      "(flag)": "atlassian-flag_on",
      "(flagoff)": "atlassian-flag_off"
    };
    exports.wikiToAdfEmojiMapping = wikiToAdfEmojiMapping;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/emphasis.js
var require_emphasis3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/emphasis.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.emphasis = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var emphasis = function emphasis2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.em.create();
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["em", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "_", "_"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.emphasis = emphasis;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/hardbreak.js
var require_hardbreak = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/hardbreak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hardbreak = void 0;
    var _whitespace = require_whitespace();
    var hardbreak = function hardbreak2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema;
      var length = (0, _whitespace.parseNewlineOnly)(input2.substring(position));
      if (length === 0) {
        return {
          type: "text",
          text: input2.substr(position, 1),
          length: 1
        };
      }
      return {
        type: "pmnode",
        nodes: [schema.nodes.hardBreak.createChecked()],
        length
      };
    };
    exports.hardbreak = hardbreak;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/heading.js
var require_heading4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/heading.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.heading = void 0;
    var _text = require_text6();
    var _ = require_tokenize();
    var HEADING_REGEXP = /^h([1-6])\.(.*)/;
    var heading = function heading2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL];
      var match = input2.substring(position).match(HEADING_REGEXP);
      if (!match) {
        return fallback(input2, position);
      }
      var level = parseInt(match[1], 10);
      var content = (0, _text.parseString)({
        schema,
        ignoreTokenTypes,
        context,
        input: match[2]
      });
      try {
        var headingNode = schema.nodes.heading.createChecked({
          level
        }, content);
        return {
          type: "pmnode",
          nodes: [headingNode],
          length: match[0].length
        };
      } catch (err) {
        return {
          type: "text",
          text: "",
          length: 4
        };
      }
    };
    exports.heading = heading;
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/inserted.js
var require_inserted = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/inserted.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inserted = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var inserted = function inserted2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.underline.create();
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["underline", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "+", "+"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.inserted = inserted;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/builder/list-builder.js
var require_list_builder = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/builder/list-builder.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ListBuilder = void 0;
    exports.getType = getType;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var supportedContentType = ["paragraph", "orderedList", "bulletList", "mediaSingle", "codeBlock"];
    function getType(bullets) {
      return /#$/.test(bullets) ? "orderedList" : "bulletList";
    }
    var ListBuilder = /* @__PURE__ */ function() {
      function ListBuilder2(schema, bullets) {
        var _this = this;
        (0, _classCallCheck2.default)(this, ListBuilder2);
        (0, _defineProperty2.default)(this, "parseList", function(list) {
          var listNode = _this.schema.nodes[list.type];
          var output = [];
          var listItemsBuffer = [];
          for (var i = 0; i < list.children.length; i++) {
            var parsedContent = _this.parseListItem(list.children[i]);
            for (var j = 0; j < parsedContent.length; j++) {
              var parsedNode = parsedContent[j];
              if (parsedNode.type.name === "listItem") {
                listItemsBuffer.push(parsedNode);
                continue;
              }
              if (listItemsBuffer.length) {
                var _list = listNode.createChecked({}, listItemsBuffer);
                output.push(_list);
              }
              output.push(parsedNode);
              listItemsBuffer = [];
            }
          }
          if (listItemsBuffer.length) {
            var _list2 = listNode.createChecked({}, listItemsBuffer);
            output.push(_list2);
          }
          return output;
        });
        (0, _defineProperty2.default)(this, "parseListItem", function(item) {
          var _item$content;
          var output = [];
          if (!item.content) {
            item.content = [];
          }
          var parsedChildren = item.children.reduce(function(result, list) {
            var parsedList = _this.parseList(list);
            result.push.apply(result, (0, _toConsumableArray2.default)(parsedList));
            return result;
          }, []);
          (_item$content = item.content).push.apply(_item$content, (0, _toConsumableArray2.default)(parsedChildren));
          var contentBuffer = [];
          for (var i = 0; i < item.content.length; i++) {
            var pmNode = item.content[i];
            if (pmNode.type.name === "paragraph" && pmNode.childCount === 0) {
              continue;
            }
            if (_this.isParagraphEmptyTextNode(pmNode)) {
              continue;
            }
            if (supportedContentType.indexOf(pmNode.type.name) === -1) {
              var listItem = _this.createListItem(contentBuffer, _this.schema);
              output.push(listItem);
              output.push(pmNode);
              contentBuffer = [];
              continue;
            }
            contentBuffer.push(pmNode);
          }
          if (contentBuffer.length) {
            var _listItem = _this.createListItem(contentBuffer, _this.schema);
            output.push(_listItem);
          }
          return output;
        });
        this.schema = schema;
        this.root = {
          children: [],
          type: getType(bullets)
        };
        this.lastDepth = 1;
        this.lastList = this.root;
      }
      (0, _createClass2.default)(ListBuilder2, [{
        key: "type",
        get: function get() {
          return this.root.type;
        }
        /**
         * Add a list item to the builder
         * @param {AddArgs[]} items
         */
      }, {
        key: "add",
        value: function add(items) {
          var _iterator = _createForOfIteratorHelper(items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var item = _step.value;
              var style = item.style, content = item.content;
              if (style === null) {
                this.appendToLastItem(content);
                continue;
              }
              var depth = style.length;
              var type = getType(style);
              if (depth > this.lastDepth) {
                this.createNest(depth - this.lastDepth, type);
                this.lastDepth = depth;
                this.lastList = this.addListItem(type, content);
              } else if (depth === this.lastDepth) {
                this.lastList = this.addListItem(type, content);
              } else {
                this.lastList = this.findAncestor(this.lastDepth - depth);
                this.lastDepth = depth;
                this.lastList = this.addListItem(type, content);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        /**
         * Compile a prosemirror node from the root list
         * @returns {PMNode[]}
         */
      }, {
        key: "buildPMNode",
        value: function buildPMNode() {
          return this.parseList(this.root);
        }
        /**
         * Build prosemirror bulletList or orderedList node
         * @param {List} list
         * @returns {PMNode}
         */
        /**
         * Build prosemirror listItem node
         * This function would possibly return non listItem nodes
         * which we need to break out later
         * @param {ListItem} item
         */
      }, {
        key: "isParagraphEmptyTextNode",
        value: (
          /* Check if all paragraph's children nodes are text and empty */
          function isParagraphEmptyTextNode(node) {
            if (node.type.name !== "paragraph" || !node.childCount) {
              return false;
            }
            for (var i = 0; i < node.childCount; i++) {
              var n = node.content.child(i);
              if (n.type.name !== "text") {
                return false;
              } else if (n.textContent.trim() !== "") {
                return false;
              }
            }
            return true;
          }
        )
      }, {
        key: "createListItem",
        value: function createListItem(content, schema) {
          if (content.length === 0 || ["paragraph", "mediaSingle"].indexOf(content[0].type.name) === -1) {
            content.unshift(this.schema.nodes.paragraph.createChecked());
          }
          return schema.nodes.listItem.createChecked({}, content);
        }
        /**
         * Add an item at the same level as the current list item
         * @param {ListType} type
         * @param {PMNode} content
         * @returns {PMNode}
         */
      }, {
        key: "addListItem",
        value: function addListItem(type, content) {
          var list = this.lastList;
          if (list.type !== type) {
            var parent = list.parent;
            var newList = {
              children: [],
              type,
              parent
            };
            parent.children.push(newList);
            this.lastList = list = newList;
          }
          var listItem = {
            content,
            parent: list,
            children: []
          };
          list.children = [].concat((0, _toConsumableArray2.default)(list.children), [listItem]);
          return list;
        }
        /**
         * Append the past content to the last accessed list node (multiline entries)
         * @param {PMNode[]} content
         */
      }, {
        key: "appendToLastItem",
        value: function appendToLastItem(content) {
          var _ref;
          var children = this.lastList.children;
          var lastItem = children[children.length - 1];
          (_ref = lastItem.content).push.apply(_ref, (0, _toConsumableArray2.default)(content));
        }
        /**
         * Created a nested list structure of N depth under the current node
         * @param {number} depth
         * @param {ListType} type
         */
      }, {
        key: "createNest",
        value: function createNest(depth, type) {
          while (depth-- > 0) {
            if (this.lastList.children.length === 0) {
              var listItem = {
                parent: this.lastList,
                children: []
              };
              this.lastList.children = [listItem];
            }
            var nextItem = this.lastList.children[this.lastList.children.length - 1];
            nextItem.children = [{
              children: [],
              parent: nextItem,
              type
            }];
            this.lastList = nextItem.children[0];
          }
        }
        /**
         * Find the Nth list ancestor of the current list
         * @param {number} depth
         */
      }, {
        key: "findAncestor",
        value: function findAncestor(depth) {
          var list = this.lastList;
          while (depth-- > 0 && list.parent) {
            var listItem = list.parent;
            if (listItem && listItem.parent) {
              list = listItem.parent;
            }
          }
          return list;
        }
      }]);
      return ListBuilder2;
    }();
    exports.ListBuilder = ListBuilder;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/list.js
var require_list3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/list.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.list = exports.MAX_LIST_DEPTH = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _listBuilder = require_list_builder();
    var _text = require_text6();
    var _normalize = require_normalize3();
    var _keyword = require_keyword();
    var _ = require_tokenize();
    var _whitespace = require_whitespace();
    var _text2 = require_text7();
    var MAX_LIST_DEPTH = 20;
    exports.MAX_LIST_DEPTH = MAX_LIST_DEPTH;
    var LIST_ITEM_REGEXP = new RegExp("^ *([*\\-#]{1,".concat(MAX_LIST_DEPTH, "}) "));
    var EMPTY_LINE_REGEXP = /^[ \t]*\r?\n/;
    var RULER_SYMBOL_REGEXP = /^-{4,5}/;
    var processState = {
      NEW_LINE: 0,
      BUFFER: 1,
      END: 2,
      MACRO: 3
    };
    var list = function list2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.LIST, _.TokenType.TABLE];
      var index = position;
      var state = processState.NEW_LINE;
      var buffer = [];
      var lastListSymbols = null;
      var builder = null;
      var contentBuffer = [];
      var output = [];
      while (index < input2.length) {
        var char = input2.charAt(index);
        switch (state) {
          case processState.NEW_LINE: {
            var substring = input2.substring(index);
            var listMatch = substring.match(LIST_ITEM_REGEXP);
            if (listMatch) {
              var _listMatch = (0, _slicedToArray2.default)(listMatch, 2), symbols = _listMatch[1];
              var rulerMatch = symbols.match(RULER_SYMBOL_REGEXP);
              if (rulerMatch) {
                var remainingAfterSymbol = input2.substring(index + rulerMatch[0].length);
                var _emptyLineMatch = remainingAfterSymbol.match(EMPTY_LINE_REGEXP);
                if (_emptyLineMatch) {
                  state = processState.BUFFER;
                  continue;
                }
              }
              if (!builder) {
                builder = new _listBuilder.ListBuilder(schema, symbols);
                lastListSymbols = symbols;
              } else {
                if (buffer.length > 0) {
                  var _contentBuffer;
                  var content = (0, _text.parseString)({
                    ignoreTokenTypes,
                    schema,
                    context,
                    input: buffer.join(""),
                    includeLeadingSpace: true
                  });
                  (_contentBuffer = contentBuffer).push.apply(_contentBuffer, (0, _toConsumableArray2.default)(content));
                  builder.add([{
                    style: lastListSymbols,
                    content: sanitize((0, _normalize.normalizePMNodes)(contentBuffer, schema), schema)
                  }]);
                  buffer = [];
                  contentBuffer = [];
                }
                lastListSymbols = symbols;
                var type = (0, _listBuilder.getType)(symbols);
                if (type !== builder.type && symbols.length === 1) {
                  output.push.apply(output, (0, _toConsumableArray2.default)(builder.buildPMNode()));
                  builder = new _listBuilder.ListBuilder(schema, symbols);
                }
              }
              index += listMatch[0].length;
            }
            var emptyLineMatch = substring.match(EMPTY_LINE_REGEXP);
            if (emptyLineMatch) {
              state = processState.END;
              continue;
            }
            state = processState.BUFFER;
            continue;
          }
          case processState.BUFFER: {
            var length = (0, _whitespace.parseNewlineOnly)(input2.substring(index));
            if (length) {
              buffer.push(input2.substr(index, length));
              state = processState.NEW_LINE;
              index += length;
              continue;
            }
            if (char === "{") {
              state = processState.MACRO;
              continue;
            } else {
              buffer.push(char);
            }
            break;
          }
          case processState.MACRO: {
            var match = (0, _keyword.parseMacroKeyword)(input2.substring(index));
            if (!match) {
              buffer.push(char);
              state = processState.BUFFER;
              break;
            }
            var token = (0, _.parseToken)(input2, match.type, index, schema, context);
            if (token.type === "text") {
              buffer.push(token.text);
            } else {
              var _contentBuffer3;
              if (!builder) {
                return fallback(input2, position);
              }
              if (buffer.length > 0) {
                var _contentBuffer2;
                var _content = (0, _text.parseString)({
                  ignoreTokenTypes,
                  schema,
                  context,
                  input: buffer.join(""),
                  includeLeadingSpace: true
                });
                (_contentBuffer2 = contentBuffer).push.apply(_contentBuffer2, (0, _toConsumableArray2.default)(sanitize(_content, schema)));
                buffer = [];
              }
              (_contentBuffer3 = contentBuffer).push.apply(_contentBuffer3, (0, _toConsumableArray2.default)(sanitize(token.nodes, schema)));
            }
            index += token.length;
            state = processState.BUFFER;
            continue;
          }
          case processState.END: {
            if (!builder) {
              return fallback(input2, position);
            }
            if (buffer.length > 0) {
              var _contentBuffer4;
              var _content2 = (0, _text.parseString)({
                ignoreTokenTypes,
                schema,
                context,
                input: buffer.join(""),
                includeLeadingSpace: true
              });
              (_contentBuffer4 = contentBuffer).push.apply(_contentBuffer4, (0, _toConsumableArray2.default)(_content2));
            }
            builder.add([{
              style: lastListSymbols,
              content: sanitize((0, _normalize.normalizePMNodes)(contentBuffer, schema), schema)
            }]);
            output.push.apply(output, (0, _toConsumableArray2.default)(builder.buildPMNode()));
            return {
              type: "pmnode",
              nodes: output,
              length: index - position
            };
          }
        }
        index++;
      }
      if (buffer.length > 0) {
        var _contentBuffer5;
        var _content3 = (0, _text.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: buffer.join(""),
          includeLeadingSpace: true
        });
        (_contentBuffer5 = contentBuffer).push.apply(_contentBuffer5, (0, _toConsumableArray2.default)(_content3));
      }
      if (builder) {
        builder.add([{
          style: lastListSymbols,
          content: sanitize((0, _normalize.normalizePMNodes)(contentBuffer, schema), schema)
        }]);
        output.push.apply(output, (0, _toConsumableArray2.default)(builder.buildPMNode()));
      }
      return {
        type: "pmnode",
        nodes: output,
        length: index - position
      };
    };
    exports.list = list;
    function sanitize(nodes, schema) {
      return nodes.reduce(function(result, curr) {
        switch (curr.type.name) {
          case "blockquote": {
            curr.content.forEach(function(n) {
              result.push(n);
            });
            break;
          }
          case "heading": {
            var contentBuffer = [];
            curr.content.forEach(function(n) {
              var mark = schema.marks.strong.create();
              if (n.type.name === "text") {
                if (n.text) {
                  n.text = n.text.toUpperCase();
                }
                if (n.type.name === "text" && !(0, _text2.hasAnyOfMarks)(n, ["strong", "code"])) {
                  contentBuffer.push(n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark])));
                } else {
                  contentBuffer.push(n);
                }
              } else {
                contentBuffer.push(n);
              }
            });
            var p = schema.nodes.paragraph.createChecked({}, contentBuffer);
            result.push(p);
            break;
          }
          default:
            result.push(curr);
        }
        return result;
      }, []);
    }
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/monospace.js
var require_monospace = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/monospace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.monospace = void 0;
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var monospace = function monospace2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.ADF_MACRO, _.TokenType.ANCHOR_MACRO, _.TokenType.CODE_MACRO, _.TokenType.QUOTE_MACRO, _.TokenType.NOFORMAT_MACRO, _.TokenType.PANEL_MACRO, _.TokenType.COLOR_MACRO, _.TokenType.LOREM_MACRO, _.TokenType.QUOTE, _.TokenType.STRING, _.TokenType.ISSUE_KEY, _.TokenType.LINK_FORMAT, _.TokenType.LINK_TEXT, _.TokenType.MEDIA, _.TokenType.HEADING, _.TokenType.LIST, _.TokenType.TABLE, _.TokenType.RULER, _.TokenType.HARD_BREAK, _.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.STRONG, _.TokenType.MONOSPACE, _.TokenType.SUPERSCRIPT, _.TokenType.SUBSCRIPT, _.TokenType.EMPHASIS, _.TokenType.CITATION, _.TokenType.DELETED, _.TokenType.INSERTED, _.TokenType.EMOJI, _.TokenType.FORCE_LINE_BREAK];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.code.create();
        if (n.type.name === "text" && n.marks.length) {
          return n;
        }
        return n.mark([mark]);
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          ignoreTokenTypes,
          schema,
          context,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "{{", "}}"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.monospace = monospace;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/quadruple-dash-symbol.js
var require_quadruple_dash_symbol = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/quadruple-dash-symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.quadrupleDashSymbol = void 0;
    var MULTI_DASH_REGEX = /^-{4,}(\s|$)/;
    var quadrupleDashSymbol = function quadrupleDashSymbol2(_ref) {
      var input2 = _ref.input, position = _ref.position;
      var match = input2.substring(position).match(MULTI_DASH_REGEX);
      if (!match) {
        return {
          type: "text",
          text: "----",
          length: 4
        };
      }
      return {
        type: "text",
        text: input2.substr(position, match[0].length),
        length: match[0].length
      };
    };
    exports.quadrupleDashSymbol = quadrupleDashSymbol;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/rule.js
var require_rule2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/nodes/rule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createRuleNode = createRuleNode;
    exports.default = getRuleNodeView;
    var HORIZONTAL_LINE_INSIDE_MACRO = "---";
    function getRuleNodeView(schema, containerNodeType) {
      var _schema$nodes = schema.nodes, paragraph = _schema$nodes.paragraph, rule = _schema$nodes.rule;
      if (containerNodeType) {
        var textNode = schema.text(HORIZONTAL_LINE_INSIDE_MACRO);
        return paragraph.createChecked({}, textNode);
      } else {
        return rule.createChecked();
      }
    }
    function createRuleNode(schema) {
      var rule = schema.nodes.rule;
      var ruleNode = rule.createChecked();
      return [ruleNode];
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/ruler.js
var require_ruler3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/ruler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ruler = void 0;
    var _rule = require_rule2();
    var RULER_REGEX = /^-{4,5}(\s|$)/;
    var ruler = function ruler2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema;
      var match = input2.substring(position).match(RULER_REGEX);
      if (match) {
        return {
          type: "pmnode",
          nodes: (0, _rule.createRuleNode)(schema),
          length: match[0].length
        };
      }
      return {
        type: "text",
        text: input2.substring(position, 1),
        length: 1
      };
    };
    exports.ruler = ruler;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/strong.js
var require_strong2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/strong.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strong = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var strong = function strong2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(pmNode) {
        var mark = schema.marks.strong.create();
        if (pmNode.type.name === "text" && !(0, _text.hasAnyOfMarks)(pmNode, ["strong", "code"])) {
          return pmNode.mark([].concat((0, _toConsumableArray2.default)(pmNode.marks), [mark]));
        }
        return pmNode;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          schema,
          context,
          ignoreTokenTypes,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "*", "*"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.strong = strong;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/subscript.js
var require_subscript = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/subscript.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subscript = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var subscript = function subscript2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.subsup.create({
          type: "sub"
        });
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["subsup", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          schema,
          context,
          ignoreTokenTypes,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "~", "~"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.subscript = subscript;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/superscript.js
var require_superscript = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/superscript.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.superscript = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _text = require_text7();
    var _commonFormatter = require_common_formatter();
    var _text2 = require_text6();
    var superscript = function superscript2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var contentDecorator = function contentDecorator2(n) {
        var mark = schema.marks.subsup.create({
          type: "sup"
        });
        if (n.type.name === "text" && !(0, _text.hasAnyOfMarks)(n, ["subsup", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      };
      var rawContentProcessor = function rawContentProcessor2(raw, length) {
        var content = (0, _text2.parseString)({
          schema,
          context,
          ignoreTokenTypes,
          input: raw
        });
        var decoratedContent = content.map(contentDecorator);
        return {
          type: "pmnode",
          nodes: decoratedContent,
          length
        };
      };
      var _getSurroundingSymbol = (0, _text.getSurroundingSymbols)(input2.substring(position), "^", "^"), openingSymbol = _getSurroundingSymbol.openingSymbol, closingSymbol = _getSurroundingSymbol.closingSymbol;
      return (0, _commonFormatter.commonFormatter)(input2, position, schema, {
        opening: openingSymbol,
        closing: closingSymbol,
        context,
        rawContentProcessor
      });
    };
    exports.superscript = superscript;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/table.js
var require_table4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/table.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.table = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _prosemirrorModel = require_dist();
    var _tableBuilder = require_table_builder();
    var _text = require_text6();
    var _normalize = require_normalize3();
    var _linkFormat = require_link_format();
    var _media = require_media3();
    var _emoji = require_emoji4();
    var _ = require_tokenize();
    var _whitespace = require_whitespace();
    var _keyword = require_keyword();
    var _text2 = require_text7();
    var CELL_REGEXP = /^([ \t]*)([|]+)([ \t]*)/;
    var EMPTY_LINE_REGEXP = /^[ \t]*\r?\n/;
    var processState = {
      END_TABLE: 2,
      BUFFER: 4,
      CLOSE_ROW: 5,
      NEW_ROW: 6,
      LINE_BREAK: 7,
      LINK: 8,
      MEDIA: 9,
      MACRO: 10,
      EMOJI: 11
    };
    var table = function table2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.TABLE, _.TokenType.RULER];
      var output = [];
      var index = position;
      var currentState = processState.NEW_ROW;
      var buffer = [];
      var cellsBuffer = [];
      var cellStyle = "";
      var builder = null;
      while (index < input2.length) {
        var char = input2.charAt(index);
        var substring = input2.substring(index);
        switch (currentState) {
          case processState.NEW_ROW: {
            var tableMatch = substring.match(CELL_REGEXP);
            if (tableMatch) {
              if (!builder) {
                builder = new _tableBuilder.TableBuilder(schema);
              }
              index += tableMatch[1].length;
              cellStyle = tableMatch[2];
              index += tableMatch[2].length;
              currentState = processState.BUFFER;
              continue;
            }
            currentState = processState.END_TABLE;
            continue;
          }
          case processState.LINE_BREAK: {
            var emptyLineMatch = substring.match(EMPTY_LINE_REGEXP);
            if (emptyLineMatch) {
              bufferToCells(cellStyle, buffer.join(""), cellsBuffer, schema, ignoreTokenTypes, context);
              currentState = processState.END_TABLE;
              continue;
            }
            var cellMatch = substring.match(CELL_REGEXP);
            if (cellMatch) {
              currentState = processState.CLOSE_ROW;
            } else {
              currentState = processState.BUFFER;
            }
            continue;
          }
          case processState.BUFFER: {
            var length = (0, _whitespace.parseNewlineOnly)(substring);
            if (length) {
              var endIndex = index;
              var startIndex = input2.lastIndexOf("|", endIndex) + 1;
              var charsBefore = input2.substring(startIndex, endIndex);
              if (charsBefore === "" || charsBefore.match(EMPTY_LINE_REGEXP)) {
                currentState = processState.CLOSE_ROW;
              } else {
                currentState = processState.LINE_BREAK;
                buffer.push(input2.substr(index, length));
              }
              index += length;
              continue;
            }
            switch (char) {
              case "|": {
                bufferToCells(cellStyle, buffer.join(""), cellsBuffer, schema, ignoreTokenTypes, context);
                buffer = [];
                var _cellMatch = substring.match(CELL_REGEXP);
                if (_cellMatch) {
                  cellStyle = _cellMatch[2];
                  index += _cellMatch[2].length;
                  continue;
                }
                break;
              }
              case ":":
              case ";":
              case "(": {
                currentState = processState.EMOJI;
                continue;
              }
              case "[": {
                currentState = processState.LINK;
                continue;
              }
              case "!": {
                currentState = processState.MEDIA;
                continue;
              }
              case "{": {
                currentState = processState.MACRO;
                continue;
              }
              default: {
                buffer.push(char);
                index++;
                continue;
              }
            }
            break;
          }
          case processState.CLOSE_ROW: {
            var _bufferOutput = buffer.join("");
            if (_bufferOutput.trim().length > 0) {
              bufferToCells(cellStyle, _bufferOutput, cellsBuffer, schema, ignoreTokenTypes, context);
              buffer = [];
            }
            if (builder) {
              builder.add(cellsBuffer);
              cellsBuffer = [];
            }
            currentState = processState.NEW_ROW;
            continue;
          }
          case processState.END_TABLE: {
            if (builder) {
              if (cellsBuffer.length) {
                builder.add(cellsBuffer);
              }
              output.push(builder.buildPMNode());
            }
            return {
              type: "pmnode",
              nodes: output,
              length: index - position
            };
          }
          case processState.MEDIA: {
            var token = (0, _media.media)({
              input: input2,
              schema,
              context,
              position: index
            });
            buffer.push(input2.substr(index, token.length));
            index += token.length;
            currentState = processState.BUFFER;
            continue;
          }
          case processState.EMOJI: {
            var _token = (0, _emoji.emoji)({
              input: input2,
              schema,
              context,
              position: index
            });
            buffer.push(input2.substr(index, _token.length));
            index += _token.length;
            currentState = processState.BUFFER;
            continue;
          }
          case processState.LINK: {
            var _token2 = (0, _linkFormat.linkFormat)({
              input: input2,
              schema,
              context,
              position: index
            });
            if (_token2.type === "text") {
              buffer.push(_token2.text);
              index += _token2.length;
              currentState = processState.BUFFER;
              continue;
            } else if (_token2.type === "pmnode") {
              buffer.push(input2.substr(index, _token2.length));
              index += _token2.length;
              currentState = processState.BUFFER;
              continue;
            }
            break;
          }
          case processState.MACRO: {
            var match = (0, _keyword.parseMacroKeyword)(input2.substring(index));
            if (!match) {
              buffer.push(char);
              currentState = processState.BUFFER;
              break;
            }
            var _token3 = (0, _.parseToken)(input2, match.type, index, schema, context);
            buffer.push(input2.substr(index, _token3.length));
            index += _token3.length;
            currentState = processState.BUFFER;
            continue;
          }
        }
        index++;
      }
      var bufferOutput = buffer.join("");
      if (bufferOutput.trim().length > 0) {
        bufferToCells(cellStyle, bufferOutput, cellsBuffer, schema, ignoreTokenTypes, context);
      }
      if (builder) {
        if (cellsBuffer.length) {
          builder.add(cellsBuffer);
        }
        output.push(builder.buildPMNode());
      }
      return {
        type: "pmnode",
        nodes: output,
        length: index - position
      };
    };
    exports.table = table;
    function bufferToCells(style, buffer, cellsBuffer, schema, ignoreTokenTypes, context) {
      if (buffer.length) {
        var contentNode = (0, _text.parseString)({
          schema,
          context,
          ignoreTokenTypes,
          input: buffer
        });
        if (style === "||") {
          contentNode = contentNode.map(function(e) {
            return createTableHeader(e, schema);
          });
        }
        cellsBuffer.push({
          style,
          content: (0, _normalize.normalizePMNodes)(contentNode, schema)
        });
      }
    }
    function createTableHeader(pmNode, schema) {
      var mark = schema.marks.strong.create();
      if (pmNode.type.name === "text" && !(0, _text2.hasAnyOfMarks)(pmNode, ["strong", "code"])) {
        return pmNode.mark([].concat((0, _toConsumableArray2.default)(pmNode.marks), [mark]));
      } else if (pmNode.childCount > 0 && pmNode.firstChild && pmNode.child(0) && pmNode.type.name !== "codeBlock") {
        var jsonNode = traverseJsonNodeAndAddMarks(pmNode.toJSON(), "strong", schema);
        pmNode = _prosemirrorModel.Node.fromJSON(schema, jsonNode);
        return pmNode;
      }
      return pmNode;
    }
    function traverseJsonNodeAndAddMarks(node, mark, schema) {
      if (node.type === "text") {
        if (node.marks && node.marks.find(function(_ref2) {
          var type = _ref2.type;
          return type === "strong" || type === "code";
        })) {
          return node;
        }
        node.marks = node.marks ? [].concat((0, _toConsumableArray2.default)(node.marks), [{
          type: mark
        }]) : [{
          type: mark
        }];
      }
      if (node.content && Array.isArray(node.content)) {
        node.content.map(function(e) {
          return traverseJsonNodeAndAddMarks(e, mark, schema);
        });
      }
      return node;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/triple-dash-symbol.js
var require_triple_dash_symbol = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/triple-dash-symbol.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.tripleDashSymbol = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _dashTokenCreator = require_dash_token_creator();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var token = {
      type: "text",
      text: "\u2014",
      // EM DASH
      length: 3
    };
    var fallback = _objectSpread(_objectSpread({}, token), {}, {
      text: "---"
    });
    var tripleDashSymbol = (0, _dashTokenCreator.createDashTokenParser)(token, fallback);
    exports.tripleDashSymbol = tripleDashSymbol;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/color-name-mapping.js
var require_color_name_mapping = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/color-name-mapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mapping = {
      crimson: {
        r: 220,
        g: 20,
        b: 60
      },
      lightpink: {
        r: 255,
        g: 182,
        b: 193
      },
      pink: {
        r: 255,
        g: 192,
        b: 203
      },
      palevioletred: {
        r: 219,
        g: 112,
        b: 147
      },
      lavenderblush: {
        r: 255,
        g: 240,
        b: 245
      },
      hotpink: {
        r: 255,
        g: 105,
        b: 180
      },
      deeppink: {
        r: 255,
        g: 20,
        b: 147
      },
      mediumvioletred: {
        r: 199,
        g: 21,
        b: 133
      },
      orchid: {
        r: 218,
        g: 112,
        b: 214
      },
      thistle: {
        r: 216,
        g: 191,
        b: 216
      },
      plum: {
        r: 221,
        g: 160,
        b: 221
      },
      violet: {
        r: 238,
        g: 130,
        b: 238
      },
      fuchsia: {
        r: 255,
        g: 0,
        b: 255
      },
      darkmagenta: {
        r: 139,
        g: 0,
        b: 139
      },
      purple: {
        r: 128,
        g: 0,
        b: 128
      },
      mediumorchid: {
        r: 186,
        g: 85,
        b: 211
      },
      darkviolet: {
        r: 148,
        g: 0,
        b: 211
      },
      darkorchid: {
        r: 153,
        g: 50,
        b: 204
      },
      indigo: {
        r: 75,
        g: 0,
        b: 130
      },
      blueviolet: {
        r: 138,
        g: 43,
        b: 226
      },
      mediumpurple: {
        r: 147,
        g: 112,
        b: 219
      },
      darkslateblue: {
        r: 72,
        g: 61,
        b: 139
      },
      mediumslateblue: {
        r: 123,
        g: 104,
        b: 238
      },
      slateblue: {
        r: 106,
        g: 90,
        b: 205
      },
      ghostwhite: {
        r: 248,
        g: 248,
        b: 255
      },
      lavender: {
        r: 230,
        g: 230,
        b: 250
      },
      blue: {
        r: 0,
        g: 0,
        b: 255
      },
      mediumblue: {
        r: 0,
        g: 0,
        b: 205
      },
      darkblue: {
        r: 0,
        g: 0,
        b: 139
      },
      navy: {
        r: 0,
        g: 0,
        b: 128
      },
      midnightblue: {
        r: 25,
        g: 25,
        b: 112
      },
      royalblue: {
        r: 65,
        g: 105,
        b: 225
      },
      cornflowerblue: {
        r: 100,
        g: 149,
        b: 237
      },
      lightsteelblue: {
        r: 176,
        g: 196,
        b: 222
      },
      lightslategray: {
        r: 119,
        g: 136,
        b: 153
      },
      slategray: {
        r: 112,
        g: 128,
        b: 144
      },
      dodgerblue: {
        r: 30,
        g: 144,
        b: 255
      },
      aliceblue: {
        r: 240,
        g: 248,
        b: 255
      },
      steelblue: {
        r: 70,
        g: 130,
        b: 180
      },
      lightskyblue: {
        r: 135,
        g: 206,
        b: 250
      },
      skyblue: {
        r: 135,
        g: 206,
        b: 235
      },
      deepskyblue: {
        r: 0,
        g: 191,
        b: 255
      },
      lightblue: {
        r: 173,
        g: 216,
        b: 230
      },
      powderblue: {
        r: 176,
        g: 224,
        b: 230
      },
      cadetblue: {
        r: 95,
        g: 158,
        b: 160
      },
      darkturquoise: {
        r: 0,
        g: 206,
        b: 209
      },
      azure: {
        r: 240,
        g: 255,
        b: 255
      },
      lightcyan: {
        r: 224,
        g: 255,
        b: 255
      },
      paleturquoise: {
        r: 174,
        g: 238,
        b: 238
      },
      darkslategray: {
        r: 47,
        g: 79,
        b: 79
      },
      aqua: {
        r: 0,
        g: 255,
        b: 255
      },
      darkcyan: {
        r: 0,
        g: 139,
        b: 139
      },
      teal: {
        r: 0,
        g: 128,
        b: 128
      },
      mediumturquoise: {
        r: 72,
        g: 209,
        b: 204
      },
      lightseagreen: {
        r: 32,
        g: 178,
        b: 170
      },
      turquoise: {
        r: 64,
        g: 224,
        b: 208
      },
      aquamarine: {
        r: 127,
        g: 255,
        b: 212
      },
      mediumaquamarine: {
        r: 102,
        g: 205,
        b: 170
      },
      mediumspringgreen: {
        r: 0,
        g: 250,
        b: 154
      },
      mintcream: {
        r: 245,
        g: 255,
        b: 250
      },
      springgreen: {
        r: 0,
        g: 255,
        b: 127
      },
      mediumseagreen: {
        r: 60,
        g: 179,
        b: 113
      },
      seagreen: {
        r: 46,
        g: 139,
        b: 87
      },
      honeydew: {
        r: 240,
        g: 255,
        b: 240
      },
      darkseagreen: {
        r: 143,
        g: 188,
        b: 143
      },
      palegreen: {
        r: 152,
        g: 251,
        b: 152
      },
      lightgreen: {
        r: 144,
        g: 238,
        b: 144
      },
      limegreen: {
        r: 50,
        g: 205,
        b: 50
      },
      forestgreen: {
        r: 34,
        g: 139,
        b: 34
      },
      lime: {
        r: 0,
        g: 255,
        b: 0
      },
      green: {
        r: 0,
        g: 128,
        b: 0
      },
      darkgreen: {
        r: 0,
        g: 100,
        b: 0
      },
      lawngreen: {
        r: 124,
        g: 252,
        b: 0
      },
      chartreuse: {
        r: 127,
        g: 255,
        b: 0
      },
      greenyellow: {
        r: 173,
        g: 255,
        b: 47
      },
      darkolivegreen: {
        r: 85,
        g: 107,
        b: 47
      },
      olivedrab: {
        r: 107,
        g: 142,
        b: 35
      },
      yellowgreen: {
        r: 154,
        g: 205,
        b: 50
      },
      ivory: {
        r: 255,
        g: 255,
        b: 240
      },
      beige: {
        r: 245,
        g: 245,
        b: 220
      },
      lightyellow: {
        r: 255,
        g: 255,
        b: 224
      },
      lightgoldenrodyellow: {
        r: 250,
        g: 250,
        b: 210
      },
      yellow: {
        r: 255,
        g: 255,
        b: 0
      },
      olive: {
        r: 128,
        g: 128,
        b: 0
      },
      darkkhaki: {
        r: 189,
        g: 183,
        b: 107
      },
      khaki: {
        r: 240,
        g: 230,
        b: 140
      },
      palegoldenrod: {
        r: 238,
        g: 232,
        b: 170
      },
      lemonchiffon: {
        r: 255,
        g: 250,
        b: 205
      },
      gold: {
        r: 255,
        g: 215,
        b: 0
      },
      cornsilk: {
        r: 255,
        g: 248,
        b: 220
      },
      goldenrod: {
        r: 218,
        g: 165,
        b: 32
      },
      darkgoldenrod: {
        r: 184,
        g: 134,
        b: 11
      },
      orange: {
        r: 255,
        g: 128,
        b: 0
      },
      floralwhite: {
        r: 255,
        g: 250,
        b: 240
      },
      oldlace: {
        r: 253,
        g: 245,
        b: 230
      },
      wheat: {
        r: 245,
        g: 222,
        b: 179
      },
      moccasin: {
        r: 255,
        g: 228,
        b: 181
      },
      papayawhip: {
        r: 255,
        g: 239,
        b: 213
      },
      blanchedalmond: {
        r: 255,
        g: 235,
        b: 205
      },
      navajowhite: {
        r: 255,
        g: 222,
        b: 173
      },
      tan: {
        r: 210,
        g: 180,
        b: 140
      },
      antiquewhite: {
        r: 250,
        g: 235,
        b: 215
      },
      burlywood: {
        r: 222,
        g: 184,
        b: 135
      },
      bisque: {
        r: 255,
        g: 228,
        b: 196
      },
      darkorange: {
        r: 255,
        g: 140,
        b: 0
      },
      peru: {
        r: 205,
        g: 133,
        b: 63
      },
      linen: {
        r: 250,
        g: 240,
        b: 230
      },
      peachpuff: {
        r: 255,
        g: 218,
        b: 185
      },
      seashell: {
        r: 255,
        g: 245,
        b: 238
      },
      sandybrown: {
        r: 244,
        g: 164,
        b: 96
      },
      chocolate: {
        r: 210,
        g: 105,
        b: 30
      },
      saddlebrown: {
        r: 139,
        g: 69,
        b: 19
      },
      sienna: {
        r: 160,
        g: 82,
        b: 45
      },
      lightsalmon: {
        r: 255,
        g: 160,
        b: 122
      },
      coral: {
        r: 255,
        g: 127,
        b: 80
      },
      orangered: {
        r: 255,
        g: 69,
        b: 0
      },
      darksalmon: {
        r: 233,
        g: 150,
        b: 122
      },
      tomato: {
        r: 255,
        g: 99,
        b: 71
      },
      salmon: {
        r: 250,
        g: 128,
        b: 114
      },
      mistyrose: {
        r: 255,
        g: 228,
        b: 225
      },
      snow: {
        r: 255,
        g: 250,
        b: 250
      },
      rosybrown: {
        r: 188,
        g: 143,
        b: 143
      },
      lightcoral: {
        r: 240,
        g: 128,
        b: 128
      },
      indianred: {
        r: 205,
        g: 92,
        b: 92
      },
      brown: {
        r: 165,
        g: 42,
        b: 42
      },
      firebrick: {
        r: 178,
        g: 34,
        b: 34
      },
      red: {
        r: 255,
        g: 0,
        b: 0
      },
      darkred: {
        r: 139,
        g: 0,
        b: 0
      },
      maroon: {
        r: 128,
        g: 0,
        b: 0
      },
      white: {
        r: 255,
        g: 255,
        b: 255
      },
      gainsboro: {
        r: 220,
        g: 220,
        b: 220
      },
      lightgray: {
        r: 211,
        g: 211,
        b: 211
      },
      silver: {
        r: 192,
        g: 192,
        b: 192
      },
      darkgray: {
        r: 169,
        g: 169,
        b: 169
      },
      gray: {
        r: 128,
        g: 128,
        b: 128
      },
      dimgray: {
        r: 105,
        g: 105,
        b: 105
      },
      black: {
        r: 0,
        g: 0,
        b: 0
      },
      whitesmoke: {
        r: 245,
        g: 245,
        b: 245
      }
    };
    var _default = mapping;
    exports.default = _default;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/panel-type.js
var require_panel_type = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/panel-type.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPanelType = getPanelType;
    var _colorNameMapping = _interopRequireDefault(require_color_name_mapping());
    var COLOR_TYPE_REGEX = {
      hexShort: /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
      hexLong: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
      rgb: /^#?rgb\((\d+),\s*(\d+),\s*(\d+)\)$/,
      prgb: /^#?rgb\((\d+)%,\s*(\d+)%,\s*(\d+)%\)$/
    };
    var PANEL_TYPE_TO_RGB = {
      info: {
        r: 222,
        g: 235,
        b: 255
      },
      note: {
        r: 234,
        g: 230,
        b: 255
      },
      success: {
        r: 227,
        g: 252,
        b: 239
      },
      warning: {
        r: 255,
        g: 250,
        b: 230
      },
      error: {
        r: 255,
        g: 235,
        b: 230
      }
    };
    function getPanelType(attrs) {
      var rgb = generateRgb(attrs.bgColor);
      if (!rgb) {
        return "info";
      }
      var mapTo = "info";
      var smallestDistance = Infinity;
      Object.keys(PANEL_TYPE_TO_RGB).forEach(function(panelType) {
        var distance = distanceOfRgb(PANEL_TYPE_TO_RGB[panelType], rgb);
        if (distance < smallestDistance) {
          smallestDistance = distance;
          mapTo = panelType;
        }
      });
      return mapTo;
    }
    function distanceOfRgb(a, b) {
      return Math.pow(a.r - b.r, 2) + Math.pow(a.g - b.g, 2) + Math.pow(a.b - b.b, 2);
    }
    function generateRgb(color) {
      switch (true) {
        case (COLOR_TYPE_REGEX.hexShort.test(color) || COLOR_TYPE_REGEX.hexLong.test(color)):
          return parseHex(color);
        case COLOR_TYPE_REGEX.rgb.test(color):
          return parseRgb(color);
        case COLOR_TYPE_REGEX.prgb.test(color):
          return parsePrgb(color);
        default:
          return parseColorName(color);
      }
    }
    function parseHex(hex) {
      hex = hex.replace(COLOR_TYPE_REGEX.hexShort, function(_m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = COLOR_TYPE_REGEX.hexLong.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    function parseRgb(rgb) {
      var result = rgb.match(COLOR_TYPE_REGEX.rgb);
      return result ? {
        r: parseInt(result[1], 10),
        g: parseInt(result[2], 10),
        b: parseInt(result[3], 10)
      } : null;
    }
    function parsePrgb(prgb) {
      var result = prgb.match(COLOR_TYPE_REGEX.prgb);
      return result ? {
        r: Math.floor(255 * parseInt(result[1], 10) / 100),
        g: Math.floor(255 * parseInt(result[2], 10) / 100),
        b: Math.floor(255 * parseInt(result[4], 10) / 100)
      } : null;
    }
    function parseColorName(color) {
      return _colorNameMapping.default[color];
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/title.js
var require_title = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/utils/title.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.title = title;
    function title(text, schema) {
      var mark = schema.marks.strong.create();
      var title2 = schema.text(text, [mark]);
      return schema.nodes.paragraph.createChecked({}, [title2]);
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/panel-macro.js
var require_panel_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/panel-macro.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.panelMacro = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _commonMacro = require_common_macro();
    var _text = require_text6();
    var _attrs = require_attrs();
    var _normalize = require_normalize3();
    var _panelType = require_panel_type();
    var _title = require_title();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var allowedNodeType = ["paragraph", "heading", "orderedList", "bulletList"];
    var panelMacro = function panelMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "panel",
        paired: true,
        context,
        rawContentProcessor
      });
    };
    exports.panelMacro = panelMacro;
    var rawContentProcessor = function rawContentProcessor2(rawAttrs, rawContent, length, schema, context) {
      var output = [];
      var parsedAttrs = (0, _attrs.parseAttrs)(rawAttrs);
      var nodeAttrs = _objectSpread(_objectSpread({}, parsedAttrs), {}, {
        panelType: (0, _panelType.getPanelType)(parsedAttrs)
      });
      var parsedContent = (0, _text.parseString)({
        schema,
        context,
        ignoreTokenTypes: [],
        input: rawContent
      });
      var normalizedContent = (0, _normalize.normalizePMNodes)(parsedContent, schema);
      var contentBuffer = parsedAttrs.title ? [(0, _title.title)(parsedAttrs.title, schema)] : [];
      var _iterator = _createForOfIteratorHelper(normalizedContent), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var n = _step.value;
          if (allowedNodeType.indexOf(n.type.name) !== -1) {
            contentBuffer.push(n);
          } else {
            var _panelNode = schema.nodes.panel.createChecked(nodeAttrs, contentBuffer.length ? contentBuffer : schema.nodes.paragraph.createChecked());
            contentBuffer = [];
            output.push(_panelNode);
            output.push(n);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (contentBuffer.length > 0) {
        var panelNode = schema.nodes.panel.createChecked(nodeAttrs, contentBuffer);
        output.push(panelNode);
      }
      return {
        type: "pmnode",
        nodes: output.length ? output : [emptyPanel(schema)],
        length
      };
    };
    function emptyPanel(schema) {
      var p = schema.nodes.paragraph.createChecked();
      return schema.nodes.panel.createChecked({}, p);
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/adf-macro.js
var require_adf_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/adf-macro.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.adfMacro = void 0;
    var _commonMacro = require_common_macro();
    var adfMacro = function adfMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "adf",
        paired: true,
        context,
        rawContentProcessor
      });
    };
    exports.adfMacro = adfMacro;
    var rawContentProcessor = function rawContentProcessor2(_rawAttrs, rawContent, length, schema, _context) {
      try {
        var json = JSON.parse(rawContent);
        var node = schema.nodeFromJSON(json);
        return {
          type: "pmnode",
          nodes: [node],
          length
        };
      } catch (_e) {
        var textContent = "Invalid ADF Macro: ".concat(rawContent);
        var textNode = rawContent.length ? schema.text(textContent) : void 0;
        var codeBlock = schema.nodes.codeBlock;
        var _node = codeBlock.create({
          language: void 0
        }, textNode);
        return {
          type: "pmnode",
          nodes: [_node],
          length
        };
      }
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/anchor-macro.js
var require_anchor_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/anchor-macro.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anchorMacro = void 0;
    var _commonMacro = require_common_macro();
    var anchorMacro = function anchorMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "anchor",
        paired: false,
        context,
        rawContentProcessor
      });
    };
    exports.anchorMacro = anchorMacro;
    var rawContentProcessor = function rawContentProcessor2(_rawAttrs, _rawContent, length, _schema, _context) {
      return {
        type: "text",
        text: "",
        length
      };
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/code-macro.js
var require_code_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/code-macro.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeMacro = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _commonMacro = require_common_macro();
    var _attrs = require_attrs();
    var _title = require_title();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var SUPPORTED_CODEBOCK_LANGUAGES = ["abap", "actionscript", "ada", "arduino", "autoit", "c", "c++", "clojure", "coffeescript", "csharp", "css", "cuda", "d", "dart", "delphi", "elixir", "erlang", "fortran", "foxpro", "go", "groovy", "haskell", "haxe", "html", "java", "javascript", "json", "julia", "kotlin", "latex", "livescript", "lua", "mathematica", "matlab", "objective-c", "objective-j", "objectpascal", "ocaml", "octave", "perl", "php", "powershell", "prolog", "puppet", "python", "qml", "r", "racket", "restructuredtext", "ruby", "rust", "sass", "scala", "scheme", "shell", "smalltalk", "sql", "standardml", "swift", "tcl", "tex", "typescript", "vala", "vbnet", "verilog", "vhdl", "xml", "xquery"];
    var codeMacro = function codeMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "code",
        paired: true,
        context,
        rawContentProcessor
      });
    };
    exports.codeMacro = codeMacro;
    var rawContentProcessor = function rawContentProcessor2(rawAttrs, rawContent, length, schema) {
      var output = [];
      var codeBlock = schema.nodes.codeBlock;
      var parsedAttrs = (0, _attrs.parseAttrs)(rawAttrs);
      var trimedContent = rawContent.replace(/^\s+|\s+$/g, "");
      var textNode = trimedContent.length ? schema.text(trimedContent) : void 0;
      if (parsedAttrs.title) {
        output.push((0, _title.title)(parsedAttrs.title, schema));
      }
      var nodeAttrs = _objectSpread(_objectSpread({}, parsedAttrs), {}, {
        language: getCodeLanguage(parsedAttrs)
      });
      output.push(codeBlock.createChecked(nodeAttrs, textNode));
      return {
        type: "pmnode",
        nodes: output,
        length
      };
    };
    function getCodeLanguage(attrs) {
      var keys = Object.keys(attrs).map(function(key) {
        return key.toLowerCase();
      });
      for (var _i = 0, _SUPPORTED_CODEBOCK_L = SUPPORTED_CODEBOCK_LANGUAGES; _i < _SUPPORTED_CODEBOCK_L.length; _i++) {
        var language = _SUPPORTED_CODEBOCK_L[_i];
        if (keys.indexOf(language) !== -1) {
          return language;
        }
      }
      if (keys.indexOf("objc") !== -1) {
        return "objective-c";
      }
      return "java";
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/color.js
var require_color = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getEditorColor = getEditorColor;
    var _adfSchema = require_cjs6();
    function getEditorColor(attrs) {
      var keys = Object.keys(attrs);
      return (0, _adfSchema.normalizeHexColor)(keys[0]);
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/color-macro.js
var require_color_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/color-macro.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.colorMacro = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _ = require_tokenize();
    var _commonMacro = require_common_macro();
    var _attrs = require_attrs();
    var _text = require_text6();
    var _color = require_color();
    var _text2 = require_text7();
    var colorMacro = function colorMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "color",
        paired: true,
        context,
        rawContentProcessor
      });
    };
    exports.colorMacro = colorMacro;
    var rawContentProcessor = function rawContentProcessor2(rawAttrs, rawContent, length, schema, context) {
      var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.ISSUE_KEY, _.TokenType.TABLE];
      var parsedAttrs = (0, _attrs.parseAttrs)(rawAttrs);
      var content = (0, _text.parseString)({
        ignoreTokenTypes,
        schema,
        context,
        input: rawContent
      });
      var decoratedContent = content.map(function(n) {
        var mark = schema.marks.textColor.create({
          color: (0, _color.getEditorColor)(parsedAttrs) || "#000000"
        });
        if (n.type.name === "text" && !(0, _text2.hasAnyOfMarks)(n, ["textColor", "code"])) {
          return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
        }
        return n;
      });
      return {
        type: "pmnode",
        nodes: decoratedContent,
        length
      };
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/noformat-macro.js
var require_noformat_macro = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/noformat-macro.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.noformatMacro = void 0;
    var _commonMacro = require_common_macro();
    var _attrs = require_attrs();
    var _title = require_title();
    var noformatMacro = function noformatMacro2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema, context = _ref.context;
      return (0, _commonMacro.commonMacro)(input2.substring(position), schema, {
        keyword: "noformat",
        paired: true,
        context,
        rawContentProcessor
      });
    };
    exports.noformatMacro = noformatMacro;
    var rawContentProcessor = function rawContentProcessor2(rawAttrs, rawContent, length, schema, _context) {
      var output = [];
      var codeBlock = schema.nodes.codeBlock;
      var parsedAttrs = (0, _attrs.parseAttrs)(rawAttrs);
      var trimedContent = rawContent.replace(/^\s+|\s+$/g, "");
      var textNode = trimedContent.length ? schema.text(trimedContent) : void 0;
      if (parsedAttrs.title) {
        output.push((0, _title.title)(parsedAttrs.title, schema));
      }
      output.push(codeBlock.createChecked({}, textNode));
      return {
        type: "pmnode",
        nodes: output,
        length
      };
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/force-line-break.js
var require_force_line_break = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/force-line-break.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forceLineBreak = void 0;
    var FORCE_LINE_BREAK_REGEX = /^\\{2}(?!\S*\\)/;
    var forceLineBreak = function forceLineBreak2(_ref) {
      var input2 = _ref.input, position = _ref.position, schema = _ref.schema;
      if (position > 0) {
        var charBefore = input2.charAt(position - 1);
        if (charBefore === "\\") {
          return fallback(input2, position);
        }
      }
      var match = input2.substring(position).match(FORCE_LINE_BREAK_REGEX);
      if (match) {
        return {
          type: "pmnode",
          nodes: [schema.nodes.hardBreak.createChecked()],
          length: 2
        };
      }
      return fallback(input2, position);
    };
    exports.forceLineBreak = forceLineBreak;
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 2),
        length: 2
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/index.js
var require_tokenize = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TokenType = void 0;
    exports.parseToken = parseToken;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _media = require_media3();
    var _blockquote = require_blockquote5();
    var _citation = require_citation();
    var _deleted = require_deleted();
    var _doubleDashSymbol = require_double_dash_symbol();
    var _emoji = require_emoji4();
    var _emphasis = require_emphasis3();
    var _hardbreak = require_hardbreak();
    var _heading = require_heading4();
    var _inserted = require_inserted();
    var _linkFormat = require_link_format();
    var _linkText = require_link_text();
    var _list = require_list3();
    var _monospace = require_monospace();
    var _quadrupleDashSymbol = require_quadruple_dash_symbol();
    var _ruler = require_ruler3();
    var _strong = require_strong2();
    var _subscript = require_subscript();
    var _superscript = require_superscript();
    var _table = require_table4();
    var _tripleDashSymbol = require_triple_dash_symbol();
    var _panelMacro = require_panel_macro();
    var _adfMacro = require_adf_macro();
    var _anchorMacro = require_anchor_macro();
    var _codeMacro = require_code_macro();
    var _quoteMacro = require_quote_macro();
    var _colorMacro = require_color_macro();
    var _noformatMacro = require_noformat_macro();
    var _forceLineBreak = require_force_line_break();
    var _issueKey = require_issue_key();
    var _tokenToTokenParserMa;
    var TokenType;
    exports.TokenType = TokenType;
    (function(TokenType2) {
      TokenType2["ADF_MACRO"] = "ADF_MACRO";
      TokenType2["ANCHOR_MACRO"] = "ANCHOR_MACRO";
      TokenType2["CODE_MACRO"] = "CODE_MACRO";
      TokenType2["QUOTE_MACRO"] = "QUOTE_MACRO";
      TokenType2["NOFORMAT_MACRO"] = "NOFORMAT_MACRO";
      TokenType2["PANEL_MACRO"] = "PANEL_MACRO";
      TokenType2["COLOR_MACRO"] = "COLOR_MACRO";
      TokenType2["LOREM_MACRO"] = "LOREM_MACRO";
      TokenType2["QUOTE"] = "QUOTE";
      TokenType2["STRING"] = "STRING";
      TokenType2["ISSUE_KEY"] = "ISSUE_KEY";
      TokenType2["LINK_FORMAT"] = "LINK_FORMAT";
      TokenType2["LINK_TEXT"] = "LINK_TEXT";
      TokenType2["MEDIA"] = "MEDIA";
      TokenType2["HEADING"] = "HEADING";
      TokenType2["LIST"] = "LIST";
      TokenType2["TABLE"] = "TABLE";
      TokenType2["RULER"] = "RULER";
      TokenType2["HARD_BREAK"] = "HARD_BREAK";
      TokenType2["DOUBLE_DASH_SYMBOL"] = "DOUBLE_DASH_SYMBOL";
      TokenType2["TRIPLE_DASH_SYMBOL"] = "TRIPLE_DASH_SYMBOL";
      TokenType2["QUADRUPLE_DASH_SYMBOL"] = "QUADRUPLE_DASH_SYMBOL";
      TokenType2["STRONG"] = "STRONG";
      TokenType2["MONOSPACE"] = "MONOSPACE";
      TokenType2["SUPERSCRIPT"] = "SUPERSCRIPT";
      TokenType2["SUBSCRIPT"] = "SUBSCRIPT";
      TokenType2["EMPHASIS"] = "EMPHASIS";
      TokenType2["CITATION"] = "CITATION";
      TokenType2["DELETED"] = "DELETED";
      TokenType2["INSERTED"] = "INSERTED";
      TokenType2["EMOJI"] = "EMOJI";
      TokenType2["FORCE_LINE_BREAK"] = "FORCE_LINE_BREAK";
    })(TokenType || (exports.TokenType = TokenType = {}));
    var tokenToTokenParserMapping = (_tokenToTokenParserMa = {}, (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.DOUBLE_DASH_SYMBOL, _doubleDashSymbol.doubleDashSymbol), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.TRIPLE_DASH_SYMBOL, _tripleDashSymbol.tripleDashSymbol), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.QUADRUPLE_DASH_SYMBOL, _quadrupleDashSymbol.quadrupleDashSymbol), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.RULER, _ruler.ruler), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.STRONG, _strong.strong), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.MONOSPACE, _monospace.monospace), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.SUPERSCRIPT, _superscript.superscript), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.SUBSCRIPT, _subscript.subscript), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.EMPHASIS, _emphasis.emphasis), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.CITATION, _citation.citation), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.DELETED, _deleted.deleted), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.INSERTED, _inserted.inserted), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.HARD_BREAK, _hardbreak.hardbreak), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.LINK_FORMAT, _linkFormat.linkFormat), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.LINK_TEXT, _linkText.linkText), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.HEADING, _heading.heading), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.MEDIA, _media.media), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.LIST, _list.list), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.QUOTE, _blockquote.blockquote), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.TABLE, _table.table), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.EMOJI, _emoji.emoji), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.ADF_MACRO, _adfMacro.adfMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.ANCHOR_MACRO, _anchorMacro.anchorMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.CODE_MACRO, _codeMacro.codeMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.QUOTE_MACRO, _quoteMacro.quoteMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.NOFORMAT_MACRO, _noformatMacro.noformatMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.PANEL_MACRO, _panelMacro.panelMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.COLOR_MACRO, _colorMacro.colorMacro), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.FORCE_LINE_BREAK, _forceLineBreak.forceLineBreak), (0, _defineProperty2.default)(_tokenToTokenParserMa, TokenType.ISSUE_KEY, _issueKey.issueKey), _tokenToTokenParserMa);
    function parseToken(input2, type, position, schema, context) {
      var tokenParser = tokenToTokenParserMapping[type];
      if (tokenParser) {
        try {
          return tokenParser({
            input: input2,
            position,
            schema,
            context
          });
        } catch (err) {
          if (context.tokenErrCallback && err instanceof Error) {
            context.tokenErrCallback(err, type);
          }
          return fallback(input2, position);
        }
      }
      return fallback(input2, position);
    }
    function fallback(input2, position) {
      return {
        type: "text",
        text: input2.substr(position, 1),
        length: 1
      };
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/keyword.js
var require_keyword = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/tokenize/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.macroKeywordTokenMap = void 0;
    exports.parseIssueKeyword = parseIssueKeyword;
    exports.parseLeadingKeyword = parseLeadingKeyword;
    exports.parseMacroKeyword = parseMacroKeyword;
    exports.parseOtherKeyword = parseOtherKeyword;
    var _ = require_tokenize();
    var _list = require_list3();
    var macroKeywordTokenMap = [{
      type: _.TokenType.ADF_MACRO,
      regex: /^{adf/i
    }, {
      type: _.TokenType.ANCHOR_MACRO,
      regex: /^{anchor/i
    }, {
      type: _.TokenType.CODE_MACRO,
      regex: /^{code/i
    }, {
      type: _.TokenType.QUOTE_MACRO,
      regex: /^{quote/i
    }, {
      type: _.TokenType.NOFORMAT_MACRO,
      regex: /^{noformat/i
    }, {
      type: _.TokenType.PANEL_MACRO,
      regex: /^{panel/i
    }, {
      type: _.TokenType.COLOR_MACRO,
      regex: /^{color/
    }, {
      type: _.TokenType.LOREM_MACRO,
      regex: /^{loremipsum/i
    }];
    exports.macroKeywordTokenMap = macroKeywordTokenMap;
    var keywordTokenMap = {
      "[": _.TokenType.LINK_FORMAT,
      http: _.TokenType.LINK_TEXT,
      ftp: _.TokenType.LINK_TEXT,
      jamfselfservice: _.TokenType.LINK_TEXT,
      irc: _.TokenType.LINK_TEXT,
      mailto: _.TokenType.LINK_TEXT,
      "\\\\": _.TokenType.FORCE_LINE_BREAK,
      "\r": _.TokenType.HARD_BREAK,
      "\n": _.TokenType.HARD_BREAK,
      "\r\n": _.TokenType.HARD_BREAK,
      "!": _.TokenType.MEDIA,
      "----": _.TokenType.QUADRUPLE_DASH_SYMBOL,
      "---": _.TokenType.TRIPLE_DASH_SYMBOL,
      "--": _.TokenType.DOUBLE_DASH_SYMBOL,
      "{-}": _.TokenType.DELETED,
      "{+}": _.TokenType.INSERTED,
      "{*}": _.TokenType.STRONG,
      "{^}": _.TokenType.SUPERSCRIPT,
      "{~}": _.TokenType.SUBSCRIPT,
      "{_}": _.TokenType.EMPHASIS,
      "{{{}": _.TokenType.MONOSPACE,
      "{??}": _.TokenType.CITATION,
      "-": _.TokenType.DELETED,
      "+": _.TokenType.INSERTED,
      "*": _.TokenType.STRONG,
      "^": _.TokenType.SUPERSCRIPT,
      "~": _.TokenType.SUBSCRIPT,
      _: _.TokenType.EMPHASIS,
      "{{": _.TokenType.MONOSPACE,
      "??": _.TokenType.CITATION
    };
    var keywordTokenMapKeys = Object.keys(keywordTokenMap);
    function parseMacroKeyword(input2) {
      for (var i = 0; i < macroKeywordTokenMap.length; i++) {
        var keyword = macroKeywordTokenMap[i];
        if (keyword.regex.test(input2)) {
          return {
            type: keyword.type
          };
        }
      }
      return null;
    }
    function parseOtherKeyword(input2) {
      for (var i = 0; i < keywordTokenMapKeys.length; i++) {
        if (input2.startsWith(keywordTokenMapKeys[i])) {
          return {
            type: keywordTokenMap[keywordTokenMapKeys[i]]
          };
        }
      }
      var char = input2.charAt(0);
      if ([":", "(", ";"].indexOf(char) !== -1) {
        return {
          // This potentially can be a emoji. The emoji parser will fail out if it's not
          type: _.TokenType.EMOJI
        };
      }
      return null;
    }
    var leadingKeywordTokenMap = [{
      type: _.TokenType.QUOTE,
      regex: /^bq\./
    }, {
      type: _.TokenType.HEADING,
      regex: /^h[1-6]\./
    }, {
      type: _.TokenType.RULER,
      regex: /^-{4,5}(\s|$)/
    }, {
      type: _.TokenType.TRIPLE_DASH_SYMBOL,
      regex: /^-{3}\s/
    }, {
      type: _.TokenType.DOUBLE_DASH_SYMBOL,
      regex: /^-{2}\s/
    }, {
      // Lists are limited to max 20 levels of depth
      type: _.TokenType.LIST,
      regex: new RegExp("^([*#]{1,".concat(_list.MAX_LIST_DEPTH, "}|-) "))
    }, {
      type: _.TokenType.TABLE,
      regex: /^\|{1,2}/
    }];
    function parseLeadingKeyword(input2) {
      for (var i = 0; i < leadingKeywordTokenMap.length; i++) {
        var keyword = leadingKeywordTokenMap[i];
        if (keyword.regex.test(input2)) {
          return {
            type: keyword.type
          };
        }
      }
      return null;
    }
    function parseIssueKeyword(input2, issueKeyRegex) {
      if (issueKeyRegex && issueKeyRegex.test(input2)) {
        return {
          type: _.TokenType.ISSUE_KEY
        };
      }
      return null;
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/code.js
var require_code4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.code = void 0;
    var code = function code2(text) {
      return "{{".concat(text, "}}");
    };
    exports.code = code;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/color.js
var require_color2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.textColor = void 0;
    var textColor = function textColor2(text, attrs) {
      return "{color:".concat(attrs.color, "}").concat(text, "{color}");
    };
    exports.textColor = textColor;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/__base.js
var require_base = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/__base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.baseMarkPattern = void 0;
    var baseMarkPattern = function baseMarkPattern2(text, token) {
      if (/^\s*$/.test(text)) {
        return text;
      }
      return text.replace(/^\s*/, "$&".concat(token)).replace(/\s*$/, "".concat(token, "$&"));
    };
    exports.baseMarkPattern = baseMarkPattern;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/em.js
var require_em2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/em.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.em = void 0;
    var _base = require_base();
    var em = function em2(text) {
      if (text.startsWith("\u2014 ")) {
        return (0, _base.baseMarkPattern)(text.substring(2), "??");
      }
      return (0, _base.baseMarkPattern)(text, "_");
    };
    exports.em = em;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/link.js
var require_link4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.link = void 0;
    var link = function link2(text, attrs) {
      return "[".concat(text, "|").concat(attrs.href, "]");
    };
    exports.link = link;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/strike.js
var require_strike2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/strike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strike = void 0;
    var _base = require_base();
    var strike = function strike2(text) {
      return (0, _base.baseMarkPattern)(text, "-");
    };
    exports.strike = strike;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/strong.js
var require_strong3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/strong.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.strong = void 0;
    var _base = require_base();
    var strong = function strong2(text) {
      return (0, _base.baseMarkPattern)(text, "*");
    };
    exports.strong = strong;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/subsup.js
var require_subsup2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/subsup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subsup = void 0;
    var _base = require_base();
    var subsup = function subsup2(text, attrs) {
      if (attrs.type === "sub") {
        return (0, _base.baseMarkPattern)(text, "~");
      } else {
        return (0, _base.baseMarkPattern)(text, "^");
      }
    };
    exports.subsup = subsup;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/underline.js
var require_underline2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/marks/underline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.underline = void 0;
    var _base = require_base();
    var underline = function underline2(text) {
      return (0, _base.baseMarkPattern)(text, "+");
    };
    exports.underline = underline;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/text.js
var require_text8 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/text.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.text = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _keyword = require_keyword();
    var _code = require_code4();
    var _color = require_color2();
    var _em = require_em2();
    var _link = require_link4();
    var _strike = require_strike2();
    var _strong = require_strong3();
    var _subsup = require_subsup2();
    var _underline = require_underline2();
    var markEncoderMapping = /* @__PURE__ */ new Map([["em", _em.em], ["strike", _strike.strike], ["strong", _strong.strong], ["subsup", _subsup.subsup], ["underline", _underline.underline], ["textColor", _color.textColor], ["link", _link.link], ["code", _code.code]]);
    var MENTION_ESCAPE_PATTERN = "(\\[~)";
    var MEDIA_ESCAPE_PATTERN = "(![^ !]+)(!)";
    var isEscapeNeeded = function isEscapeNeeded2(node, parent) {
      return !(parent && parent.type.name === "codeBlock" || node.marks.find(function(m) {
        return m.type.name === "code";
      }) !== void 0);
    };
    function escapingWikiFormatter(text2) {
      var pattern = [MENTION_ESCAPE_PATTERN].concat((0, _toConsumableArray2.default)(_keyword.macroKeywordTokenMap.map(function(macro) {
        return "(".concat(macro.regex.source.replace("^", ""), ")");
      }))).join("|");
      return text2.replace(new RegExp(pattern, "g"), "\\$&").replace(new RegExp(MEDIA_ESCAPE_PATTERN, "g"), "\\$1\\$2");
    }
    var text = function text2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, parent = _ref.parent;
      var result = isEscapeNeeded(node, parent) ? escapingWikiFormatter(node.text) : node.text;
      markEncoderMapping.forEach(function(encoder, markName) {
        var mark = node.marks.find(function(m) {
          return m.type.name === markName;
        });
        if (mark) {
          result = encoder(result, mark.attrs);
        }
      });
      return result;
    };
    exports.text = text;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/inline-card.js
var require_inline_card2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/inline-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inlineCard = void 0;
    var _unknown = require_unknown();
    var _issueKey = require_issue_key();
    var inlineCard = function inlineCard2(node) {
      if (!node.attrs.url) {
        return (0, _unknown.unknown)(node);
      }
      var match = node.attrs.url.match(_issueKey.INLINE_CARD_FROM_TEXT_STAMP);
      if (!match) {
        return "[".concat(node.attrs.url, "|").concat(node.attrs.url, "|smart-link]");
      }
      return "[".concat(match[2], "]");
    };
    exports.inlineCard = inlineCard;
  }
});

// node_modules/@atlaskit/ds-lib/dist/cjs/utils/deprecation-warning.js
var require_deprecation_warning = __commonJS({
  "node_modules/@atlaskit/ds-lib/dist/cjs/utils/deprecation-warning.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    exports.propDeprecationWarning = propDeprecationWarning;
    var _warnOnce = _interopRequireDefault(require_warn_once());
    function deprecationWarning(packageName, api, additionalMessage) {
      (0, _warnOnce.default)("[".concat(packageName, "]: The ").concat(api, " is deprecated.").concat(additionalMessage && " ".concat(additionalMessage)));
    }
    function propDeprecationWarning(packageName, propName, predicate, deprecationAnnouncementOnDAC) {
      if (typeof process !== "undefined" && process.env.NODE_ENV === "development" && predicate) {
        (0, _warnOnce.default)("[".concat(packageName, "]: The ").concat(propName, " prop is deprecated and will be removed, please migrate away.\nPublic announcement: ").concat(deprecationAnnouncementOnDAC));
      }
    }
  }
});

// node_modules/@atlaskit/theme/dist/cjs/constants.js
var require_constants2 = __commonJS({
  "node_modules/@atlaskit/theme/dist/cjs/constants.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.visuallyHidden = exports.skeletonShimmer = exports.noFocusRing = exports.layers = exports.gridSize = exports.fontSizeSmall = exports.fontSize = exports.fontFamily = exports.focusRing = exports.codeFontFamily = exports.borderRadius = exports.assistive = exports.THEME_MODES = exports.DEFAULT_THEME_MODE = exports.CHANNEL = void 0;
    var _deprecationWarning = _interopRequireDefault(require_deprecation_warning());
    var _colors = require_colors2();
    var CHANNEL = "__ATLASKIT_THEME__";
    exports.CHANNEL = CHANNEL;
    var DEFAULT_THEME_MODE = "light";
    exports.DEFAULT_THEME_MODE = DEFAULT_THEME_MODE;
    var THEME_MODES = ["light", "dark"];
    exports.THEME_MODES = THEME_MODES;
    var borderRadius = function borderRadius2() {
      return 3;
    };
    exports.borderRadius = borderRadius;
    var gridSize = function gridSize2() {
      return 8;
    };
    exports.gridSize = gridSize;
    var fontSize = function fontSize2() {
      return 14;
    };
    exports.fontSize = fontSize;
    var fontSizeSmall = function fontSizeSmall2() {
      return 11;
    };
    exports.fontSizeSmall = fontSizeSmall;
    var fontFamily = function fontFamily2() {
      return "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif";
    };
    exports.fontFamily = fontFamily;
    var codeFontFamily = function codeFontFamily2() {
      return "'SFMono-Medium', 'SF Mono', 'Segoe UI Mono', 'Roboto Mono', 'Ubuntu Mono', Menlo, Consolas, Courier, monospace";
    };
    exports.codeFontFamily = codeFontFamily;
    var focusRing = function focusRing2() {
      var color = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "var(--ds-border-focused, ".concat(_colors.B100, ")");
      var outlineWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : gridSize() / 4;
      (0, _deprecationWarning.default)("@atlaskit/theme", "focus ring mixin", "Please use `@atlaskit/focus-ring` instead.");
      return "\n  &:focus {\n    outline: none;\n    box-shadow: 0px 0px 0px ".concat(outlineWidth, "px ").concat(color, ";\n  }\n");
    };
    exports.focusRing = focusRing;
    var noFocusRing = function noFocusRing2() {
      return "\n  box-shadow: none;\n";
    };
    exports.noFocusRing = noFocusRing;
    var layers = {
      card: function card() {
        return 100;
      },
      navigation: function navigation() {
        return 200;
      },
      dialog: function dialog() {
        return 300;
      },
      layer: function layer() {
        return 400;
      },
      blanket: function blanket() {
        return 500;
      },
      modal: function modal() {
        return 510;
      },
      flag: function flag() {
        return 600;
      },
      spotlight: function spotlight() {
        return 700;
      },
      tooltip: function tooltip() {
        return 800;
      }
    };
    exports.layers = layers;
    var visuallyHidden = function visuallyHidden2() {
      (0, _deprecationWarning.default)("@atlaskit/theme", "visually hidden mixin", "Please use `@atlaskit/visually-hidden` instead.");
      return {
        border: "0 !important",
        clip: "rect(1px, 1px, 1px, 1px) !important",
        height: "1px !important",
        overflow: "hidden !important",
        padding: "0 !important",
        position: "absolute !important",
        width: "1px !important",
        whiteSpace: "nowrap !important"
      };
    };
    exports.visuallyHidden = visuallyHidden;
    var assistive = visuallyHidden;
    exports.assistive = assistive;
    var skeletonShimmer = function skeletonShimmer2() {
      return {
        css: {
          backgroundColor: "var(--ds-skeleton, ".concat((0, _colors.skeleton)(), ")"),
          animationDuration: "1.5s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate"
        },
        keyframes: {
          from: {
            backgroundColor: "var(--ds-skeleton, ".concat((0, _colors.skeleton)(), ")")
          },
          to: {
            backgroundColor: "var(--ds-skeleton-subtle, ".concat(_colors.N30A, ")")
          }
        }
      };
    };
    exports.skeletonShimmer = skeletonShimmer;
  }
});

// node_modules/@atlaskit/theme/dist/cjs/utils/get-theme.js
var require_get_theme = __commonJS({
  "node_modules/@atlaskit/theme/dist/cjs/utils/get-theme.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getTheme;
    var _constants = require_constants2();
    function getTheme(props) {
      if (props && props.theme) {
        if (_constants.CHANNEL in props.theme) {
          return props.theme[_constants.CHANNEL];
        } else if ("mode" in props.theme && _constants.THEME_MODES.includes(props.theme.mode)) {
          return props.theme;
        }
      }
      return {
        mode: _constants.DEFAULT_THEME_MODE
      };
    }
  }
});

// node_modules/@atlaskit/theme/dist/cjs/utils/themed.js
var require_themed = __commonJS({
  "node_modules/@atlaskit/theme/dist/cjs/utils/themed.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = themed;
    var _getTheme = _interopRequireDefault(require_get_theme());
    function themedVariants(variantProp, variants) {
      return function(props) {
        var theme = (0, _getTheme.default)(props);
        if (props && props[variantProp] && variants) {
          var modes = variants[props[variantProp]];
          if (modes && modes[theme.mode]) {
            var value = modes[theme.mode];
            if (value) {
              return value;
            }
          }
        }
        return "";
      };
    }
    function themed(modesOrVariant, variantModes) {
      if (typeof modesOrVariant === "string") {
        return themedVariants(modesOrVariant, variantModes);
      }
      var modes = modesOrVariant;
      return function(props) {
        var theme = (0, _getTheme.default)(props);
        if (theme.mode in modes) {
          var value = modes[theme.mode];
          if (value) {
            return value;
          }
        }
        return "";
      };
    }
  }
});

// node_modules/@atlaskit/theme/dist/cjs/colors.js
var require_colors2 = __commonJS({
  "node_modules/@atlaskit/theme/dist/cjs/colors.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.R75 = exports.R500 = exports.R50 = exports.R400 = exports.R300 = exports.R200 = exports.R100 = exports.P75 = exports.P500 = exports.P50 = exports.P400 = exports.P300 = exports.P200 = exports.P100 = exports.N90A = exports.N900 = exports.N90 = exports.N80A = exports.N800A = exports.N800 = exports.N80 = exports.N70A = exports.N700A = exports.N700 = exports.N70 = exports.N60A = exports.N600A = exports.N600 = exports.N60 = exports.N50A = exports.N500A = exports.N500 = exports.N50 = exports.N40A = exports.N400A = exports.N400 = exports.N40 = exports.N30A = exports.N300A = exports.N300 = exports.N30 = exports.N20A = exports.N200A = exports.N200 = exports.N20 = exports.N10A = exports.N100A = exports.N100 = exports.N10 = exports.N0 = exports.G75 = exports.G500 = exports.G50 = exports.G400 = exports.G300 = exports.G200 = exports.G100 = exports.DN90A = exports.DN900 = exports.DN90 = exports.DN80A = exports.DN800A = exports.DN800 = exports.DN80 = exports.DN70A = exports.DN700A = exports.DN700 = exports.DN70 = exports.DN60A = exports.DN600A = exports.DN600 = exports.DN60 = exports.DN50A = exports.DN500A = exports.DN500 = exports.DN50 = exports.DN40A = exports.DN400A = exports.DN400 = exports.DN40 = exports.DN30A = exports.DN300A = exports.DN300 = exports.DN30 = exports.DN20A = exports.DN200A = exports.DN200 = exports.DN20 = exports.DN10A = exports.DN100A = exports.DN100 = exports.DN10 = exports.DN0 = exports.B75 = exports.B500 = exports.B50 = exports.B400 = exports.B300 = exports.B200 = exports.B100 = void 0;
    exports.yellow = exports.textHover = exports.textActive = exports.text = exports.teal = exports.subtleText = exports.subtleHeading = exports.skeleton = exports.red = exports.purple = exports.primary = exports.placeholderText = exports.linkOutline = exports.linkHover = exports.linkActive = exports.link = exports.heading = exports.green = exports.codeBlock = exports.blue = exports.backgroundOnLayer = exports.backgroundHover = exports.backgroundActive = exports.background = exports.Y75 = exports.Y500 = exports.Y50 = exports.Y400 = exports.Y300 = exports.Y200 = exports.Y100 = exports.T75 = exports.T500 = exports.T50 = exports.T400 = exports.T300 = exports.T200 = exports.T100 = void 0;
    var _themed = _interopRequireDefault(require_themed());
    var R50 = "#FFEBE6";
    exports.R50 = R50;
    var R75 = "#FFBDAD";
    exports.R75 = R75;
    var R100 = "#FF8F73";
    exports.R100 = R100;
    var R200 = "#FF7452";
    exports.R200 = R200;
    var R300 = "#FF5630";
    exports.R300 = R300;
    var R400 = "#DE350B";
    exports.R400 = R400;
    var R500 = "#BF2600";
    exports.R500 = R500;
    var Y50 = "#FFFAE6";
    exports.Y50 = Y50;
    var Y75 = "#FFF0B3";
    exports.Y75 = Y75;
    var Y100 = "#FFE380";
    exports.Y100 = Y100;
    var Y200 = "#FFC400";
    exports.Y200 = Y200;
    var Y300 = "#FFAB00";
    exports.Y300 = Y300;
    var Y400 = "#FF991F";
    exports.Y400 = Y400;
    var Y500 = "#FF8B00";
    exports.Y500 = Y500;
    var G50 = "#E3FCEF";
    exports.G50 = G50;
    var G75 = "#ABF5D1";
    exports.G75 = G75;
    var G100 = "#79F2C0";
    exports.G100 = G100;
    var G200 = "#57D9A3";
    exports.G200 = G200;
    var G300 = "#36B37E";
    exports.G300 = G300;
    var G400 = "#00875A";
    exports.G400 = G400;
    var G500 = "#006644";
    exports.G500 = G500;
    var B50 = "#DEEBFF";
    exports.B50 = B50;
    var B75 = "#B3D4FF";
    exports.B75 = B75;
    var B100 = "#4C9AFF";
    exports.B100 = B100;
    var B200 = "#2684FF";
    exports.B200 = B200;
    var B300 = "#0065FF";
    exports.B300 = B300;
    var B400 = "#0052CC";
    exports.B400 = B400;
    var B500 = "#0747A6";
    exports.B500 = B500;
    var P50 = "#EAE6FF";
    exports.P50 = P50;
    var P75 = "#C0B6F2";
    exports.P75 = P75;
    var P100 = "#998DD9";
    exports.P100 = P100;
    var P200 = "#8777D9";
    exports.P200 = P200;
    var P300 = "#6554C0";
    exports.P300 = P300;
    var P400 = "#5243AA";
    exports.P400 = P400;
    var P500 = "#403294";
    exports.P500 = P500;
    var T50 = "#E6FCFF";
    exports.T50 = T50;
    var T75 = "#B3F5FF";
    exports.T75 = T75;
    var T100 = "#79E2F2";
    exports.T100 = T100;
    var T200 = "#00C7E6";
    exports.T200 = T200;
    var T300 = "#00B8D9";
    exports.T300 = T300;
    var T400 = "#00A3BF";
    exports.T400 = T400;
    var T500 = "#008DA6";
    exports.T500 = T500;
    var N0 = "#FFFFFF";
    exports.N0 = N0;
    var N10 = "#FAFBFC";
    exports.N10 = N10;
    var N20 = "#F4F5F7";
    exports.N20 = N20;
    var N30 = "#EBECF0";
    exports.N30 = N30;
    var N40 = "#DFE1E6";
    exports.N40 = N40;
    var N50 = "#C1C7D0";
    exports.N50 = N50;
    var N60 = "#B3BAC5";
    exports.N60 = N60;
    var N70 = "#A5ADBA";
    exports.N70 = N70;
    var N80 = "#97A0AF";
    exports.N80 = N80;
    var N90 = "#8993A4";
    exports.N90 = N90;
    var N100 = "#7A869A";
    exports.N100 = N100;
    var N200 = "#6B778C";
    exports.N200 = N200;
    var N300 = "#5E6C84";
    exports.N300 = N300;
    var N400 = "#505F79";
    exports.N400 = N400;
    var N500 = "#42526E";
    exports.N500 = N500;
    var N600 = "#344563";
    exports.N600 = N600;
    var N700 = "#253858";
    exports.N700 = N700;
    var N800 = "#172B4D";
    exports.N800 = N800;
    var N900 = "#091E42";
    exports.N900 = N900;
    var N10A = "rgba(9, 30, 66, 0.02)";
    exports.N10A = N10A;
    var N20A = "rgba(9, 30, 66, 0.04)";
    exports.N20A = N20A;
    var N30A = "rgba(9, 30, 66, 0.08)";
    exports.N30A = N30A;
    var N40A = "rgba(9, 30, 66, 0.13)";
    exports.N40A = N40A;
    var N50A = "rgba(9, 30, 66, 0.25)";
    exports.N50A = N50A;
    var N60A = "rgba(9, 30, 66, 0.31)";
    exports.N60A = N60A;
    var N70A = "rgba(9, 30, 66, 0.36)";
    exports.N70A = N70A;
    var N80A = "rgba(9, 30, 66, 0.42)";
    exports.N80A = N80A;
    var N90A = "rgba(9, 30, 66, 0.48)";
    exports.N90A = N90A;
    var N100A = "rgba(9, 30, 66, 0.54)";
    exports.N100A = N100A;
    var N200A = "rgba(9, 30, 66, 0.60)";
    exports.N200A = N200A;
    var N300A = "rgba(9, 30, 66, 0.66)";
    exports.N300A = N300A;
    var N400A = "rgba(9, 30, 66, 0.71)";
    exports.N400A = N400A;
    var N500A = "rgba(9, 30, 66, 0.77)";
    exports.N500A = N500A;
    var N600A = "rgba(9, 30, 66, 0.82)";
    exports.N600A = N600A;
    var N700A = "rgba(9, 30, 66, 0.89)";
    exports.N700A = N700A;
    var N800A = "rgba(9, 30, 66, 0.95)";
    exports.N800A = N800A;
    var DN900 = "#E6EDFA";
    exports.DN900 = DN900;
    var DN800 = "#DCE5F5";
    exports.DN800 = DN800;
    var DN700 = "#CED9EB";
    exports.DN700 = DN700;
    var DN600 = "#B8C7E0";
    exports.DN600 = DN600;
    var DN500 = "#ABBBD6";
    exports.DN500 = DN500;
    var DN400 = "#9FB0CC";
    exports.DN400 = DN400;
    var DN300 = "#8C9CB8";
    exports.DN300 = DN300;
    var DN200 = "#7988A3";
    exports.DN200 = DN200;
    var DN100 = "#67758F";
    exports.DN100 = DN100;
    var DN90 = "#56637A";
    exports.DN90 = DN90;
    var DN80 = "#455166";
    exports.DN80 = DN80;
    var DN70 = "#3B475C";
    exports.DN70 = DN70;
    var DN60 = "#313D52";
    exports.DN60 = DN60;
    var DN50 = "#283447";
    exports.DN50 = DN50;
    var DN40 = "#202B3D";
    exports.DN40 = DN40;
    var DN30 = "#1B2638";
    exports.DN30 = DN30;
    var DN20 = "#121A29";
    exports.DN20 = DN20;
    var DN10 = "#0E1624";
    exports.DN10 = DN10;
    var DN0 = "#0D1424";
    exports.DN0 = DN0;
    var DN800A = "rgba(13, 20, 36, 0.06)";
    exports.DN800A = DN800A;
    var DN700A = "rgba(13, 20, 36, 0.14)";
    exports.DN700A = DN700A;
    var DN600A = "rgba(13, 20, 36, 0.18)";
    exports.DN600A = DN600A;
    var DN500A = "rgba(13, 20, 36, 0.29)";
    exports.DN500A = DN500A;
    var DN400A = "rgba(13, 20, 36, 0.36)";
    exports.DN400A = DN400A;
    var DN300A = "rgba(13, 20, 36, 0.40)";
    exports.DN300A = DN300A;
    var DN200A = "rgba(13, 20, 36, 0.47)";
    exports.DN200A = DN200A;
    var DN100A = "rgba(13, 20, 36, 0.53)";
    exports.DN100A = DN100A;
    var DN90A = "rgba(13, 20, 36, 0.63)";
    exports.DN90A = DN90A;
    var DN80A = "rgba(13, 20, 36, 0.73)";
    exports.DN80A = DN80A;
    var DN70A = "rgba(13, 20, 36, 0.78)";
    exports.DN70A = DN70A;
    var DN60A = "rgba(13, 20, 36, 0.81)";
    exports.DN60A = DN60A;
    var DN50A = "rgba(13, 20, 36, 0.85)";
    exports.DN50A = DN50A;
    var DN40A = "rgba(13, 20, 36, 0.89)";
    exports.DN40A = DN40A;
    var DN30A = "rgba(13, 20, 36, 0.92)";
    exports.DN30A = DN30A;
    var DN20A = "rgba(13, 20, 36, 0.95)";
    exports.DN20A = DN20A;
    var DN10A = "rgba(13, 20, 36, 0.97)";
    exports.DN10A = DN10A;
    var background = (0, _themed.default)({
      light: "var(--ds-surface, ".concat(N0, ")"),
      dark: "var(--ds-surface, ".concat(DN30, ")")
    });
    exports.background = background;
    var backgroundActive = (0, _themed.default)({
      light: "var(--ds-background-selected, ".concat(B50, ")"),
      dark: "var(--ds-background-selected, ".concat(B75, ")")
    });
    exports.backgroundActive = backgroundActive;
    var backgroundHover = (0, _themed.default)({
      light: "var(--ds-background-neutral-hovered, ".concat(N30, ")"),
      dark: "var(--ds-background-neutral-hovered, ".concat(DN70, ")")
    });
    exports.backgroundHover = backgroundHover;
    var backgroundOnLayer = (0, _themed.default)({
      light: "var(--ds-surface-overlay, ".concat(N0, ")"),
      dark: "var(--ds-surface-overlay, ".concat(DN50, ")")
    });
    exports.backgroundOnLayer = backgroundOnLayer;
    var text = (0, _themed.default)({
      light: "var(--ds-text, ".concat(N900, ")"),
      dark: "var(--ds-text, ".concat(DN600, ")")
    });
    exports.text = text;
    var textHover = (0, _themed.default)({
      light: "var(--ds-text, ".concat(N800, ")"),
      dark: "var(--ds-text, ".concat(DN600, ")")
    });
    exports.textHover = textHover;
    var textActive = (0, _themed.default)({
      light: "var(--ds-text-selected, ".concat(B400, ")"),
      dark: "var(--ds-text-selected, ".concat(B400, ")")
    });
    exports.textActive = textActive;
    var subtleText = (0, _themed.default)({
      light: "var(--ds-text-subtlest, ".concat(N200, ")"),
      dark: "var(--ds-text-subtlest, ".concat(DN300, ")")
    });
    exports.subtleText = subtleText;
    var placeholderText = (0, _themed.default)({
      light: "var(--ds-text-subtlest, ".concat(N100, ")"),
      dark: "var(--ds-text-subtlest, ".concat(DN200, ")")
    });
    exports.placeholderText = placeholderText;
    var heading = (0, _themed.default)({
      light: "var(--ds-text, ".concat(N800, ")"),
      dark: "var(--ds-text, ".concat(DN600, ")")
    });
    exports.heading = heading;
    var subtleHeading = (0, _themed.default)({
      light: "var(--ds-text-subtlest, ".concat(N200, ")"),
      dark: "var(--ds-text-subtlest, ".concat(DN300, ")")
    });
    exports.subtleHeading = subtleHeading;
    var codeBlock = (0, _themed.default)({
      light: N20,
      dark: DN50
    });
    exports.codeBlock = codeBlock;
    var link = (0, _themed.default)({
      light: "var(--ds-link, ".concat(B400, ")"),
      dark: "var(--ds-link, ".concat(B100, ")")
    });
    exports.link = link;
    var linkHover = (0, _themed.default)({
      light: "var(--ds-link-pressed, ".concat(B300, ")"),
      dark: "var(--ds-link-pressed, ".concat(B200, ")")
    });
    exports.linkHover = linkHover;
    var linkActive = (0, _themed.default)({
      light: "var(--ds-link-pressed, ".concat(B500, ")"),
      dark: "var(--ds-link-pressed, ".concat(B100, ")")
    });
    exports.linkActive = linkActive;
    var linkOutline = (0, _themed.default)({
      light: "var(--ds-border-focused, ".concat(B100, ")"),
      dark: "var(--ds-border-focused, ".concat(B200, ")")
    });
    exports.linkOutline = linkOutline;
    var primary = (0, _themed.default)({
      light: "var(--ds-background-brand-bold, ".concat(B400, ")"),
      dark: "var(--ds-background-brand-bold, ".concat(B100, ")")
    });
    exports.primary = primary;
    var blue = (0, _themed.default)({
      light: B400,
      dark: B100
    });
    exports.blue = blue;
    var teal = (0, _themed.default)({
      light: T300,
      dark: T200
    });
    exports.teal = teal;
    var purple = (0, _themed.default)({
      light: P300,
      dark: P100
    });
    exports.purple = purple;
    var red = (0, _themed.default)({
      light: R300,
      dark: R300
    });
    exports.red = red;
    var yellow = (0, _themed.default)({
      light: Y300,
      dark: Y300
    });
    exports.yellow = yellow;
    var green = (0, _themed.default)({
      light: G300,
      dark: G300
    });
    exports.green = green;
    var skeleton = function skeleton2() {
      return "var(--ds-skeleton, ".concat(N20A, ")");
    };
    exports.skeleton = skeleton;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/status.js
var require_status2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/status.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.status = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _color = require_color2();
    var _colors = require_colors2();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var color = {
      grey: _colors.N80,
      purple: _colors.P300,
      blue: _colors.T300,
      red: _colors.R300,
      yellow: _colors.Y400,
      green: _colors.G300
    };
    var status = function status2(node) {
      var text = "*[ ".concat(node.attrs.text.toUpperCase(), " ]*");
      var newAttrs = _objectSpread({}, node.attrs);
      if (color[node.attrs.color]) {
        newAttrs.color = color[node.attrs.color];
      } else {
        newAttrs.color = color["grey"];
      }
      return (0, _color.textColor)(text, newAttrs);
    };
    exports.status = status;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/date.js
var require_date2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.date = void 0;
    var date = function date2(node) {
      var addLeadingZero = function addLeadingZero2(val) {
        if (val < 10) {
          return "0".concat(val);
        }
        return val;
      };
      var result = new Date(Number(node.attrs.timestamp));
      return "{{".concat(result.getUTCFullYear(), "-").concat(addLeadingZero(result.getUTCMonth() + 1), "-").concat(addLeadingZero(result.getUTCDate()), "}}");
    };
    exports.date = date;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/inlines.js
var require_inlines = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/inlines.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inlines = void 0;
    var _emoji = require_emoji3();
    var _hardBreak = require_hard_break2();
    var _mediaInline = require_media_inline2();
    var _mention = require_mention2();
    var _text = require_text8();
    var _inlineCard = require_inline_card2();
    var _status = require_status2();
    var _unknown = require_unknown();
    var _date = require_date2();
    var inlinesEncoderMapping = {
      emoji: _emoji.emoji,
      hardBreak: _hardBreak.hardBreak,
      mediaInline: _mediaInline.mediaInline,
      mention: _mention.mention,
      text: _text.text,
      inlineCard: _inlineCard.inlineCard,
      status: _status.status,
      date: _date.date
    };
    var inlines = function inlines2(node, opts) {
      var encoder = inlinesEncoderMapping[node.type.name];
      if (encoder) {
        return encoder(node, opts);
      }
      return (0, _unknown.unknown)(node);
    };
    exports.inlines = inlines;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/paragraph.js
var require_paragraph5 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/paragraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.paragraph = void 0;
    var _inlines = require_inlines();
    var paragraph = function paragraph2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = "";
      node.forEach(function(n) {
        result += (0, _inlines.inlines)(n, {
          context
        });
      });
      return result;
    };
    exports.paragraph = paragraph;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/code-block.js
var require_code_block2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/code-block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeBlock = void 0;
    var _inlines = require_inlines();
    var supportedLanguageInWiki = ["actionscript", "ada", "applescript", "bash", "c", "c#", "c++", "cpp", "css", "erlang", "go", "groovy", "haskell", "html", "java", "javascript", "js", "json", "lua", "none", "nyan", "objc", "perl", "php", "python", "r", "rainbow", "ruby", "scala", "sh", "sql", "swift", "visualbasic", "xml", "yaml"];
    var codeBlock = function codeBlock2(node) {
      var result = "";
      node.forEach(function(n) {
        result += (0, _inlines.inlines)(n, {
          parent: node
        });
      });
      if (supportedLanguageInWiki.indexOf(node.attrs.language) !== -1) {
        return "{code:".concat(node.attrs.language, "}").concat(result, "{code}");
      } else {
        return "{noformat}".concat(result, "{noformat}");
      }
    };
    exports.codeBlock = codeBlock;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/caption.js
var require_caption2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/caption.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.caption = void 0;
    var _inlines = require_inlines();
    var caption = function caption2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = "";
      node.forEach(function(n) {
        result += (0, _inlines.inlines)(n, {
          context
        });
      });
      return result;
    };
    exports.caption = caption;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media.js
var require_media4 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.media = void 0;
    var media = function media2(node) {
      var _context$conversion2, _context$conversion2$, _context$conversion2$2;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context, parent = _ref.parent;
      var wikiAttrs = [];
      if (parent && parent.attrs.width) {
        wikiAttrs.push("width=".concat(parent.attrs.width, "%"));
      } else {
        if (node.attrs.width) {
          wikiAttrs.push("width=".concat(node.attrs.width));
        }
        if (node.attrs.height) {
          wikiAttrs.push("height=".concat(node.attrs.height));
        }
      }
      if (node.attrs.alt) {
        wikiAttrs.push('alt="'.concat(node.attrs.alt, '"'));
      }
      if (node.marks.length) {
        var linkMark = node.marks.find(function(mark) {
          return mark.type.name === "link";
        });
        if (linkMark) {
          wikiAttrs.push('href="'.concat(linkMark === null || linkMark === void 0 ? void 0 : linkMark.attrs.href, '"'));
        }
      }
      var fileName;
      if (node.attrs.type === "external") {
        fileName = node.attrs.url;
      } else {
        var _context$conversion$m, _context$conversion, _context$conversion$m2, _context$conversion$m3;
        fileName = (_context$conversion$m = context === null || context === void 0 ? void 0 : (_context$conversion = context.conversion) === null || _context$conversion === void 0 ? void 0 : (_context$conversion$m2 = _context$conversion.mediaConversion) === null || _context$conversion$m2 === void 0 ? void 0 : (_context$conversion$m3 = _context$conversion$m2[node.attrs.id]) === null || _context$conversion$m3 === void 0 ? void 0 : _context$conversion$m3.transform) !== null && _context$conversion$m !== void 0 ? _context$conversion$m : node.attrs.id;
      }
      if ((context === null || context === void 0 ? void 0 : (_context$conversion2 = context.conversion) === null || _context$conversion2 === void 0 ? void 0 : (_context$conversion2$ = _context$conversion2.mediaConversion) === null || _context$conversion2$ === void 0 ? void 0 : (_context$conversion2$2 = _context$conversion2$[node.attrs.id]) === null || _context$conversion2$2 === void 0 ? void 0 : _context$conversion2$2.embed) === false) {
        return "[^".concat(fileName, "]");
      }
      if (wikiAttrs.length) {
        return "!".concat(fileName, "|").concat(wikiAttrs.join(","), "!");
      }
      return "!".concat(fileName, "|thumbnail!");
    };
    exports.media = media;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media-group.js
var require_media_group2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/media-group.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mediaGroup = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _caption = require_caption2();
    var _media = require_media4();
    var _unknown = require_unknown();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var mediaGroup = function mediaGroup2(node) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var result = [];
      node.forEach(function(n) {
        switch (n.type.name) {
          case "media":
            result.push((0, _media.media)(n, _objectSpread(_objectSpread({}, opts), {}, {
              parent: node
            })));
            break;
          case "caption":
            result.push((0, _caption.caption)(n, opts));
            break;
          default:
            result.push((0, _unknown.unknown)(n));
            break;
        }
      });
      return result.join("\n");
    };
    exports.mediaGroup = mediaGroup;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/listItem.js
var require_listItem = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/listItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.listItem = void 0;
    var _ = require_encoder();
    var _paragraph = require_paragraph5();
    var _unknown = require_unknown();
    var _codeBlock = require_code_block2();
    var _mediaGroup = require_media_group2();
    var _mediaInline = require_media_inline2();
    var listItem = function listItem2(node, prefix, context) {
      var result = [];
      var contentBuffer = [];
      node.forEach(function(n) {
        switch (n.type.name) {
          case "paragraph": {
            contentBuffer.push((0, _paragraph.paragraph)(n, {
              context
            }));
            break;
          }
          case "bulletList":
          case "orderedList": {
            if (contentBuffer.length) {
              result.push("".concat(prefix, " ").concat(contentBuffer.join("\n")));
              contentBuffer = [];
            }
            var nestedList = (0, _.encode)(n, context).split("\n").map(function(line) {
              if (["#", "*"].indexOf(line.substr(0, 1)) !== -1) {
                return "".concat(prefix).concat(line);
              }
              return line;
            }).join("\n");
            result.push(nestedList);
            break;
          }
          case "codeBlock": {
            contentBuffer.push((0, _codeBlock.codeBlock)(n));
            break;
          }
          case "mediaInline": {
            contentBuffer.push((0, _mediaInline.mediaInline)(n, {
              context
            }));
            break;
          }
          case "mediaSingle": {
            contentBuffer.push((0, _mediaGroup.mediaGroup)(n, {
              context
            }));
            break;
          }
          default:
            contentBuffer.push((0, _unknown.unknown)(n));
        }
      });
      if (contentBuffer.length) {
        result.push("".concat(prefix, " ").concat(contentBuffer.join("\n")));
      }
      return result.join("\n");
    };
    exports.listItem = listItem;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/bullet-list.js
var require_bullet_list2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/bullet-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bulletList = void 0;
    var _listItem = require_listItem();
    var bulletList = function bulletList2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = [];
      node.forEach(function(item) {
        result.push((0, _listItem.listItem)(item, "*", context));
      });
      return result.join("\n");
    };
    exports.bulletList = bulletList;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/taskItem.js
var require_taskItem = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/taskItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.taskItem = void 0;
    var _inlines = require_inlines();
    var taskItem = function taskItem2(node, nestedLevel) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, context = _ref.context;
      var result = "";
      node.forEach(function(n) {
        var prefix = Array(nestedLevel).fill("*").join("");
        if (node.attrs.state === "DONE") {
          result += "".concat(prefix, " -").concat((0, _inlines.inlines)(n, {
            context
          }), "-");
        } else {
          result += "".concat(prefix, " ").concat((0, _inlines.inlines)(n, {
            context
          }));
        }
      });
      return result;
    };
    exports.taskItem = taskItem;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/taskList.js
var require_taskList = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/taskList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.taskList = void 0;
    var _taskItem = require_taskItem();
    var nestedNode = function nestedNode2(node) {
      var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var result = [];
      node.forEach(function(item) {
        if (item.type.name === "taskList") {
          result.push(nestedNode2(item, depth + 1));
        } else {
          result.push((0, _taskItem.taskItem)(item, depth));
        }
      });
      return result.join("\n");
    };
    var taskList = function taskList2(node) {
      return nestedNode(node);
    };
    exports.taskList = taskList;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/decisionItem.js
var require_decisionItem = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/decisionItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decisionItem = void 0;
    var _inlines = require_inlines();
    var decisionItem = function decisionItem2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = "";
      node.forEach(function(n) {
        result += "* <> ".concat((0, _inlines.inlines)(n, {
          context
        }));
      });
      return result;
    };
    exports.decisionItem = decisionItem;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/decisionList.js
var require_decisionList = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/decisionList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decisionList = void 0;
    var _decisionItem = require_decisionItem();
    var decisionList = function decisionList2(node) {
      var result = [];
      node.forEach(function(item) {
        result.push((0, _decisionItem.decisionItem)(item));
      });
      return result.join("\n");
    };
    exports.decisionList = decisionList;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/doc.js
var require_doc2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/doc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doc = void 0;
    var _ = require_encoder();
    var doc = function doc2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = [];
      node.forEach(function(n) {
        result.push((0, _.encode)(n, context));
      });
      return result.join("\n\n");
    };
    exports.doc = doc;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/expand.js
var require_expand2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.expand = void 0;
    var _ = require_encoder();
    var expand = function expand2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = ["*".concat(node.attrs.title, "*"), ""];
      node.forEach(function(n) {
        result.push((0, _.encode)(n, context));
      });
      return result.join("\n");
    };
    exports.expand = expand;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/heading.js
var require_heading5 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/heading.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.heading = void 0;
    var _inlines = require_inlines();
    var heading = function heading2(node) {
      var result = "";
      node.forEach(function(n) {
        result += (0, _inlines.inlines)(n);
      });
      return "h".concat(node.attrs.level, ". ").concat(result);
    };
    exports.heading = heading;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/ordered-list.js
var require_ordered_list2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/ordered-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.orderedList = void 0;
    var _listItem = require_listItem();
    var orderedList = function orderedList2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = [];
      node.forEach(function(item) {
        result.push((0, _listItem.listItem)(item, "#", context));
      });
      return result.join("\n");
    };
    exports.orderedList = orderedList;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/panel.js
var require_panel2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/panel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.panel = void 0;
    var _ = require_encoder();
    var panelTypeColorMapping = {
      info: "#deebff",
      note: "#eae6ff",
      success: "#e3fcef",
      warning: "#fffae6",
      error: "#ffebe6"
    };
    var panel = function panel2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      var result = [];
      node.forEach(function(n) {
        result.push((0, _.encode)(n, context));
      });
      return "{panel:bgColor=".concat(panelTypeColorMapping[node.attrs.panelType] || "", "}\n").concat(result.join("\n\n"), "\n{panel}");
    };
    exports.panel = panel;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/rule.js
var require_rule3 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/rule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rule = void 0;
    var rule = function rule2(_node) {
      return "----";
    };
    exports.rule = rule;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/table.js
var require_table5 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.table = void 0;
    var _ = require_encoder();
    var _unknown = require_unknown();
    var table = function table2(node) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      try {
        var result = [];
        node.forEach(function(n) {
          result.push(tableRow(n, opts));
        });
        return result.join("\n");
      } catch (err) {
        return (0, _unknown.unknown)(node);
      }
    };
    exports.table = table;
    var tableRow = function tableRow2(node) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var result = "";
      var separator = "|";
      node.forEach(function(n) {
        if (n.type.name === "tableHeader") {
          separator = "||";
        } else {
          separator = "|";
        }
        result = "".concat(result).concat(separator).concat(tableCell(n, opts));
      });
      return "".concat(result).concat(separator);
    };
    var tableCell = function tableCell2(node) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, context = _ref.context;
      if (hasMergedCell(node)) {
        throw new Error("Advanced feature of table is not supported");
      }
      var result = [];
      node.forEach(function(n) {
        result.push((0, _.encode)(n, context));
      });
      var output = result.join("\n").trim();
      return output === "" ? " " : output;
    };
    var hasMergedCell = function hasMergedCell2(node) {
      if (!node.attrs) {
        return false;
      }
      if (node.attrs.colspan && node.attrs.colspan !== 1) {
        return true;
      }
      if (node.attrs.rowspan && node.attrs.rowspan !== 1) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/block-card.js
var require_block_card2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/block-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.blockCard = void 0;
    var _unknown = require_unknown();
    var blockCard = function blockCard2(node) {
      if (!node.attrs.url) {
        return (0, _unknown.unknown)(node);
      }
      return "[".concat(node.attrs.url, "|").concat(node.attrs.url, "|smart-card]");
    };
    exports.blockCard = blockCard;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/embed-card.js
var require_embed_card2 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/nodes/embed-card.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.embedCard = void 0;
    var _unknown = require_unknown();
    var embedCard = function embedCard2(node) {
      if (!node.attrs.url) {
        return (0, _unknown.unknown)(node);
      }
      return "[".concat(node.attrs.url, "|").concat(node.attrs.url, "|smart-embed]");
    };
    exports.embedCard = embedCard;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/index.js
var require_encoder = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/encoder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.encode = encode;
    var _blockquote = require_blockquote4();
    var _bulletList = require_bullet_list2();
    var _taskList = require_taskList();
    var _decisionList = require_decisionList();
    var _codeBlock = require_code_block2();
    var _doc = require_doc2();
    var _expand = require_expand2();
    var _heading = require_heading5();
    var _mediaGroup = require_media_group2();
    var _mediaInline = require_media_inline2();
    var _orderedList = require_ordered_list2();
    var _panel = require_panel2();
    var _paragraph = require_paragraph5();
    var _rule = require_rule3();
    var _table = require_table5();
    var _unknown = require_unknown();
    var _blockCard = require_block_card2();
    var _embedCard = require_embed_card2();
    var _caption = require_caption2();
    var nodeEncoderMapping = {
      blockquote: _blockquote.blockquote,
      bulletList: _bulletList.bulletList,
      taskList: _taskList.taskList,
      decisionList: _decisionList.decisionList,
      codeBlock: _codeBlock.codeBlock,
      doc: _doc.doc,
      heading: _heading.heading,
      caption: _caption.caption,
      mediaGroup: _mediaGroup.mediaGroup,
      mediaInline: _mediaInline.mediaInline,
      mediaSingle: _mediaGroup.mediaGroup,
      orderedList: _orderedList.orderedList,
      panel: _panel.panel,
      paragraph: _paragraph.paragraph,
      rule: _rule.rule,
      table: _table.table,
      blockCard: _blockCard.blockCard,
      embedCard: _embedCard.embedCard,
      expand: _expand.expand
    };
    function encode(node, context) {
      var encoder = nodeEncoderMapping[node.type.name];
      try {
        if (encoder) {
          return encoder(node, {
            context
          });
        }
        return (0, _unknown.unknown)(node);
      } catch (err) {
        return (0, _unknown.unknown)(node);
      }
    }
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/abstract-tree.js
var require_abstract_tree = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/parser/abstract-tree.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _text = require_text6();
    var _normalize = require_normalize3();
    var AbstractTree = /* @__PURE__ */ function() {
      function AbstractTree2(schema, wikiMarkup) {
        (0, _classCallCheck2.default)(this, AbstractTree2);
        this.schema = schema;
        this.wikiMarkup = wikiMarkup;
      }
      (0, _createClass2.default)(AbstractTree2, [{
        key: "getProseMirrorModel",
        value: function getProseMirrorModel(context) {
          var content = (0, _text.parseString)({
            context,
            ignoreTokenTypes: [],
            input: this.wikiMarkup,
            schema: this.schema
          });
          return this.schema.nodes.doc.createChecked({}, (0, _normalize.normalizePMNodes)(content, this.schema, "doc"));
        }
      }]);
      return AbstractTree2;
    }();
    exports.default = AbstractTree;
  }
});

// node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@atlaskit/editor-wikimarkup-transformer/dist/cjs/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.WikiMarkupTransformer = void 0;
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _schemaDefault = require_default_schema();
    var _encoder = require_encoder();
    var _abstractTree = _interopRequireDefault(require_abstract_tree());
    var _issueKey = require_issue_key();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var WikiMarkupTransformer2 = /* @__PURE__ */ function() {
      function WikiMarkupTransformer3() {
        var schema = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _schemaDefault.defaultSchema;
        (0, _classCallCheck2.default)(this, WikiMarkupTransformer3);
        this.schema = schema;
      }
      (0, _createClass2.default)(WikiMarkupTransformer3, [{
        key: "sanitizeWikiMarkup",
        value: function sanitizeWikiMarkup(wikiMarkup) {
          return wikiMarkup.replace(/\0/g, "");
        }
      }, {
        key: "encode",
        value: function encode(node, context) {
          var wikiMarkup = (0, _encoder.encode)(node, normalizeContextObject(context));
          var sanitizedWikiMarkup = this.sanitizeWikiMarkup(wikiMarkup);
          return sanitizedWikiMarkup;
        }
      }, {
        key: "parse",
        value: function parse(wikiMarkup, context) {
          var sanitizedWikiMarkup = this.sanitizeWikiMarkup(wikiMarkup);
          var tree = new _abstractTree.default(this.schema, sanitizedWikiMarkup);
          return tree.getProseMirrorModel(this.buildContext(normalizeContextObject(context)));
        }
      }, {
        key: "buildContext",
        value: function buildContext(context) {
          return context ? _objectSpread(_objectSpread({}, context), {}, {
            issueKeyRegex: context.conversion ? (0, _issueKey.buildIssueKeyRegex)(context.conversion.inlineCardConversion) : void 0
          }) : {};
        }
      }]);
      return WikiMarkupTransformer3;
    }();
    exports.WikiMarkupTransformer = WikiMarkupTransformer2;
    var normalizeContextObject = function normalizeContextObject2(context) {
      if (!context || !context.conversion || !context.conversion.mentionConversion) {
        return context;
      }
      var mentionConversion = {};
      for (var key in context.conversion.mentionConversion) {
        mentionConversion[key.toLowerCase()] = context.conversion.mentionConversion[key];
      }
      context.conversion.mentionConversion = mentionConversion;
      return context;
    };
    var _default = WikiMarkupTransformer2;
    exports.default = _default;
  }
});

// atlaskit-transformer.js
var import_editor_markdown_transformer = __toESM(require_cjs5());
var import_editor_json_transformer = __toESM(require_cjs7());
var import_editor_wikimarkup_transformer = __toESM(require_cjs8());
var transformers = {
  "md": new import_editor_markdown_transformer.MarkdownTransformer(),
  "adf": new import_editor_json_transformer.JSONTransformer(),
  "wiki": new import_editor_wikimarkup_transformer.WikiMarkupTransformer()
};
var readline = require("readline");
var args = process.argv.slice(2);
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var input = "";
rl.on("line", (line) => {
  input += line;
});
rl.on("close", () => {
  let output = transformers[args[1]].encode(transformers[args[0]].parse(input));
  if (typeof output !== "string") {
    output = JSON.stringify(output);
  }
  console.log(output);
});
/*! Bundled license information:

@atlaskit/tokens/dist/cjs/utils/theme-loading.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@atlaskit/tokens/dist/cjs/set-global-theme.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react/cjs/react.production.min.js:
  (** @license React v16.14.0
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (** @license React v16.14.0
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
